/* Program: COMPILER */
#include "pascual.h"
typedef enum { TKUNKNOWN, TKEOF, TKCOMMENT, TKIDENTIFIER, TKNUMBER, TKSTRING, TKPLUS, TKMINUS, TKASTERISK, TKSLASH, TKEQUALS, TKLESSTHAN, TKMORETHAN, TKLBRACKET, TKRBRACKET, TKDOT, TKCOMMA, TKCOLON, TKSEMICOLON, TKCARET, TKLPAREN, TKRPAREN, TKNOTEQUALS, TKLESSOREQUALS, TKMOREOREQUALS, TKASSIGN, TKRANGE, TKAND, TKFALSE, TKTRUE, TKARRAY, TKBEGIN, TKCASE, TKCONST, TKDIV, TKDO, TKDOWNTO, TKELSE, TKEND, TKFILE, TKFOR, TKFORWARD, TKFUNCTION, TKGOTO, TKIF, TKIN, TKLABEL, TKMOD, TKNIL, TKNOT, TKOF, TKOR, TKPACKED, TKPROCEDURE, TKPROGRAM, TKRECORD, TKREPEAT, TKSET, TKTHEN, TKTO, TKTYPE, TKUNTIL, TKVAR, TKWHILE, TKWITH} TLXTOKENID;
typedef struct { int ROW; int COL; } TLXPOS;
typedef struct { TLXTOKENID ID; STRING VALUE; TLXPOS POS; } TLXTOKEN;
const char* EnumValues1[] = { "TKUNKNOWN", "TKEOF", "TKCOMMENT", "TKIDENTIFIER", "TKNUMBER", "TKSTRING", "TKPLUS", "TKMINUS", "TKASTERISK", "TKSLASH", "TKEQUALS", "TKLESSTHAN", "TKMORETHAN", "TKLBRACKET", "TKRBRACKET", "TKDOT", "TKCOMMA", "TKCOLON", "TKSEMICOLON", "TKCARET", "TKLPAREN", "TKRPAREN", "TKNOTEQUALS", "TKLESSOREQUALS", "TKMOREOREQUALS", "TKASSIGN", "TKRANGE", "TKAND", "TKFALSE", "TKTRUE", "TKARRAY", "TKBEGIN", "TKCASE", "TKCONST", "TKDIV", "TKDO", "TKDOWNTO", "TKELSE", "TKEND", "TKFILE", "TKFOR", "TKFORWARD", "TKFUNCTION", "TKGOTO", "TKIF", "TKIN", "TKLABEL", "TKMOD", "TKNIL", "TKNOT", "TKOF", "TKOR", "TKPACKED", "TKPROCEDURE", "TKPROGRAM", "TKRECORD", "TKREPEAT", "TKSET", "TKTHEN", "TKTO", "TKTYPE", "TKUNTIL", "TKVAR", "TKWHILE", "TKWITH" };
STRING LXLINE;
TLXTOKEN LXTOKEN;
TLXPOS LXPOS;
STRING LXPOSSTR(TLXPOS POS) {
STRING return_LXPOSSTR;
STRING ROW;
STRING COL;
ROW = to_str_i(POS.ROW);
COL = to_str_i(POS.COL);
return_LXPOSSTR = cat_ss(cat_ss(cat_ss(str_make(4, "row "), ROW), str_make(5, " col ")), COL);
return return_LXPOSSTR;
}
STRING LXWHERESTR() {
STRING return_LXWHERESTR;
return_LXWHERESTR = cat_ss(str_make(6, " near "), LXPOSSTR(LXTOKEN.POS));
return return_LXWHERESTR;
}
STRING LXTOKENSTR() {
STRING return_LXTOKENSTR;
STRING ID;
ID = to_str_e(LXTOKEN.ID, EnumValues1);
return_LXTOKENSTR = cat_sc(cat_ss(cat_ss(ID, str_make(2, " [")), LXTOKEN.VALUE), ']');
return return_LXTOKENSTR;
}
PBoolean LXISALPHA(char CHR) {
PBoolean return_LXISALPHA;
return_LXISALPHA = ((cmp_cc(CHR, 'a') >= 0) && (cmp_cc(CHR, 'z') <= 0)) || ((cmp_cc(CHR, 'A') >= 0) && (cmp_cc(CHR, 'Z') <= 0));
return return_LXISALPHA;
}
PBoolean LXISDIGIT(char CHR) {
PBoolean return_LXISDIGIT;
return_LXISDIGIT = (cmp_cc(CHR, '0') >= 0) && (cmp_cc(CHR, '9') <= 0);
return return_LXISDIGIT;
}
PBoolean LXISALPHANUM(char CHR) {
PBoolean return_LXISALPHANUM;
return_LXISALPHANUM = LXISALPHA(CHR) || LXISDIGIT(CHR);
return return_LXISALPHANUM;
}
PBoolean LXISTOKENWAITING() {
PBoolean return_LXISTOKENWAITING;
do {
while ((LENGTH(LXLINE) == 0) && !EOF(INPUT)) {
LXPOS.ROW = LXPOS.ROW + 1;
LXPOS.COL = 1;
{
read_s(INPUT, &LXLINE);
readln(INPUT);
}
}
while ((LENGTH(LXLINE) > 0) && (cmp_cc(LXLINE.chr[1], ' ') == 0)) {
LXPOS.COL = LXPOS.COL + 1;
DELETE(&LXLINE, 1, 1);
}
} while (!(EOF(INPUT) || (LENGTH(LXLINE) > 0)));
return_LXISTOKENWAITING = LENGTH(LXLINE) > 0;
return return_LXISTOKENWAITING;
}
void LXGETSYMBOL(TLXTOKENID ID, int LENGTH) {
LXTOKEN.ID = ID;
LXTOKEN.VALUE = COPY(LXLINE, 1, LENGTH);
LXTOKEN.POS = LXPOS;
DELETE(&LXLINE, 1, LENGTH);
LXPOS.COL = LXPOS.COL + LENGTH;
}
void LXGETIDENTIFIER() {
char CHR;
int POS;
PBoolean INTOKEN;
POS = 0;
INTOKEN = 1;
while ((POS < LENGTH(LXLINE)) && INTOKEN) {
CHR = LXLINE.chr[POS + 1];
INTOKEN = LXISALPHANUM(CHR);
if (INTOKEN) POS = POS + 1;
}
LXGETSYMBOL(TKIDENTIFIER, POS);
{
int first = 1;
int last = LENGTH(LXTOKEN.VALUE);
if (first <= last) {
POS = first;
while (1) {
LXTOKEN.VALUE.chr[POS] = UPCASE(LXTOKEN.VALUE.chr[POS]);
if (POS == last) break;
++POS;
}
}
}
if (cmp_ss(LXTOKEN.VALUE, str_make(3, "AND")) == 0) LXTOKEN.ID = TKAND;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(5, "ARRAY")) == 0) LXTOKEN.ID = TKARRAY;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(5, "BEGIN")) == 0) LXTOKEN.ID = TKBEGIN;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(4, "CASE")) == 0) LXTOKEN.ID = TKCASE;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(5, "CONST")) == 0) LXTOKEN.ID = TKCONST;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(3, "DIV")) == 0) LXTOKEN.ID = TKDIV;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(2, "DO")) == 0) LXTOKEN.ID = TKDO;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(6, "DOWNTO")) == 0) LXTOKEN.ID = TKDOWNTO;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(4, "ELSE")) == 0) LXTOKEN.ID = TKELSE;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(3, "END")) == 0) LXTOKEN.ID = TKEND;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(4, "FILE")) == 0) LXTOKEN.ID = TKFILE;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(3, "FOR")) == 0) LXTOKEN.ID = TKFOR;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(7, "FORWARD")) == 0) LXTOKEN.ID = TKFORWARD;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(8, "FUNCTION")) == 0) LXTOKEN.ID = TKFUNCTION;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(4, "GOTO")) == 0) LXTOKEN.ID = TKGOTO;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(2, "IF")) == 0) LXTOKEN.ID = TKIF;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(2, "IN")) == 0) LXTOKEN.ID = TKIN;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(5, "LABEL")) == 0) LXTOKEN.ID = TKLABEL;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(3, "MOD")) == 0) LXTOKEN.ID = TKMOD;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(3, "NIL")) == 0) LXTOKEN.ID = TKNIL;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(3, "NOT")) == 0) LXTOKEN.ID = TKNOT;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(2, "OF")) == 0) LXTOKEN.ID = TKOF;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(2, "OR")) == 0) LXTOKEN.ID = TKOR;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(6, "PACKED")) == 0) LXTOKEN.ID = TKPACKED;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(9, "PROCEDURE")) == 0) LXTOKEN.ID = TKPROCEDURE;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(7, "PROGRAM")) == 0) LXTOKEN.ID = TKPROGRAM;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(6, "RECORD")) == 0) LXTOKEN.ID = TKRECORD;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(6, "REPEAT")) == 0) LXTOKEN.ID = TKREPEAT;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(3, "SET")) == 0) LXTOKEN.ID = TKSET;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(4, "THEN")) == 0) LXTOKEN.ID = TKTHEN;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(2, "TO")) == 0) LXTOKEN.ID = TKTO;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(4, "TYPE")) == 0) LXTOKEN.ID = TKTYPE;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(5, "UNTIL")) == 0) LXTOKEN.ID = TKUNTIL;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(3, "VAR")) == 0) LXTOKEN.ID = TKVAR;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(5, "WHILE")) == 0) LXTOKEN.ID = TKWHILE;
 else if (cmp_ss(LXTOKEN.VALUE, str_make(4, "WITH")) == 0) LXTOKEN.ID = TKWITH;
}
void LXGETNUMBER() {
char CHR;
int POS;
PBoolean INTOKEN;
POS = 0;
INTOKEN = 1;
while ((POS < LENGTH(LXLINE)) && INTOKEN) {
CHR = LXLINE.chr[POS + 1];
INTOKEN = LXISDIGIT(CHR);
if (INTOKEN) POS = POS + 1;
}
LXGETSYMBOL(TKNUMBER, POS);
}
void LXGETSTRING() {
char CHR;
int POS;
PBoolean INSTRING;
POS = 1;
INSTRING = 1;
while (INSTRING) {
POS = POS + 1;
CHR = LXLINE.chr[POS];
if (cmp_cc(CHR, '\'') == 0) {
if ((LENGTH(LXLINE) > POS + 1) && (cmp_cc(LXLINE.chr[POS + 1], '\'') == 0)) POS = POS + 1;
 else INSTRING = 0;
}
}
LXGETSYMBOL(TKSTRING, POS);
}
void LXGETCOMMENT() {
char CHR;
PBoolean SHORTCOMMENT;
char DELIM;
PBoolean CANEND;
CHR = LXLINE.chr[1];
SHORTCOMMENT = cmp_cc(CHR, '{') == 0;
if (SHORTCOMMENT) {
DELIM = '}';
LXGETSYMBOL(TKCOMMENT, 1);
}
 else {
DELIM = ')';
LXGETSYMBOL(TKCOMMENT, 2);
}
do {
if (!LXISTOKENWAITING()) {
{
write_s(STDERR, str_make(22, "End of file in comment"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
CANEND = SHORTCOMMENT || (cmp_cc(CHR, '*') == 0);
CHR = LXLINE.chr[1];
DELETE(&LXLINE, 1, 1);
LXPOS.COL = LXPOS.COL + 1;
} while (!(CANEND && (cmp_cc(CHR, DELIM) == 0)));
LXTOKEN.VALUE = str_make(0, "");
}
void LXREADTOKEN() {
char CHR;
char NXT;
LXTOKEN.VALUE = str_make(0, "");
LXTOKEN.ID = TKUNKNOWN;
if (!LXISTOKENWAITING()) LXTOKEN.ID = TKEOF;
 else {
CHR = LXLINE.chr[1];
if (LXISALPHA(CHR)) LXGETIDENTIFIER();
if ((LXTOKEN.ID == TKUNKNOWN) && LXISDIGIT(CHR)) LXGETNUMBER();
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '\'') == 0)) LXGETSTRING();
if ((LXTOKEN.ID == TKUNKNOWN) && (LENGTH(LXLINE) > 1)) {
NXT = LXLINE.chr[2];
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '<') == 0) && (cmp_cc(NXT, '>') == 0)) LXGETSYMBOL(TKNOTEQUALS, 2);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '<') == 0) && (cmp_cc(NXT, '=') == 0)) LXGETSYMBOL(TKLESSOREQUALS, 2);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '>') == 0) && (cmp_cc(NXT, '=') == 0)) LXGETSYMBOL(TKMOREOREQUALS, 2);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, ':') == 0) && (cmp_cc(NXT, '=') == 0)) LXGETSYMBOL(TKASSIGN, 2);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '.') == 0) && (cmp_cc(NXT, '.') == 0)) LXGETSYMBOL(TKRANGE, 2);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '(') == 0) && (cmp_cc(NXT, '*') == 0)) LXGETCOMMENT();
}
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '+') == 0)) LXGETSYMBOL(TKPLUS, 1);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '-') == 0)) LXGETSYMBOL(TKMINUS, 1);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '*') == 0)) LXGETSYMBOL(TKASTERISK, 1);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '/') == 0)) LXGETSYMBOL(TKSLASH, 1);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '=') == 0)) LXGETSYMBOL(TKEQUALS, 1);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '<') == 0)) LXGETSYMBOL(TKLESSTHAN, 1);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '>') == 0)) LXGETSYMBOL(TKMORETHAN, 1);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '[') == 0)) LXGETSYMBOL(TKLBRACKET, 1);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, ']') == 0)) LXGETSYMBOL(TKRBRACKET, 1);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '.') == 0)) LXGETSYMBOL(TKDOT, 1);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, ',') == 0)) LXGETSYMBOL(TKCOMMA, 1);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, ':') == 0)) LXGETSYMBOL(TKCOLON, 1);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, ';') == 0)) LXGETSYMBOL(TKSEMICOLON, 1);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '^') == 0)) LXGETSYMBOL(TKCARET, 1);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '(') == 0)) LXGETSYMBOL(TKLPAREN, 1);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, ')') == 0)) LXGETSYMBOL(TKRPAREN, 1);
if ((LXTOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '{') == 0)) LXGETCOMMENT();
if (LXTOKEN.ID == TKUNKNOWN) {
{
write_s(STDERR, str_make(17, "Could not parse ["));
write_s(STDERR, LXLINE);
write_s(STDERR, str_make(5, "] at "));
write_s(STDERR, LXPOSSTR(LXPOS));
writeln(STDERR);
}
HALT(1);
}
}
}
void READTOKEN() {
do {
LXREADTOKEN();
} while (!(LXTOKEN.ID != TKCOMMENT));
}
void WANTTOKEN(TLXTOKENID ID) {
if (LXTOKEN.ID != ID) {
{
write_s(STDERR, str_make(13, "Wanted token "));
write_e(STDERR, ID, EnumValues1);
write_s(STDERR, str_make(8, ", found "));
write_s(STDERR, LXTOKENSTR());
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
void WANTTOKEN2(TLXTOKENID ID1, TLXTOKENID ID2) {
if ((LXTOKEN.ID != ID1) && (LXTOKEN.ID != ID2)) {
{
write_s(STDERR, str_make(13, "Wanted token "));
write_e(STDERR, ID1, EnumValues1);
write_s(STDERR, str_make(4, " or "));
write_e(STDERR, ID2, EnumValues1);
write_s(STDERR, str_make(8, ", found "));
write_s(STDERR, LXTOKENSTR());
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
void WANTTOKENANDREAD(TLXTOKENID ID) {
WANTTOKEN(ID);
READTOKEN();
}
STRING GETTOKENVALUEANDREAD(TLXTOKENID ID) {
STRING return_GETTOKENVALUEANDREAD;
WANTTOKEN(ID);
return_GETTOKENVALUEANDREAD = LXTOKEN.VALUE;
READTOKEN();
return return_GETTOKENVALUEANDREAD;
}
void SKIPTOKEN(TLXTOKENID ID) {
if (LXTOKEN.ID == ID) READTOKEN();
}
typedef int TPSENUMINDEX;
typedef int TPSRECORDINDEX;
typedef int TPSARRAYINDEX;
typedef int TPSTYPEINDEX;
typedef enum { TTCBOOLEAN, TTCINTEGER, TTCCHAR, TTCSTRING, TTCTEXT, TTCENUM, TTCRECORD, TTCARRAY} TPSTYPECLASS;
typedef struct { STRING NAME; TPSTYPECLASS CLS; TPSENUMINDEX ENUMINDEX; TPSRECORDINDEX RECORDINDEX; TPSARRAYINDEX ARRAYINDEX; TPSTYPEINDEX ALIASFOR; } TPSTYPE;
typedef struct { int SIZE; STRING VALUES[1 + 128 - 1]; } TPSENUMDEF;
typedef struct { STRING NAME; TPSTYPEINDEX TYPEINDEX; } TPSRECORDFIELD;
typedef struct { int SIZE; TPSRECORDFIELD FIELDS[1 + 16 - 1]; } TPSRECORDDEF;
typedef struct { STRING LOWBOUND; STRING HIGHBOUND; TPSTYPEINDEX TYPEINDEX; } TPSARRAYDEF;
typedef int TPSCONSTANTINDEX;
typedef struct { STRING NAME; TLXTOKEN REPLACEMENT; } TPSCONSTANT;
typedef int TPSVARIABLEINDEX;
typedef struct { STRING NAME; TPSTYPEINDEX TYPEINDEX; PBoolean ISREFERENCE; } TPSVARIABLE;
typedef int TPSFUNCTIONINDEX;
typedef struct { STRING NAME; int ARGCOUNT; TPSVARIABLE ARGS[1 + 4 - 1]; TPSTYPEINDEX RETURNTYPEINDEX; PBoolean ISDECLARATION; } TPSFUNCTION;
typedef struct { int NUMTYPES; int NUMENUMS; int NUMRECORDS; int NUMARRAYS; int NUMCONSTANTS; int NUMVARIABLES; int NUMFUNCTIONS; } TPSSCOPE;
typedef struct { TPSSCOPE SCOPE; TPSTYPE TYPES[1 + 64 - 1]; TPSENUMDEF ENUMS[1 + 16 - 1]; TPSRECORDDEF RECORDS[1 + 32 - 1]; TPSARRAYDEF ARRAYS[1 + 32 - 1]; TPSCONSTANT CONSTANTS[1 + 32 - 1]; TPSVARIABLE VARIABLES[1 + 32 - 1]; TPSFUNCTION FUNCTIONS[1 + 256 - 1]; } TPSDEFS;
const char* EnumValues2[] = { "TTCBOOLEAN", "TTCINTEGER", "TTCCHAR", "TTCSTRING", "TTCTEXT", "TTCENUM", "TTCRECORD", "TTCARRAY" };
TPSDEFS DEFS;
struct { TPSTYPEINDEX PTBOOLEAN; TPSTYPEINDEX PTINTEGER; TPSTYPEINDEX PTCHAR; TPSTYPEINDEX PTSTRING; TPSTYPEINDEX PTTEXT; } PRIMITIVETYPES;
TPSSCOPE GLOBALSCOPE;
void CLEARDEFS() {
DEFS.SCOPE.NUMTYPES = 0;
DEFS.SCOPE.NUMENUMS = 0;
DEFS.SCOPE.NUMRECORDS = 0;
DEFS.SCOPE.NUMARRAYS = 0;
DEFS.SCOPE.NUMCONSTANTS = 0;
DEFS.SCOPE.NUMVARIABLES = 0;
DEFS.SCOPE.NUMFUNCTIONS = 0;
}
TPSSCOPE GETCURRENTSCOPE() {
TPSSCOPE return_GETCURRENTSCOPE;
return_GETCURRENTSCOPE = DEFS.SCOPE;
return return_GETCURRENTSCOPE;
}
void SETCURRENTSCOPE(TPSSCOPE SCOPE) {
DEFS.SCOPE = SCOPE;
}
STRING DEEPTYPENAME(TPSTYPEINDEX TYPEINDEX, PBoolean USEORIGINAL) {
STRING return_DEEPTYPENAME;
TPSTYPE TYP;
STRING RET;
int POS;
do {
TYP = DEFS.TYPES[(TYPEINDEX) - 1];
TYPEINDEX = TYP.ALIASFOR;
} while (!(!USEORIGINAL || (TYPEINDEX == 0)));
if (cmp_ss(TYP.NAME, str_make(0, "")) != 0) return_DEEPTYPENAME = TYP.NAME;
 else if (TYP.CLS == TTCENUM) {
RET = str_of('(');
{
int first = 1;
int last = DEFS.ENUMS[(TYP.ENUMINDEX) - 1].SIZE;
if (first <= last) {
POS = first;
while (1) {
{
if (POS != 1) RET = cat_sc(RET, ',');
RET = cat_ss(RET, DEFS.ENUMS[(TYP.ENUMINDEX) - 1].VALUES[(POS) - 1]);
}
if (POS == last) break;
++POS;
}
}
}
return_DEEPTYPENAME = cat_sc(RET, ')');
}
 else if (TYP.CLS == TTCRECORD) {
RET = str_make(7, "record ");
{
int first = 1;
int last = DEFS.RECORDS[(TYP.RECORDINDEX) - 1].SIZE;
if (first <= last) {
POS = first;
while (1) {
{
if (POS != 1) RET = cat_sc(RET, ',');
RET = cat_ss(RET, DEEPTYPENAME(DEFS.RECORDS[(TYP.RECORDINDEX) - 1].FIELDS[(POS) - 1].TYPEINDEX, 1));
RET = cat_ss(cat_sc(RET, ':'), DEFS.RECORDS[(TYP.RECORDINDEX) - 1].FIELDS[(POS) - 1].NAME);
}
if (POS == last) break;
++POS;
}
}
}
return_DEEPTYPENAME = cat_ss(RET, str_make(4, " end"));
}
 else if (TYP.CLS == TTCARRAY) {
RET = cat_ss(str_make(7, "array ["), DEFS.ARRAYS[(TYP.ARRAYINDEX) - 1].LOWBOUND);
RET = cat_ss(cat_ss(RET, str_make(2, "..")), DEFS.ARRAYS[(TYP.ARRAYINDEX) - 1].HIGHBOUND);
RET = cat_ss(cat_ss(RET, str_make(5, "] of ")), DEEPTYPENAME(DEFS.ARRAYS[(TYP.ARRAYINDEX) - 1].TYPEINDEX, 1));
return_DEEPTYPENAME = RET;
}
 else {
{
write_s(STDERR, str_make(37, "Could not get name for type of class "));
write_e(STDERR, TYP.CLS, EnumValues2);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
return return_DEEPTYPENAME;
}
STRING TYPENAME(TPSTYPEINDEX TYPEINDEX) {
STRING return_TYPENAME;
return_TYPENAME = DEEPTYPENAME(TYPEINDEX, 0);
return return_TYPENAME;
}
TPSTYPE EMPTYTYPE() {
TPSTYPE return_EMPTYTYPE;
TPSTYPE RET;
RET.NAME = str_make(0, "");
RET.CLS = TTCBOOLEAN;
RET.ENUMINDEX = 0;
RET.RECORDINDEX = 0;
RET.ALIASFOR = 0;
return_EMPTYTYPE = RET;
return return_EMPTYTYPE;
}
TPSTYPE TYPEOFCLASS(TPSTYPECLASS CLS) {
TPSTYPE return_TYPEOFCLASS;
TPSTYPE RET;
RET = EMPTYTYPE();
RET.CLS = CLS;
return_TYPEOFCLASS = RET;
return return_TYPEOFCLASS;
}
PBoolean TYPEHASCLASS(TPSTYPEINDEX TYPEINDEX, TPSTYPECLASS CLS) {
PBoolean return_TYPEHASCLASS;
return_TYPEHASCLASS = DEFS.TYPES[(TYPEINDEX) - 1].CLS == CLS;
return return_TYPEHASCLASS;
}
TPSTYPE INTEGERTYPE() {
TPSTYPE return_INTEGERTYPE;
return_INTEGERTYPE = TYPEOFCLASS(TTCINTEGER);
return return_INTEGERTYPE;
}
PBoolean ISINTEGERTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISINTEGERTYPE;
return_ISINTEGERTYPE = TYPEHASCLASS(TYPEINDEX, TTCINTEGER);
return return_ISINTEGERTYPE;
}
TPSTYPE STRINGTYPE() {
TPSTYPE return_STRINGTYPE;
return_STRINGTYPE = TYPEOFCLASS(TTCSTRING);
return return_STRINGTYPE;
}
TPSTYPE CHARTYPE() {
TPSTYPE return_CHARTYPE;
return_CHARTYPE = TYPEOFCLASS(TTCCHAR);
return return_CHARTYPE;
}
PBoolean ISSTRINGTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISSTRINGTYPE;
return_ISSTRINGTYPE = TYPEHASCLASS(TYPEINDEX, TTCSTRING);
return return_ISSTRINGTYPE;
}
PBoolean ISCHARTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISCHARTYPE;
return_ISCHARTYPE = TYPEHASCLASS(TYPEINDEX, TTCCHAR);
return return_ISCHARTYPE;
}
PBoolean ISSTRINGYTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISSTRINGYTYPE;
return_ISSTRINGYTYPE = ISSTRINGTYPE(TYPEINDEX) || ISCHARTYPE(TYPEINDEX);
return return_ISSTRINGYTYPE;
}
TPSTYPE BOOLEANTYPE() {
TPSTYPE return_BOOLEANTYPE;
return_BOOLEANTYPE = TYPEOFCLASS(TTCBOOLEAN);
return return_BOOLEANTYPE;
}
PBoolean ISBOOLEANTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISBOOLEANTYPE;
return_ISBOOLEANTYPE = TYPEHASCLASS(TYPEINDEX, TTCBOOLEAN);
return return_ISBOOLEANTYPE;
}
TPSTYPE TEXTTYPE() {
TPSTYPE return_TEXTTYPE;
return_TEXTTYPE = TYPEOFCLASS(TTCTEXT);
return return_TEXTTYPE;
}
PBoolean ISTEXTTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISTEXTTYPE;
return_ISTEXTTYPE = TYPEHASCLASS(TYPEINDEX, TTCTEXT);
return return_ISTEXTTYPE;
}
PBoolean ISENUMTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISENUMTYPE;
return_ISENUMTYPE = TYPEHASCLASS(TYPEINDEX, TTCENUM);
return return_ISENUMTYPE;
}
PBoolean ISRECORDTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISRECORDTYPE;
return_ISRECORDTYPE = TYPEHASCLASS(TYPEINDEX, TTCRECORD);
return return_ISRECORDTYPE;
}
PBoolean ISARRAYTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISARRAYTYPE;
return_ISARRAYTYPE = TYPEHASCLASS(TYPEINDEX, TTCARRAY);
return return_ISARRAYTYPE;
}
PBoolean ISSAMETYPE(TPSTYPEINDEX AINDEX, TPSTYPEINDEX BINDEX) {
PBoolean return_ISSAMETYPE;
TPSTYPE A;
TPSTYPE B;
A = DEFS.TYPES[(AINDEX) - 1];
B = DEFS.TYPES[(BINDEX) - 1];
return_ISSAMETYPE = (A.CLS == B.CLS) && (A.ENUMINDEX == B.ENUMINDEX) && (A.RECORDINDEX == B.RECORDINDEX);
return return_ISSAMETYPE;
}
TPSTYPEINDEX FINDTYPE(STRING NAME) {
TPSTYPEINDEX return_FINDTYPE;
int POS;
TPSTYPEINDEX RET;
RET = 0;
{
int first = 1;
int last = DEFS.SCOPE.NUMTYPES;
if (first <= last) {
POS = first;
while (1) {
if (cmp_ss(NAME, DEFS.TYPES[(POS) - 1].NAME) == 0) RET = POS;
if (POS == last) break;
++POS;
}
}
}
return_FINDTYPE = RET;
return return_FINDTYPE;
}
TPSTYPEINDEX ADDTYPE(TPSTYPE TYP, TPSSCOPE SCOPE) {
TPSTYPEINDEX return_ADDTYPE;
int POS;
if (cmp_ss(TYP.NAME, str_make(0, "")) != 0) {
POS = FINDTYPE(TYP.NAME);
if (POS > SCOPE.NUMTYPES) {
{
write_s(STDERR, str_make(9, "Variable "));
write_s(STDERR, TYP.NAME);
write_s(STDERR, str_make(20, " already defined as "));
write_s(STDERR, TYPENAME(POS));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
POS = DEFS.SCOPE.NUMTYPES + 1;
if (POS > 64) {
{
write_s(STDERR, str_make(32, "Too many types have been defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
DEFS.TYPES[(POS) - 1] = TYP;
DEFS.SCOPE.NUMTYPES = POS;
return_ADDTYPE = POS;
return return_ADDTYPE;
}
TPSTYPEINDEX FINDTYPEOFENUMVALUE(STRING NAME) {
TPSTYPEINDEX return_FINDTYPEOFENUMVALUE;
TPSTYPEINDEX POS;
int ENUMPOS;
return_FINDTYPEOFENUMVALUE = 0;
{
TPSTYPEINDEX first = 1;
TPSTYPEINDEX last = DEFS.SCOPE.NUMTYPES;
if (first <= last) {
POS = first;
while (1) {
if (DEFS.TYPES[(POS) - 1].ENUMINDEX != 0) {
int first = 1;
int last = DEFS.ENUMS[(DEFS.TYPES[(POS) - 1].ENUMINDEX) - 1].SIZE;
if (first <= last) {
ENUMPOS = first;
while (1) {
if (cmp_ss(NAME, DEFS.ENUMS[(DEFS.TYPES[(POS) - 1].ENUMINDEX) - 1].VALUES[(ENUMPOS) - 1]) == 0) return_FINDTYPEOFENUMVALUE = POS;
if (ENUMPOS == last) break;
++ENUMPOS;
}
}
}
if (POS == last) break;
++POS;
}
}
}
return return_FINDTYPEOFENUMVALUE;
}
TPSENUMINDEX ADDENUM(TPSENUMDEF ENUM) {
TPSENUMINDEX return_ADDENUM;
DEFS.SCOPE.NUMENUMS = DEFS.SCOPE.NUMENUMS + 1;
if (DEFS.SCOPE.NUMENUMS > 16) {
{
write_s(STDERR, str_make(32, "Too many enums have been defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
DEFS.ENUMS[(DEFS.SCOPE.NUMENUMS) - 1] = ENUM;
return_ADDENUM = DEFS.SCOPE.NUMENUMS;
return return_ADDENUM;
}
TPSRECORDINDEX ADDRECORD(TPSRECORDDEF REC) {
TPSRECORDINDEX return_ADDRECORD;
DEFS.SCOPE.NUMRECORDS = DEFS.SCOPE.NUMRECORDS + 1;
if (DEFS.SCOPE.NUMRECORDS > 32) {
{
write_s(STDERR, str_make(34, "Too many records have been defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
DEFS.RECORDS[(DEFS.SCOPE.NUMRECORDS) - 1] = REC;
return_ADDRECORD = DEFS.SCOPE.NUMRECORDS;
return return_ADDRECORD;
}
TPSARRAYINDEX ADDARRAY(TPSARRAYDEF ARR) {
TPSARRAYINDEX return_ADDARRAY;
DEFS.SCOPE.NUMARRAYS = DEFS.SCOPE.NUMARRAYS + 1;
if (DEFS.SCOPE.NUMARRAYS > 32) {
{
write_s(STDERR, str_make(33, "Too many arrays have been defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
DEFS.ARRAYS[(DEFS.SCOPE.NUMARRAYS) - 1] = ARR;
return_ADDARRAY = DEFS.SCOPE.NUMARRAYS;
return return_ADDARRAY;
}
TPSCONSTANTINDEX FINDCONSTANT(STRING NAME) {
TPSCONSTANTINDEX return_FINDCONSTANT;
int POS;
TPSCONSTANTINDEX RET;
RET = 0;
{
int first = 1;
int last = DEFS.SCOPE.NUMCONSTANTS;
if (first <= last) {
POS = first;
while (1) {
if (cmp_ss(NAME, DEFS.CONSTANTS[(POS) - 1].NAME) == 0) RET = POS;
if (POS == last) break;
++POS;
}
}
}
return_FINDCONSTANT = RET;
return return_FINDCONSTANT;
}
TPSCONSTANTINDEX ADDCONSTANT(TPSCONSTANT CONSTANT, TPSSCOPE SCOPE) {
TPSCONSTANTINDEX return_ADDCONSTANT;
int POS;
if (cmp_ss(CONSTANT.NAME, str_make(0, "")) != 0) {
POS = FINDCONSTANT(CONSTANT.NAME);
if (POS > SCOPE.NUMCONSTANTS) {
{
write_s(STDERR, str_make(9, "Constant "));
write_s(STDERR, CONSTANT.NAME);
write_s(STDERR, str_make(16, " already defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
POS = DEFS.SCOPE.NUMCONSTANTS + 1;
if (POS > 32) {
{
write_s(STDERR, str_make(36, "Too many constants have been defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
DEFS.CONSTANTS[(POS) - 1] = CONSTANT;
DEFS.SCOPE.NUMCONSTANTS = POS;
return_ADDCONSTANT = POS;
return return_ADDCONSTANT;
}
TPSVARIABLEINDEX FINDVARIABLE(STRING NAME) {
TPSVARIABLEINDEX return_FINDVARIABLE;
int POS;
TPSVARIABLEINDEX RET;
RET = 0;
{
int first = 1;
int last = DEFS.SCOPE.NUMVARIABLES;
if (first <= last) {
POS = first;
while (1) {
if (cmp_ss(NAME, DEFS.VARIABLES[(POS) - 1].NAME) == 0) RET = POS;
if (POS == last) break;
++POS;
}
}
}
return_FINDVARIABLE = RET;
return return_FINDVARIABLE;
}
TPSVARIABLEINDEX ADDVARIABLE(TPSVARIABLE VARDEF, TPSSCOPE SCOPE) {
TPSVARIABLEINDEX return_ADDVARIABLE;
int POS;
if (cmp_ss(VARDEF.NAME, str_make(0, "")) != 0) {
POS = FINDVARIABLE(VARDEF.NAME);
if (POS > SCOPE.NUMVARIABLES) {
{
write_s(STDERR, str_make(9, "Variable "));
write_s(STDERR, VARDEF.NAME);
write_s(STDERR, str_make(20, " already defined as "));
write_s(STDERR, TYPENAME(DEFS.VARIABLES[(POS) - 1].TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
POS = DEFS.SCOPE.NUMVARIABLES + 1;
if (POS > 32) {
{
write_s(STDERR, str_make(36, "Too many variables have been defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
DEFS.VARIABLES[(POS) - 1] = VARDEF;
DEFS.SCOPE.NUMVARIABLES = POS;
return_ADDVARIABLE = POS;
return return_ADDVARIABLE;
}
TPSFUNCTION EMPTYFUNCTION() {
TPSFUNCTION return_EMPTYFUNCTION;
TPSFUNCTION RET;
RET.NAME = str_make(0, "");
RET.ARGCOUNT = 0;
RET.RETURNTYPEINDEX = 0;
RET.ISDECLARATION = 0;
return_EMPTYFUNCTION = RET;
return return_EMPTYFUNCTION;
}
PBoolean ISEMPTYFUNCTION(TPSFUNCTION FN) {
PBoolean return_ISEMPTYFUNCTION;
return_ISEMPTYFUNCTION = cmp_ss(FN.NAME, str_make(0, "")) == 0;
return return_ISEMPTYFUNCTION;
}
TPSFUNCTIONINDEX FINDFUNCTION(STRING NAME) {
TPSFUNCTIONINDEX return_FINDFUNCTION;
int POS;
return_FINDFUNCTION = 0;
{
int first = 1;
int last = DEFS.SCOPE.NUMFUNCTIONS;
if (first <= last) {
POS = first;
while (1) {
{
if (cmp_ss(DEFS.FUNCTIONS[(POS) - 1].NAME, NAME) == 0) return_FINDFUNCTION = POS;
}
if (POS == last) break;
++POS;
}
}
}
return return_FINDFUNCTION;
}
PBoolean ISSAMEFUNCTIONDEFINITION(TPSFUNCTIONINDEX DECLINDEX, TPSFUNCTION FUN) {
PBoolean return_ISSAMEFUNCTIONDEFINITION;
TPSFUNCTION DECL;
PBoolean SAME;
int POS;
DECL = DEFS.FUNCTIONS[(DECLINDEX) - 1];
SAME = ISSAMETYPE(DECL.RETURNTYPEINDEX, FUN.RETURNTYPEINDEX) && (DECL.ARGCOUNT == FUN.ARGCOUNT);
{
int first = 1;
int last = DECL.ARGCOUNT;
if (first <= last) {
POS = first;
while (1) {
SAME = SAME && ISSAMETYPE(DECL.ARGS[(POS) - 1].TYPEINDEX, FUN.ARGS[(POS) - 1].TYPEINDEX) && (DECL.ARGS[(POS) - 1].ISREFERENCE == FUN.ARGS[(POS) - 1].ISREFERENCE);
if (POS == last) break;
++POS;
}
}
}
return_ISSAMEFUNCTIONDEFINITION = SAME;
return return_ISSAMEFUNCTIONDEFINITION;
}
TPSFUNCTIONINDEX ADDFUNCTION(TPSFUNCTION FUN) {
TPSFUNCTIONINDEX return_ADDFUNCTION;
int POS;
POS = FINDFUNCTION(FUN.NAME);
if (POS != 0) {
if (DEFS.FUNCTIONS[(POS) - 1].ISDECLARATION) {
if (!ISSAMEFUNCTIONDEFINITION(POS, FUN)) {
if (FUN.RETURNTYPEINDEX == 0) {
write_s(STDERR, str_make(10, "Procedure "));
write_s(STDERR, FUN.NAME);
write_s(STDERR, str_make(42, " incompatible with its forward declaration"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
 else {
write_s(STDERR, str_make(9, "Function "));
write_s(STDERR, FUN.NAME);
write_s(STDERR, str_make(42, " incompatible with its forward declaration"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
 else {
if (FUN.RETURNTYPEINDEX == 0) {
write_s(STDERR, str_make(10, "Procedure "));
write_s(STDERR, FUN.NAME);
write_s(STDERR, str_make(16, " already defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
 else {
write_s(STDERR, str_make(9, "Function "));
write_s(STDERR, FUN.NAME);
write_s(STDERR, str_make(16, " already defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
 else {
POS = DEFS.SCOPE.NUMFUNCTIONS + 1;
if (POS > 256) {
{
write_s(STDERR, str_make(36, "Too many functions have been defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
DEFS.SCOPE.NUMFUNCTIONS = POS;
}
DEFS.FUNCTIONS[(POS) - 1] = FUN;
return_ADDFUNCTION = POS;
return return_ADDFUNCTION;
}
TPSTYPEINDEX FINDFIELDTYPE(TPSTYPEINDEX TYPEINDEX, STRING NAME) {
TPSTYPEINDEX return_FINDFIELDTYPE;
TPSTYPE TYP;
TPSRECORDDEF REC;
int POS;
TYP = DEFS.TYPES[(TYPEINDEX) - 1];
if (TYP.CLS != TTCRECORD) {
{
write_s(STDERR, str_make(14, "Not a record: "));
write_s(STDERR, TYP.NAME);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
TYPEINDEX = 0;
REC = DEFS.RECORDS[(TYP.RECORDINDEX) - 1];
{
int first = 1;
int last = REC.SIZE;
if (first <= last) {
POS = first;
while (1) {
if (cmp_ss(REC.FIELDS[(POS) - 1].NAME, NAME) == 0) TYPEINDEX = REC.FIELDS[(POS) - 1].TYPEINDEX;
if (POS == last) break;
++POS;
}
}
}
if (TYPEINDEX == 0) {
{
write_s(STDERR, str_make(17, "Field not found: "));
write_s(STDERR, NAME);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
return_FINDFIELDTYPE = TYPEINDEX;
return return_FINDFIELDTYPE;
}
TPSTYPE MAKETYPE(STRING NAME, TPSTYPECLASS CLS) {
TPSTYPE return_MAKETYPE;
TPSTYPE TYP;
TYP = EMPTYTYPE();
TYP.NAME = NAME;
TYP.CLS = CLS;
return_MAKETYPE = TYP;
return return_MAKETYPE;
}
TPSCONSTANT MAKECONSTANT(STRING NAME, TLXTOKENID TOKENID, STRING TOKENVALUE) {
TPSCONSTANT return_MAKECONSTANT;
TPSCONSTANT CONSTANT;
CONSTANT.NAME = NAME;
CONSTANT.REPLACEMENT.ID = TOKENID;
CONSTANT.REPLACEMENT.VALUE = TOKENVALUE;
return_MAKECONSTANT = CONSTANT;
return return_MAKECONSTANT;
}
TPSVARIABLE MAKEVARIABLE(STRING NAME, TPSTYPEINDEX TYPEINDEX, PBoolean ISREF) {
TPSVARIABLE return_MAKEVARIABLE;
TPSVARIABLE VARDEF;
VARDEF.NAME = NAME;
VARDEF.TYPEINDEX = TYPEINDEX;
VARDEF.ISREFERENCE = ISREF;
return_MAKEVARIABLE = VARDEF;
return return_MAKEVARIABLE;
}
void STARTGLOBALSCOPE() {
TPSFUNCTION FUN;
CLEARDEFS();
GLOBALSCOPE = GETCURRENTSCOPE();
PRIMITIVETYPES.PTBOOLEAN = ADDTYPE(MAKETYPE(str_make(7, "BOOLEAN"), TTCBOOLEAN), GLOBALSCOPE);
PRIMITIVETYPES.PTINTEGER = ADDTYPE(MAKETYPE(str_make(7, "INTEGER"), TTCINTEGER), GLOBALSCOPE);
PRIMITIVETYPES.PTCHAR = ADDTYPE(MAKETYPE(str_make(4, "CHAR"), TTCCHAR), GLOBALSCOPE);
PRIMITIVETYPES.PTSTRING = ADDTYPE(MAKETYPE(str_make(6, "STRING"), TTCSTRING), GLOBALSCOPE);
PRIMITIVETYPES.PTTEXT = ADDTYPE(MAKETYPE(str_make(4, "TEXT"), TTCTEXT), GLOBALSCOPE);
ADDCONSTANT(MAKECONSTANT(str_make(5, "FALSE"), TKFALSE, str_make(5, "FALSE")), GLOBALSCOPE);
ADDCONSTANT(MAKECONSTANT(str_make(4, "TRUE"), TKTRUE, str_make(4, "TRUE")), GLOBALSCOPE);
ADDVARIABLE(MAKEVARIABLE(str_make(5, "INPUT"), PRIMITIVETYPES.PTTEXT, 0), GLOBALSCOPE);
ADDVARIABLE(MAKEVARIABLE(str_make(6, "OUTPUT"), PRIMITIVETYPES.PTTEXT, 0), GLOBALSCOPE);
ADDVARIABLE(MAKEVARIABLE(str_make(6, "STDERR"), PRIMITIVETYPES.PTTEXT, 0), GLOBALSCOPE);
FUN.NAME = str_make(4, "COPY");
FUN.ARGCOUNT = 3;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_make(3, "STR"), PRIMITIVETYPES.PTSTRING, 0);
FUN.ARGS[(2) - 1] = MAKEVARIABLE(str_make(3, "POS"), PRIMITIVETYPES.PTINTEGER, 0);
FUN.ARGS[(3) - 1] = MAKEVARIABLE(str_make(3, "NUM"), PRIMITIVETYPES.PTINTEGER, 0);
FUN.RETURNTYPEINDEX = PRIMITIVETYPES.PTSTRING;
ADDFUNCTION(FUN);
FUN.NAME = str_make(6, "DELETE");
FUN.ARGCOUNT = 3;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_make(3, "STR"), PRIMITIVETYPES.PTSTRING, 1);
FUN.ARGS[(2) - 1] = MAKEVARIABLE(str_make(3, "POS"), PRIMITIVETYPES.PTINTEGER, 0);
FUN.ARGS[(3) - 1] = MAKEVARIABLE(str_make(3, "NUM"), PRIMITIVETYPES.PTINTEGER, 0);
FUN.RETURNTYPEINDEX = 0;
ADDFUNCTION(FUN);
FUN.NAME = str_make(3, "EOF");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_of('F'), PRIMITIVETYPES.PTTEXT, 0);
FUN.RETURNTYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
ADDFUNCTION(FUN);
FUN.NAME = str_make(4, "HALT");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_make(4, "CODE"), PRIMITIVETYPES.PTINTEGER, 0);
FUN.RETURNTYPEINDEX = 0;
ADDFUNCTION(FUN);
FUN.NAME = str_make(6, "LENGTH");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_make(3, "STR"), PRIMITIVETYPES.PTSTRING, 0);
FUN.RETURNTYPEINDEX = PRIMITIVETYPES.PTINTEGER;
ADDFUNCTION(FUN);
FUN.NAME = str_make(6, "UPCASE");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_make(3, "CHR"), PRIMITIVETYPES.PTCHAR, 0);
FUN.RETURNTYPEINDEX = PRIMITIVETYPES.PTCHAR;
ADDFUNCTION(FUN);
}
TPSTYPEINDEX PSTYPEDENOTER(TPSSCOPE SCOPE) {
TPSTYPEINDEX return_PSTYPEDENOTER;
TPSTYPEINDEX TYPEINDEX;
TPSTYPE TYP;
TPSENUMDEF ENUM;
TPSRECORDDEF REC;
TPSARRAYDEF ARR;
TYPEINDEX = 0;
if (LXTOKEN.ID == TKIDENTIFIER) {
TYPEINDEX = FINDTYPE(LXTOKEN.VALUE);
if (TYPEINDEX == 0) {
{
write_s(STDERR, str_make(14, "Unknown type: "));
write_s(STDERR, LXTOKEN.VALUE);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
READTOKEN();
}
 else if (LXTOKEN.ID == TKLPAREN) {
SKIPTOKEN(TKLPAREN);
ENUM.SIZE = 0;
do {
ENUM.SIZE = ENUM.SIZE + 1;
if (ENUM.SIZE > 128) {
{
write_s(STDERR, str_make(23, "Too many values in enum"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
ENUM.VALUES[(ENUM.SIZE) - 1] = GETTOKENVALUEANDREAD(TKIDENTIFIER);
WANTTOKEN2(TKCOMMA, TKRPAREN);
SKIPTOKEN(TKCOMMA);
} while (!(LXTOKEN.ID == TKRPAREN));
TYP = EMPTYTYPE();
TYP.CLS = TTCENUM;
TYP.ENUMINDEX = ADDENUM(ENUM);
TYPEINDEX = ADDTYPE(TYP, SCOPE);
SKIPTOKEN(TKRPAREN);
}
 else if (LXTOKEN.ID == TKRECORD) {
SKIPTOKEN(TKRECORD);
REC.SIZE = 0;
do {
REC.SIZE = REC.SIZE + 1;
REC.FIELDS[(REC.SIZE) - 1].NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
WANTTOKENANDREAD(TKCOLON);
REC.FIELDS[(REC.SIZE) - 1].TYPEINDEX = PSTYPEDENOTER(SCOPE);
WANTTOKEN2(TKSEMICOLON, TKEND);
SKIPTOKEN(TKSEMICOLON);
} while (!(LXTOKEN.ID == TKEND));
TYP = TYPEOFCLASS(TTCRECORD);
TYP.RECORDINDEX = ADDRECORD(REC);
TYPEINDEX = ADDTYPE(TYP, SCOPE);
SKIPTOKEN(TKEND);
}
 else if (LXTOKEN.ID == TKARRAY) {
SKIPTOKEN(TKARRAY);
WANTTOKENANDREAD(TKLBRACKET);
ARR.LOWBOUND = GETTOKENVALUEANDREAD(TKNUMBER);
WANTTOKENANDREAD(TKRANGE);
ARR.HIGHBOUND = GETTOKENVALUEANDREAD(TKNUMBER);
WANTTOKENANDREAD(TKRBRACKET);
WANTTOKENANDREAD(TKOF);
ARR.TYPEINDEX = PSTYPEDENOTER(SCOPE);
TYP = TYPEOFCLASS(TTCARRAY);
TYP.ARRAYINDEX = ADDARRAY(ARR);
TYPEINDEX = ADDTYPE(TYP, SCOPE);
}
 else {
{
write_s(STDERR, str_make(30, "Wanted type definition, found "));
write_s(STDERR, LXTOKENSTR());
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
return_PSTYPEDENOTER = TYPEINDEX;
return return_PSTYPEDENOTER;
}
void OUTBEGIN() {
{
write_c(OUTPUT, '{');
writeln(OUTPUT);
}
}
void OUTEND() {
{
write_c(OUTPUT, '}');
writeln(OUTPUT);
}
}
void OUTENUMVALUES(TPSENUMINDEX POS) {
int POSINENUM;
{
write_s(OUTPUT, str_make(22, "const char* EnumValues"));
write_i(OUTPUT, POS);
write_s(OUTPUT, str_make(7, "[] = { "));
}
{
int first = 1;
int last = DEFS.ENUMS[(POS) - 1].SIZE;
if (first <= last) {
POSINENUM = first;
while (1) {
{
if (POSINENUM != 1) {
write_s(OUTPUT, str_make(2, ", "));
}
{
write_c(OUTPUT, '\"');
write_s(OUTPUT, DEFS.ENUMS[(POS) - 1].VALUES[(POSINENUM) - 1]);
write_c(OUTPUT, '\"');
}
}
if (POSINENUM == last) break;
++POSINENUM;
}
}
}
{
write_s(OUTPUT, str_make(3, " };"));
writeln(OUTPUT);
}
}
void OUTENUMVALUESINSCOPE(TPSSCOPE SCOPE) {
TPSENUMINDEX POS;
{
TPSENUMINDEX first = SCOPE.NUMENUMS + 1;
TPSENUMINDEX last = DEFS.SCOPE.NUMENUMS;
if (first <= last) {
POS = first;
while (1) {
OUTENUMVALUES(POS);
if (POS == last) break;
++POS;
}
}
}
}
STRING OUTVARIABLENAME(STRING NAME, PBoolean ISREFERENCE) {
STRING return_OUTVARIABLENAME;
if (ISREFERENCE) return_OUTVARIABLENAME = cat_cs('*', NAME);
 else return_OUTVARIABLENAME = NAME;
return return_OUTVARIABLENAME;
}
STRING OUTRETURNVARIABLENAME(STRING NAME) {
STRING return_OUTRETURNVARIABLENAME;
return_OUTRETURNVARIABLENAME = cat_ss(str_make(7, "return_"), NAME);
return return_OUTRETURNVARIABLENAME;
}
void OUTNAMEANDTYPE(STRING NAME, TPSTYPEINDEX TYPEINDEX) {
TPSTYPE TYP;
TPSENUMDEF ENUM;
TPSRECORDDEF REC;
TPSARRAYDEF ARR;
int POS;
if (TYPEINDEX != 0) TYP = DEFS.TYPES[(TYPEINDEX) - 1];
if (TYPEINDEX == 0) {
write_s(OUTPUT, str_make(5, "void "));
write_s(OUTPUT, NAME);
}
 else if ((TYP.ALIASFOR != 0) && (cmp_ss(TYP.NAME, str_make(0, "")) != 0)) {
write_s(OUTPUT, TYP.NAME);
write_c(OUTPUT, ' ');
write_s(OUTPUT, NAME);
}
 else if (TYP.CLS == TTCBOOLEAN) {
write_s(OUTPUT, str_make(9, "PBoolean "));
write_s(OUTPUT, NAME);
}
 else if (TYP.CLS == TTCINTEGER) {
write_s(OUTPUT, str_make(4, "int "));
write_s(OUTPUT, NAME);
}
 else if (TYP.CLS == TTCCHAR) {
write_s(OUTPUT, str_make(5, "char "));
write_s(OUTPUT, NAME);
}
 else if (TYP.CLS == TTCSTRING) {
write_s(OUTPUT, str_make(7, "STRING "));
write_s(OUTPUT, NAME);
}
 else if (TYP.CLS == TTCTEXT) {
write_s(OUTPUT, str_make(6, "PFile "));
write_s(OUTPUT, NAME);
}
 else if (TYP.CLS == TTCENUM) {
ENUM = DEFS.ENUMS[(TYP.ENUMINDEX) - 1];
{
write_s(OUTPUT, str_make(7, "enum { "));
}
{
int first = 1;
int last = ENUM.SIZE;
if (first <= last) {
POS = first;
while (1) {
{
if (POS > 1) {
write_s(OUTPUT, str_make(2, ", "));
}
{
write_s(OUTPUT, ENUM.VALUES[(POS) - 1]);
}
}
if (POS == last) break;
++POS;
}
}
}
{
write_s(OUTPUT, str_make(2, "} "));
write_s(OUTPUT, NAME);
}
}
 else if (TYP.CLS == TTCRECORD) {
REC = DEFS.RECORDS[(TYP.RECORDINDEX) - 1];
{
write_s(OUTPUT, str_make(9, "struct { "));
}
{
int first = 1;
int last = REC.SIZE;
if (first <= last) {
POS = first;
while (1) {
{
OUTNAMEANDTYPE(REC.FIELDS[(POS) - 1].NAME, REC.FIELDS[(POS) - 1].TYPEINDEX);
{
write_s(OUTPUT, str_make(2, "; "));
}
}
if (POS == last) break;
++POS;
}
}
}
{
write_s(OUTPUT, str_make(2, "} "));
write_s(OUTPUT, NAME);
}
}
 else if (TYP.CLS == TTCARRAY) {
ARR = DEFS.ARRAYS[(TYP.ARRAYINDEX) - 1];
OUTNAMEANDTYPE(NAME, ARR.TYPEINDEX);
{
write_s(OUTPUT, str_make(5, "[1 + "));
write_s(OUTPUT, ARR.HIGHBOUND);
write_s(OUTPUT, str_make(3, " - "));
write_s(OUTPUT, ARR.LOWBOUND);
write_c(OUTPUT, ']');
}
}
 else {
{
write_s(STDERR, str_make(29, "Error writing name and type: "));
write_s(STDERR, NAME);
write_s(STDERR, str_make(2, ", "));
write_s(STDERR, TYPENAME(TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
void OUTTYPEDEFINITION(TPSTYPEINDEX TYPEINDEX) {
STRING NAME;
NAME = DEFS.TYPES[(TYPEINDEX) - 1].NAME;
if (DEFS.TYPES[(TYPEINDEX) - 1].ALIASFOR == 0) {
{
write_s(STDERR, str_make(5, "Type "));
write_s(STDERR, NAME);
write_s(STDERR, str_make(16, " is not an alias"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
{
write_s(OUTPUT, str_make(8, "typedef "));
}
OUTNAMEANDTYPE(NAME, DEFS.TYPES[(TYPEINDEX) - 1].ALIASFOR);
{
write_c(OUTPUT, ';');
writeln(OUTPUT);
}
}
void PSTYPEDEFINITIONS(TPSSCOPE SCOPE) {
STRING NAME;
TPSTYPEINDEX TYPEINDEX;
TPSTYPE NEWTYPE;
TPSSCOPE PREVIOUSSCOPE;
PREVIOUSSCOPE = GETCURRENTSCOPE();
WANTTOKENANDREAD(TKTYPE);
do {
NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
WANTTOKENANDREAD(TKEQUALS);
TYPEINDEX = PSTYPEDENOTER(SCOPE);
NEWTYPE = DEFS.TYPES[(TYPEINDEX) - 1];
NEWTYPE.NAME = NAME;
NEWTYPE.ALIASFOR = TYPEINDEX;
TYPEINDEX = ADDTYPE(NEWTYPE, SCOPE);
WANTTOKENANDREAD(TKSEMICOLON);
OUTTYPEDEFINITION(TYPEINDEX);
} while (!(LXTOKEN.ID != TKIDENTIFIER));
OUTENUMVALUESINSCOPE(PREVIOUSSCOPE);
}
void PSCONSTDEFINITIONS(TPSSCOPE SCOPE) {
TLXTOKEN REPLACEMENT;
TPSCONSTANTINDEX CONSTINDEX;
TPSCONSTANT CONSTANT;
WANTTOKENANDREAD(TKCONST);
do {
CONSTANT.NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
WANTTOKENANDREAD(TKEQUALS);
if ((LXTOKEN.ID == TKNUMBER) || (LXTOKEN.ID == TKSTRING)) CONSTANT.REPLACEMENT = LXTOKEN;
 else if (LXTOKEN.ID == TKIDENTIFIER) {
CONSTINDEX = FINDCONSTANT(LXTOKEN.VALUE);
if (CONSTINDEX == 0) {
{
write_s(STDERR, str_make(25, "Expected constant, found "));
write_s(STDERR, LXTOKENSTR());
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
CONSTANT.REPLACEMENT = DEFS.CONSTANTS[(CONSTINDEX) - 1].REPLACEMENT;
}
 else {
{
write_s(STDERR, str_make(31, "Expected constant value, found "));
write_s(STDERR, LXTOKENSTR());
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
ADDCONSTANT(CONSTANT, SCOPE);
READTOKEN();
WANTTOKENANDREAD(TKSEMICOLON);
} while (!(LXTOKEN.ID != TKIDENTIFIER));
}
void OUTVARIABLEDECLARATION(TPSVARIABLE VARDEF) {
OUTNAMEANDTYPE(OUTVARIABLENAME(VARDEF.NAME, VARDEF.ISREFERENCE), VARDEF.TYPEINDEX);
}
void OUTVARIABLEDEFINITION(TPSVARIABLEINDEX VARINDEX) {
OUTVARIABLEDECLARATION(DEFS.VARIABLES[(VARINDEX) - 1]);
{
write_c(OUTPUT, ';');
writeln(OUTPUT);
}
}
void PSVARDEFINITIONS(TPSSCOPE SCOPE) {
STRING NAME;
TPSTYPEINDEX TYPEINDEX;
TPSSCOPE PREVIOUSSCOPE;
PREVIOUSSCOPE = GETCURRENTSCOPE();
WANTTOKENANDREAD(TKVAR);
do {
NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
WANTTOKENANDREAD(TKCOLON);
TYPEINDEX = PSTYPEDENOTER(SCOPE);
WANTTOKENANDREAD(TKSEMICOLON);
OUTVARIABLEDEFINITION(ADDVARIABLE(MAKEVARIABLE(NAME, TYPEINDEX, 0), SCOPE));
} while (!(LXTOKEN.ID != TKIDENTIFIER));
OUTENUMVALUESINSCOPE(PREVIOUSSCOPE);
}
void OUTFUNCTIONPROTOTYPE(TPSFUNCTION DEF) {
int POS;
OUTNAMEANDTYPE(DEF.NAME, DEF.RETURNTYPEINDEX);
{
write_c(OUTPUT, '(');
}
{
int first = 1;
int last = DEF.ARGCOUNT;
if (first <= last) {
POS = first;
while (1) {
{
OUTVARIABLEDECLARATION(DEF.ARGS[(POS) - 1]);
if (POS != DEF.ARGCOUNT) {
write_s(OUTPUT, str_make(2, ", "));
}
}
if (POS == last) break;
++POS;
}
}
}
{
write_c(OUTPUT, ')');
}
}
void OUTFUNCTIONDECLARATION(TPSFUNCTIONINDEX FNINDEX) {
OUTFUNCTIONPROTOTYPE(DEFS.FUNCTIONS[(FNINDEX) - 1]);
{
write_c(OUTPUT, ';');
writeln(OUTPUT);
}
}
void OUTFUNCTIONDEFINITION(TPSFUNCTIONINDEX FNINDEX) {
TPSFUNCTION FUN;
FUN = DEFS.FUNCTIONS[(FNINDEX) - 1];
OUTFUNCTIONPROTOTYPE(FUN);
{
write_s(OUTPUT, str_make(2, " {"));
writeln(OUTPUT);
}
if (FUN.RETURNTYPEINDEX != 0) {
OUTNAMEANDTYPE(OUTRETURNVARIABLENAME(FUN.NAME), FUN.RETURNTYPEINDEX);
{
write_c(OUTPUT, ';');
writeln(OUTPUT);
}
}
}
void OUTFUNCTIONEND(TPSFUNCTIONINDEX FNINDEX) {
if (DEFS.FUNCTIONS[(FNINDEX) - 1].RETURNTYPEINDEX != 0) {
write_s(OUTPUT, str_make(7, "return "));
write_s(OUTPUT, OUTRETURNVARIABLENAME(DEFS.FUNCTIONS[(FNINDEX) - 1].NAME));
write_c(OUTPUT, ';');
writeln(OUTPUT);
}
{
write_c(OUTPUT, '}');
writeln(OUTPUT);
}
}
void PSSTATEMENT();
void PSDEFINITIONS(TPSSCOPE SCOPE);
void ADDFUNCARGSTOSCOPE(TPSFUNCTIONINDEX FNINDEX, TPSSCOPE SCOPE) {
int POS;
{
int first = 1;
int last = DEFS.FUNCTIONS[(FNINDEX) - 1].ARGCOUNT;
if (first <= last) {
POS = first;
while (1) {
ADDVARIABLE(DEFS.FUNCTIONS[(FNINDEX) - 1].ARGS[(POS) - 1], SCOPE);
if (POS == last) break;
++POS;
}
}
}
}
void PSFUNCTIONBODY(TPSFUNCTIONINDEX FNINDEX) {
TPSSCOPE PREVIOUSSCOPE;
if (LXTOKEN.ID == TKFORWARD) {
SKIPTOKEN(TKFORWARD);
WANTTOKENANDREAD(TKSEMICOLON);
DEFS.FUNCTIONS[(FNINDEX) - 1].ISDECLARATION = 1;
OUTFUNCTIONDECLARATION(FNINDEX);
}
 else {
PREVIOUSSCOPE = GETCURRENTSCOPE();
ADDFUNCARGSTOSCOPE(FNINDEX, PREVIOUSSCOPE);
OUTFUNCTIONDEFINITION(FNINDEX);
OUTENUMVALUESINSCOPE(PREVIOUSSCOPE);
PSDEFINITIONS(PREVIOUSSCOPE);
WANTTOKENANDREAD(TKBEGIN);
while (LXTOKEN.ID != TKEND) {
PSSTATEMENT();
WANTTOKEN2(TKSEMICOLON, TKEND);
SKIPTOKEN(TKSEMICOLON);
}
WANTTOKENANDREAD(TKEND);
WANTTOKENANDREAD(TKSEMICOLON);
OUTFUNCTIONEND(FNINDEX);
SETCURRENTSCOPE(PREVIOUSSCOPE);
}
}
void PSFUNCTIONDEFINITION() {
PBoolean ISPROCEDURE;
TPSFUNCTION DEF;
WANTTOKEN2(TKFUNCTION, TKPROCEDURE);
ISPROCEDURE = LXTOKEN.ID == TKPROCEDURE;
READTOKEN();
DEF.NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
DEF.ARGCOUNT = 0;
if (ISPROCEDURE) WANTTOKEN2(TKLPAREN, TKSEMICOLON);
 else WANTTOKEN2(TKLPAREN, TKCOLON);
if (LXTOKEN.ID == TKLPAREN) {
WANTTOKENANDREAD(TKLPAREN);
do {
DEF.ARGCOUNT = DEF.ARGCOUNT + 1;
DEF.ARGS[(DEF.ARGCOUNT) - 1].ISREFERENCE = LXTOKEN.ID == TKVAR;
SKIPTOKEN(TKVAR);
DEF.ARGS[(DEF.ARGCOUNT) - 1].NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
WANTTOKENANDREAD(TKCOLON);
DEF.ARGS[(DEF.ARGCOUNT) - 1].TYPEINDEX = PSTYPEDENOTER(GLOBALSCOPE);
WANTTOKEN2(TKSEMICOLON, TKRPAREN);
SKIPTOKEN(TKSEMICOLON);
} while (!(LXTOKEN.ID == TKRPAREN));
SKIPTOKEN(TKRPAREN);
}
if (ISPROCEDURE) DEF.RETURNTYPEINDEX = 0;
 else {
WANTTOKENANDREAD(TKCOLON);
DEF.RETURNTYPEINDEX = PSTYPEDENOTER(GLOBALSCOPE);
}
WANTTOKENANDREAD(TKSEMICOLON);
PSFUNCTIONBODY(ADDFUNCTION(DEF));
}
void PSDEFINITIONS(TPSSCOPE SCOPE) {
PBoolean DONE;
DONE = 0;
do {
if (LXTOKEN.ID == TKTYPE) PSTYPEDEFINITIONS(SCOPE);
 else if (LXTOKEN.ID == TKCONST) PSCONSTDEFINITIONS(SCOPE);
 else if (LXTOKEN.ID == TKVAR) PSVARDEFINITIONS(SCOPE);
 else if ((LXTOKEN.ID == TKPROCEDURE) || (LXTOKEN.ID == TKFUNCTION)) PSFUNCTIONDEFINITION();
 else DONE = 1;
} while (!(DONE));
}
void OUTPROGRAMHEADING(STRING NAME) {
{
write_s(OUTPUT, str_make(12, "/* Program: "));
write_s(OUTPUT, NAME);
write_s(OUTPUT, str_make(3, " */"));
writeln(OUTPUT);
}
{
write_s(OUTPUT, str_make(20, "#include \"pascual.h\""));
writeln(OUTPUT);
}
}
void PSPROGRAMHEADING() {
WANTTOKENANDREAD(TKPROGRAM);
OUTPROGRAMHEADING(GETTOKENVALUEANDREAD(TKIDENTIFIER));
if (LXTOKEN.ID == TKLPAREN) {
do {
READTOKEN();
WANTTOKEN2(TKIDENTIFIER, TKRPAREN);
SKIPTOKEN(TKIDENTIFIER);
WANTTOKEN2(TKCOMMA, TKRPAREN);
} while (!(LXTOKEN.ID == TKRPAREN));
SKIPTOKEN(TKRPAREN);
}
WANTTOKENANDREAD(TKSEMICOLON);
}
typedef enum { IDCVARIABLE, IDCFUNCTION, IDCREAD, IDCREADLN, IDCWRITE, IDCWRITELN, IDCSTR} TPSIDCLASS;
typedef struct { STRING NAME; STRING VALUE; TPSIDCLASS CLS; TPSTYPEINDEX TYPEINDEX; TPSFUNCTIONINDEX FUNCTIONINDEX; } TPSIDENTIFIER;
typedef struct { STRING VALUE; TPSTYPEINDEX TYPEINDEX; } TPSEXPRESSION;
const char* EnumValues3[] = { "IDCVARIABLE", "IDCFUNCTION", "IDCREAD", "IDCREADLN", "IDCWRITE", "IDCWRITELN", "IDCSTR" };
TPSEXPRESSION PSEXPRESSION();
STRING OUTFIELDNAME(STRING BASE, STRING NAME) {
STRING return_OUTFIELDNAME;
if (cmp_cc(BASE.chr[1], '*') == 0) return_OUTFIELDNAME = cat_ss(cat_ss(cat_cs('(', BASE), str_make(2, ").")), NAME);
 else return_OUTFIELDNAME = cat_ss(cat_sc(BASE, '.'), NAME);
return return_OUTFIELDNAME;
}
STRING OUTSTRINGINDEX(STRING BASE, TPSEXPRESSION EXPR) {
STRING return_OUTSTRINGINDEX;
if (!ISINTEGERTYPE(EXPR.TYPEINDEX)) {
{
write_s(STDERR, str_make(28, "Subscript must be an integer"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
return_OUTSTRINGINDEX = cat_sc(cat_ss(cat_ss(BASE, str_make(5, ".chr[")), EXPR.VALUE), ']');
return return_OUTSTRINGINDEX;
}
STRING OUTARRAYINDEX(STRING BASE, TPSEXPRESSION EXPR, TPSTYPEINDEX TYPEINDEX) {
STRING return_OUTARRAYINDEX;
if (!ISINTEGERTYPE(EXPR.TYPEINDEX)) {
{
write_s(STDERR, str_make(28, "Subscript must be an integer"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
return_OUTARRAYINDEX = cat_sc(cat_ss(cat_ss(cat_ss(cat_ss(BASE, str_make(2, "[(")), EXPR.VALUE), str_make(4, ") - ")), DEFS.ARRAYS[(DEFS.TYPES[(TYPEINDEX) - 1].ARRAYINDEX) - 1].LOWBOUND), ']');
return return_OUTARRAYINDEX;
}
void OUTIDENTIFIER(TPSIDENTIFIER ID) {
{
write_s(OUTPUT, ID.VALUE);
}
}
TPSIDENTIFIER PSIDENTIFIER() {
TPSIDENTIFIER return_PSIDENTIFIER;
STRING NAME;
STRING FULLNAME;
TPSIDENTIFIER IDENT;
TPSVARIABLEINDEX VARINDEX;
TPSFUNCTIONINDEX FNINDEX;
TPSTYPEINDEX ENUMTYPEINDEX;
TPSEXPRESSION EXPR;
NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
IDENT.NAME = NAME;
VARINDEX = FINDVARIABLE(NAME);
FNINDEX = FINDFUNCTION(NAME);
ENUMTYPEINDEX = FINDTYPEOFENUMVALUE(NAME);
if (LXTOKEN.ID == TKLPAREN) {
if (cmp_ss(NAME, str_make(4, "READ")) == 0) IDENT.CLS = IDCREAD;
 else if (cmp_ss(NAME, str_make(6, "READLN")) == 0) IDENT.CLS = IDCREADLN;
 else if (cmp_ss(NAME, str_make(5, "WRITE")) == 0) IDENT.CLS = IDCWRITE;
 else if (cmp_ss(NAME, str_make(7, "WRITELN")) == 0) IDENT.CLS = IDCWRITELN;
 else if (cmp_ss(NAME, str_make(3, "STR")) == 0) IDENT.CLS = IDCSTR;
 else {
if (FNINDEX == 0) {
{
write_s(STDERR, str_make(31, "Unknown function or procedure: "));
write_s(STDERR, NAME);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
IDENT.VALUE = NAME;
IDENT.CLS = IDCFUNCTION;
IDENT.FUNCTIONINDEX = FNINDEX;
}
}
 else {
IDENT.CLS = IDCVARIABLE;
if (VARINDEX != 0) {
IDENT.VALUE = OUTVARIABLENAME(NAME, DEFS.VARIABLES[(VARINDEX) - 1].ISREFERENCE);
IDENT.TYPEINDEX = DEFS.VARIABLES[(VARINDEX) - 1].TYPEINDEX;
}
 else if (FNINDEX != 0) {
IDENT.VALUE = OUTRETURNVARIABLENAME(NAME);
IDENT.TYPEINDEX = DEFS.FUNCTIONS[(FNINDEX) - 1].RETURNTYPEINDEX;
}
 else if (ENUMTYPEINDEX != 0) {
IDENT.VALUE = OUTVARIABLENAME(NAME, 0);
IDENT.TYPEINDEX = ENUMTYPEINDEX;
}
 else {
{
write_s(STDERR, str_make(30, "Unknown variable or argument: "));
write_s(STDERR, NAME);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
FULLNAME = NAME;
while ((LXTOKEN.ID == TKDOT) || (LXTOKEN.ID == TKLBRACKET)) {
if (LXTOKEN.ID == TKDOT) {
WANTTOKENANDREAD(TKDOT);
if (DEFS.TYPES[(IDENT.TYPEINDEX) - 1].CLS != TTCRECORD) {
{
write_s(STDERR, str_make(9, "Variable "));
write_s(STDERR, FULLNAME);
write_s(STDERR, str_make(16, " is not a record"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
IDENT.NAME = cat_ss(cat_sc(IDENT.NAME, '.'), NAME);
IDENT.TYPEINDEX = FINDFIELDTYPE(IDENT.TYPEINDEX, NAME);
if (IDENT.TYPEINDEX == 0) {
{
write_s(STDERR, str_make(21, "Could not find field "));
write_s(STDERR, NAME);
write_s(STDERR, str_make(4, " of "));
write_s(STDERR, FULLNAME);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
FULLNAME = cat_ss(cat_sc(FULLNAME, '.'), NAME);
IDENT.VALUE = OUTFIELDNAME(IDENT.VALUE, NAME);
}
 else if (LXTOKEN.ID == TKLBRACKET) {
WANTTOKENANDREAD(TKLBRACKET);
EXPR = PSEXPRESSION();
WANTTOKENANDREAD(TKRBRACKET);
IDENT.NAME = cat_ss(IDENT.NAME, str_make(5, "[...]"));
if (ISSTRINGYTYPE(IDENT.TYPEINDEX)) {
IDENT.VALUE = OUTSTRINGINDEX(IDENT.VALUE, EXPR);
IDENT.TYPEINDEX = PRIMITIVETYPES.PTCHAR;
}
 else if (ISARRAYTYPE(IDENT.TYPEINDEX)) {
IDENT.VALUE = OUTARRAYINDEX(IDENT.VALUE, EXPR, IDENT.TYPEINDEX);
IDENT.TYPEINDEX = DEFS.ARRAYS[(DEFS.TYPES[(IDENT.TYPEINDEX) - 1].ARRAYINDEX) - 1].TYPEINDEX;
}
 else {
{
write_s(STDERR, str_make(9, "Variable "));
write_s(STDERR, FULLNAME);
write_s(STDERR, str_make(28, " is not an array or a string"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
}
}
return_PSIDENTIFIER = IDENT;
return return_PSIDENTIFIER;
}
PBoolean ISOPADDING(TLXTOKEN TOK) {
PBoolean return_ISOPADDING;
return_ISOPADDING = (TOK.ID == TKPLUS) || (TOK.ID == TKMINUS) || (TOK.ID == TKOR);
return return_ISOPADDING;
}
PBoolean ISOPMULTIPYING(TLXTOKEN TOK) {
PBoolean return_ISOPMULTIPYING;
return_ISOPMULTIPYING = (TOK.ID == TKASTERISK) || (TOK.ID == TKSLASH) || (TOK.ID == TKDIV) || (TOK.ID == TKMOD) || (TOK.ID == TKAND);
return return_ISOPMULTIPYING;
}
PBoolean ISOPRELATIONAL(TLXTOKEN TOK) {
PBoolean return_ISOPRELATIONAL;
return_ISOPRELATIONAL = (TOK.ID == TKEQUALS) || (TOK.ID == TKNOTEQUALS) || (TOK.ID == TKLESSTHAN) || (TOK.ID == TKMORETHAN) || (TOK.ID == TKLESSOREQUALS) || (TOK.ID == TKMOREOREQUALS) || (TOK.ID == TKIN);
return return_ISOPRELATIONAL;
}
TPSEXPRESSION GENBOOLEANCONSTANT(PBoolean VALUE) {
TPSEXPRESSION return_GENBOOLEANCONSTANT;
TPSEXPRESSION EXPR;
EXPR.TYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
if (VALUE) EXPR.VALUE = str_of('1');
 else EXPR.VALUE = str_of('0');
return_GENBOOLEANCONSTANT = EXPR;
return return_GENBOOLEANCONSTANT;
}
TPSEXPRESSION GENSTRINGCONSTANT(STRING VALUE) {
TPSEXPRESSION return_GENSTRINGCONSTANT;
TPSEXPRESSION EXPR;
STRING SIZE;
int POS;
PBoolean INSTR;
PBoolean LASTQUOTE;
int LEN;
INSTR = 0;
LASTQUOTE = 0;
EXPR.VALUE = str_make(0, "");
LEN = 0;
{
int first = 1;
int last = LENGTH(VALUE);
if (first <= last) {
POS = first;
while (1) {
{
if (cmp_cc(VALUE.chr[POS], '\'') == 0) {
INSTR = !INSTR;
if (INSTR && LASTQUOTE) {
EXPR.VALUE = cat_ss(EXPR.VALUE, str_make(2, "\\\'"));
LEN = LEN + 1;
}
 else LASTQUOTE = !INSTR;
}
 else {
LASTQUOTE = 0;
if (cmp_cc(VALUE.chr[POS], '\"') == 0) EXPR.VALUE = cat_ss(EXPR.VALUE, str_make(2, "\\\""));
 else if (cmp_cc(VALUE.chr[POS], '\\') == 0) EXPR.VALUE = cat_ss(EXPR.VALUE, str_make(2, "\\\\"));
 else EXPR.VALUE = cat_sc(EXPR.VALUE, VALUE.chr[POS]);
LEN = LEN + 1;
}
}
if (POS == last) break;
++POS;
}
}
}
if (LEN == 1) {
EXPR.VALUE = cat_sc(cat_cs('\'', EXPR.VALUE), '\'');
EXPR.TYPEINDEX = PRIMITIVETYPES.PTCHAR;
}
 else {
SIZE = to_str_i(LEN);
EXPR.VALUE = cat_ss(cat_ss(cat_ss(cat_ss(str_make(9, "str_make("), SIZE), str_make(3, ", \"")), EXPR.VALUE), str_make(2, "\")"));
EXPR.TYPEINDEX = PRIMITIVETYPES.PTSTRING;
}
return_GENSTRINGCONSTANT = EXPR;
return return_GENSTRINGCONSTANT;
}
TPSEXPRESSION GENNUMBERCONSTANT(STRING VALUE) {
TPSEXPRESSION return_GENNUMBERCONSTANT;
TPSEXPRESSION EXPR;
EXPR.TYPEINDEX = PRIMITIVETYPES.PTINTEGER;
EXPR.VALUE = VALUE;
return_GENNUMBERCONSTANT = EXPR;
return return_GENNUMBERCONSTANT;
}
char SHORTTYPENAME(TPSTYPEINDEX TYPEINDEX) {
char return_SHORTTYPENAME;
if (ISBOOLEANTYPE(TYPEINDEX)) return_SHORTTYPENAME = 'b';
 else if (ISINTEGERTYPE(TYPEINDEX)) return_SHORTTYPENAME = 'i';
 else if (ISCHARTYPE(TYPEINDEX)) return_SHORTTYPENAME = 'c';
 else if (ISSTRINGTYPE(TYPEINDEX)) return_SHORTTYPENAME = 's';
 else if (ISENUMTYPE(TYPEINDEX)) return_SHORTTYPENAME = 'e';
 else {
write_s(STDERR, str_make(30, "No short type name exists for "));
write_s(STDERR, TYPENAME(TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
return return_SHORTTYPENAME;
}
TPSEXPRESSION INTEGERBINARYEXPRESSION(TPSEXPRESSION LEFT, TLXTOKENID OP, TPSEXPRESSION RIGHT) {
TPSEXPRESSION return_INTEGERBINARYEXPRESSION;
STRING OPER;
STRING CMP;
TPSEXPRESSION EXPR;
OPER = str_make(0, "");
CMP = str_make(0, "");
if (OP == TKPLUS) OPER = str_of('+');
 else if (OP == TKMINUS) OPER = str_of('-');
 else if (OP == TKASTERISK) OPER = str_of('*');
 else if (OP == TKSLASH) OPER = str_of('/');
 else if (OP == TKDIV) OPER = str_of('/');
 else if (OP == TKMOD) OPER = str_of('%');
 else if (OP == TKAND) OPER = str_of('&');
 else if (OP == TKOR) OPER = str_of('|');
 else if (OP == TKEQUALS) CMP = str_make(2, "==");
 else if (OP == TKNOTEQUALS) CMP = str_make(2, "!=");
 else if (OP == TKLESSTHAN) CMP = str_of('<');
 else if (OP == TKMORETHAN) CMP = str_of('>');
 else if (OP == TKLESSOREQUALS) CMP = str_make(2, "<=");
 else if (OP == TKMOREOREQUALS) CMP = str_make(2, ">=");
 else {
{
write_s(STDERR, str_make(32, "Expected binary operator, found "));
write_e(STDERR, OP, EnumValues1);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
if (cmp_ss(CMP, str_make(0, "")) == 0) EXPR.TYPEINDEX = PRIMITIVETYPES.PTINTEGER;
 else EXPR.TYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
EXPR.VALUE = cat_ss(cat_sc(cat_ss(cat_ss(cat_sc(LEFT.VALUE, ' '), OPER), CMP), ' '), RIGHT.VALUE);
return_INTEGERBINARYEXPRESSION = EXPR;
return return_INTEGERBINARYEXPRESSION;
}
TPSEXPRESSION BOOLEANBINARYEXPRESSION(TPSEXPRESSION LEFT, TLXTOKENID OP, TPSEXPRESSION RIGHT) {
TPSEXPRESSION return_BOOLEANBINARYEXPRESSION;
STRING OPER;
TPSEXPRESSION EXPR;
if (OP == TKAND) OPER = str_make(2, "&&");
 else if (OP == TKOR) OPER = str_make(2, "||");
 else if (OP == TKEQUALS) OPER = str_make(2, "==");
 else if (OP == TKNOTEQUALS) OPER = str_make(2, "!=");
 else if (OP == TKLESSTHAN) OPER = str_of('<');
 else if (OP == TKMORETHAN) OPER = str_of('>');
 else if (OP == TKLESSOREQUALS) OPER = str_make(2, "<=");
 else if (OP == TKMOREOREQUALS) OPER = str_make(2, ">=");
 else {
{
write_s(STDERR, str_make(32, "Expected binary operator, found "));
write_e(STDERR, OP, EnumValues1);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
EXPR.TYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
EXPR.VALUE = cat_ss(cat_sc(cat_ss(cat_sc(LEFT.VALUE, ' '), OPER), ' '), RIGHT.VALUE);
return_BOOLEANBINARYEXPRESSION = EXPR;
return return_BOOLEANBINARYEXPRESSION;
}
TPSEXPRESSION STRINGYBINARYEXPRESSION(TPSEXPRESSION LEFT, TLXTOKENID OP, TPSEXPRESSION RIGHT) {
TPSEXPRESSION return_STRINGYBINARYEXPRESSION;
STRING FNAME;
STRING CMP;
TPSEXPRESSION EXPR;
FNAME = str_make(3, "cmp");
CMP = str_make(0, "");
if (OP == TKPLUS) FNAME = str_make(3, "cat");
 else if (OP == TKEQUALS) CMP = str_make(2, "==");
 else if (OP == TKNOTEQUALS) CMP = str_make(2, "!=");
 else if (OP == TKLESSTHAN) CMP = str_of('<');
 else if (OP == TKMORETHAN) CMP = str_of('>');
 else if (OP == TKLESSOREQUALS) CMP = str_make(2, "<=");
 else if (OP == TKMOREOREQUALS) CMP = str_make(2, ">=");
 else {
{
write_s(STDERR, str_make(32, "Expected binary operator, found "));
write_e(STDERR, OP, EnumValues1);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
FNAME = cat_sc(cat_sc(cat_sc(FNAME, '_'), SHORTTYPENAME(LEFT.TYPEINDEX)), SHORTTYPENAME(RIGHT.TYPEINDEX));
EXPR.TYPEINDEX = PRIMITIVETYPES.PTSTRING;
EXPR.VALUE = cat_sc(cat_ss(cat_ss(cat_ss(cat_sc(FNAME, '('), LEFT.VALUE), str_make(2, ", ")), RIGHT.VALUE), ')');
if (cmp_ss(CMP, str_make(0, "")) != 0) {
EXPR.TYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
EXPR.VALUE = cat_ss(cat_ss(cat_sc(EXPR.VALUE, ' '), CMP), str_make(2, " 0"));
}
return_STRINGYBINARYEXPRESSION = EXPR;
return return_STRINGYBINARYEXPRESSION;
}
TPSEXPRESSION ENUMBINARYEXPRESSION(TPSEXPRESSION LEFT, TLXTOKENID OP, TPSEXPRESSION RIGHT) {
TPSEXPRESSION return_ENUMBINARYEXPRESSION;
STRING CMP;
TPSEXPRESSION EXPR;
CMP = str_make(0, "");
if (OP == TKEQUALS) CMP = str_make(2, "==");
 else if (OP == TKNOTEQUALS) CMP = str_make(2, "!=");
 else if (OP == TKLESSTHAN) CMP = str_of('<');
 else if (OP == TKMORETHAN) CMP = str_of('>');
 else if (OP == TKLESSOREQUALS) CMP = str_make(2, "<=");
 else if (OP == TKMOREOREQUALS) CMP = str_make(2, ">=");
 else {
{
write_s(STDERR, str_make(32, "Expected binary operator, found "));
write_e(STDERR, OP, EnumValues1);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
EXPR.TYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
EXPR.VALUE = cat_ss(cat_sc(cat_ss(cat_sc(LEFT.VALUE, ' '), CMP), ' '), RIGHT.VALUE);
return_ENUMBINARYEXPRESSION = EXPR;
return return_ENUMBINARYEXPRESSION;
}
TPSEXPRESSION BINARYEXPRESSION(TPSEXPRESSION LEFT, TLXTOKENID OP, TPSEXPRESSION RIGHT) {
TPSEXPRESSION return_BINARYEXPRESSION;
if (ISBOOLEANTYPE(LEFT.TYPEINDEX) && ISBOOLEANTYPE(RIGHT.TYPEINDEX)) return_BINARYEXPRESSION = BOOLEANBINARYEXPRESSION(LEFT, OP, RIGHT);
 else if (ISINTEGERTYPE(LEFT.TYPEINDEX) && ISINTEGERTYPE(RIGHT.TYPEINDEX)) return_BINARYEXPRESSION = INTEGERBINARYEXPRESSION(LEFT, OP, RIGHT);
 else if (ISSTRINGYTYPE(LEFT.TYPEINDEX) && ISSTRINGYTYPE(RIGHT.TYPEINDEX)) return_BINARYEXPRESSION = STRINGYBINARYEXPRESSION(LEFT, OP, RIGHT);
 else if (ISENUMTYPE(LEFT.TYPEINDEX) && ISSAMETYPE(LEFT.TYPEINDEX, RIGHT.TYPEINDEX)) return_BINARYEXPRESSION = ENUMBINARYEXPRESSION(LEFT, OP, RIGHT);
 else {
{
write_s(STDERR, str_make(27, "Type mismatch for operator "));
write_e(STDERR, OP, EnumValues1);
write_s(STDERR, str_make(2, ": "));
write_s(STDERR, TYPENAME(LEFT.TYPEINDEX));
write_s(STDERR, str_make(5, " and "));
write_s(STDERR, TYPENAME(RIGHT.TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
return return_BINARYEXPRESSION;
}
TPSEXPRESSION UNARYEXPRESSION(TLXTOKENID OP, TPSEXPRESSION EXPR) {
TPSEXPRESSION return_UNARYEXPRESSION;
if (OP != TKNOT) {
{
write_s(STDERR, str_make(31, "Expected unary operator, found "));
write_e(STDERR, OP, EnumValues1);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
 else if (!ISBOOLEANTYPE(EXPR.TYPEINDEX)) {
{
write_s(STDERR, str_make(33, "Expected boolean expression, got "));
write_s(STDERR, TYPENAME(EXPR.TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
 else EXPR.VALUE = cat_cs('!', EXPR.VALUE);
return_UNARYEXPRESSION = EXPR;
return return_UNARYEXPRESSION;
}
TPSEXPRESSION COERCETYPE(TPSEXPRESSION EXPR, TPSTYPEINDEX TYPEINDEX) {
TPSEXPRESSION return_COERCETYPE;
if (ISCHARTYPE(EXPR.TYPEINDEX) && ISSTRINGTYPE(TYPEINDEX)) {
EXPR.TYPEINDEX = PRIMITIVETYPES.PTSTRING;
EXPR.VALUE = cat_sc(cat_ss(str_make(7, "str_of("), EXPR.VALUE), ')');
}
 else if (!ISSAMETYPE(EXPR.TYPEINDEX, TYPEINDEX)) {
{
write_s(STDERR, str_make(14, "Cannot assign "));
write_s(STDERR, TYPENAME(EXPR.TYPEINDEX));
write_s(STDERR, str_make(4, " to "));
write_s(STDERR, TYPENAME(TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
return_COERCETYPE = EXPR;
return return_COERCETYPE;
}
TPSEXPRESSION GENFUNCTIONCALLSTART(TPSEXPRESSION FNPROC) {
TPSEXPRESSION return_GENFUNCTIONCALLSTART;
FNPROC.VALUE = cat_sc(FNPROC.VALUE, '(');
return_GENFUNCTIONCALLSTART = FNPROC;
return return_GENFUNCTIONCALLSTART;
}
TPSEXPRESSION GENFUNCTIONCALLEND(TPSEXPRESSION FNPROC) {
TPSEXPRESSION return_GENFUNCTIONCALLEND;
FNPROC.VALUE = cat_sc(FNPROC.VALUE, ')');
return_GENFUNCTIONCALLEND = FNPROC;
return return_GENFUNCTIONCALLEND;
}
TPSEXPRESSION GENFUNCTIONCALLARGUMENT(TPSEXPRESSION FNPROC, TPSEXPRESSION ARG, TPSVARIABLE DEF, PBoolean FIRST) {
TPSEXPRESSION return_GENFUNCTIONCALLARGUMENT;
TPSEXPRESSION COERCED;
if (!FIRST) FNPROC.VALUE = cat_ss(FNPROC.VALUE, str_make(2, ", "));
if (DEF.ISREFERENCE) FNPROC.VALUE = cat_sc(FNPROC.VALUE, '&');
COERCED = COERCETYPE(ARG, DEF.TYPEINDEX);
FNPROC.VALUE = cat_ss(FNPROC.VALUE, COERCED.VALUE);
return_GENFUNCTIONCALLARGUMENT = FNPROC;
return return_GENFUNCTIONCALLARGUMENT;
}
TPSEXPRESSION GENPARENS(TPSEXPRESSION EXPR) {
TPSEXPRESSION return_GENPARENS;
EXPR.VALUE = cat_sc(cat_cs('(', EXPR.VALUE), ')');
return_GENPARENS = EXPR;
return return_GENPARENS;
}
TPSEXPRESSION PSFUNCTIONCALL(TPSIDENTIFIER ID) {
TPSEXPRESSION return_PSFUNCTIONCALL;
TPSEXPRESSION EXPR;
int ARGNUM;
EXPR.TYPEINDEX = DEFS.FUNCTIONS[(ID.FUNCTIONINDEX) - 1].RETURNTYPEINDEX;
EXPR.VALUE = ID.VALUE;
WANTTOKENANDREAD(TKLPAREN);
EXPR = GENFUNCTIONCALLSTART(EXPR);
{
int first = 1;
int last = DEFS.FUNCTIONS[(ID.FUNCTIONINDEX) - 1].ARGCOUNT;
if (first <= last) {
ARGNUM = first;
while (1) {
{
if (ARGNUM != 1) WANTTOKENANDREAD(TKCOMMA);
EXPR = GENFUNCTIONCALLARGUMENT(EXPR, PSEXPRESSION(), DEFS.FUNCTIONS[(ID.FUNCTIONINDEX) - 1].ARGS[(ARGNUM) - 1], ARGNUM == 1);
}
if (ARGNUM == last) break;
++ARGNUM;
}
}
}
WANTTOKENANDREAD(TKRPAREN);
return_PSFUNCTIONCALL = GENFUNCTIONCALLEND(EXPR);
return return_PSFUNCTIONCALL;
}
void OUTREAD(STRING SRC, TPSIDENTIFIER OUTVAR) {
if (OUTVAR.CLS != IDCVARIABLE) {
{
write_s(STDERR, str_make(41, "Expected variable for read argument, got "));
write_s(STDERR, OUTVAR.VALUE);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
if (!ISSTRINGYTYPE(OUTVAR.TYPEINDEX)) {
{
write_s(STDERR, str_make(31, "Invalid type for read argument "));
write_s(STDERR, OUTVAR.VALUE);
write_s(STDERR, str_make(5, " got "));
write_s(STDERR, TYPENAME(OUTVAR.TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
{
write_s(OUTPUT, str_make(5, "read_"));
write_c(OUTPUT, SHORTTYPENAME(OUTVAR.TYPEINDEX));
write_c(OUTPUT, '(');
write_s(OUTPUT, SRC);
write_s(OUTPUT, str_make(3, ", &"));
write_s(OUTPUT, OUTVAR.VALUE);
write_s(OUTPUT, str_make(2, ");"));
writeln(OUTPUT);
}
}
void OUTREADLN(STRING SRC) {
{
write_s(OUTPUT, str_make(7, "readln("));
write_s(OUTPUT, SRC);
write_s(OUTPUT, str_make(2, ");"));
writeln(OUTPUT);
}
}
void PSREAD(TPSIDENTIFIER ID) {
STRING SRC;
TPSIDENTIFIER OUTVAR;
OUTBEGIN();
SRC = str_make(5, "INPUT");
WANTTOKENANDREAD(TKLPAREN);
if (LXTOKEN.ID != TKRPAREN) {
OUTVAR = PSIDENTIFIER();
if (ISTEXTTYPE(OUTVAR.TYPEINDEX)) SRC = OUTVAR.VALUE;
 else OUTREAD(SRC, OUTVAR);
WANTTOKEN2(TKCOMMA, TKRPAREN);
SKIPTOKEN(TKCOMMA);
while (LXTOKEN.ID != TKRPAREN) {
WANTTOKEN(TKIDENTIFIER);
OUTVAR = PSIDENTIFIER();
OUTREAD(SRC, OUTVAR);
WANTTOKEN2(TKCOMMA, TKRPAREN);
SKIPTOKEN(TKCOMMA);
}
}
WANTTOKENANDREAD(TKRPAREN);
if (ID.CLS == IDCREADLN) OUTREADLN(SRC);
OUTEND();
}
void OUTWRITE(STRING DST, TPSEXPRESSION EXPR) {
if (DEFS.TYPES[(EXPR.TYPEINDEX) - 1].CLS == TTCENUM) {
write_s(OUTPUT, str_make(8, "write_e("));
write_s(OUTPUT, DST);
write_s(OUTPUT, str_make(2, ", "));
write_s(OUTPUT, EXPR.VALUE);
write_s(OUTPUT, str_make(12, ", EnumValues"));
write_i(OUTPUT, DEFS.TYPES[(EXPR.TYPEINDEX) - 1].ENUMINDEX);
write_s(OUTPUT, str_make(2, ");"));
writeln(OUTPUT);
}
 else {
write_s(OUTPUT, str_make(6, "write_"));
write_c(OUTPUT, SHORTTYPENAME(EXPR.TYPEINDEX));
write_c(OUTPUT, '(');
write_s(OUTPUT, DST);
write_s(OUTPUT, str_make(2, ", "));
write_s(OUTPUT, EXPR.VALUE);
write_s(OUTPUT, str_make(2, ");"));
writeln(OUTPUT);
}
}
void OUTWRITELN(STRING SRC) {
{
write_s(OUTPUT, str_make(8, "writeln("));
write_s(OUTPUT, SRC);
write_s(OUTPUT, str_make(2, ");"));
writeln(OUTPUT);
}
}
void PSWRITE(TPSIDENTIFIER ID) {
STRING DST;
TPSEXPRESSION EXPR;
OUTBEGIN();
DST = str_make(6, "OUTPUT");
WANTTOKENANDREAD(TKLPAREN);
if (LXTOKEN.ID != TKRPAREN) {
EXPR = PSEXPRESSION();
if (ISTEXTTYPE(EXPR.TYPEINDEX)) DST = EXPR.VALUE;
 else OUTWRITE(DST, EXPR);
WANTTOKEN2(TKCOMMA, TKRPAREN);
SKIPTOKEN(TKCOMMA);
while (LXTOKEN.ID != TKRPAREN) {
OUTWRITE(DST, PSEXPRESSION());
WANTTOKEN2(TKCOMMA, TKRPAREN);
SKIPTOKEN(TKCOMMA);
}
}
WANTTOKENANDREAD(TKRPAREN);
if (ID.CLS == IDCWRITELN) OUTWRITELN(DST);
OUTEND();
}
void OUTSTR(STRING DST, TPSEXPRESSION EXPR) {
if (DEFS.TYPES[(EXPR.TYPEINDEX) - 1].CLS == TTCENUM) {
write_s(OUTPUT, DST);
write_s(OUTPUT, str_make(12, " = to_str_e("));
write_s(OUTPUT, EXPR.VALUE);
write_s(OUTPUT, str_make(12, ", EnumValues"));
write_i(OUTPUT, DEFS.TYPES[(EXPR.TYPEINDEX) - 1].ENUMINDEX);
write_s(OUTPUT, str_make(2, ");"));
writeln(OUTPUT);
}
 else {
write_s(OUTPUT, DST);
write_s(OUTPUT, str_make(10, " = to_str_"));
write_c(OUTPUT, SHORTTYPENAME(EXPR.TYPEINDEX));
write_c(OUTPUT, '(');
write_s(OUTPUT, EXPR.VALUE);
write_s(OUTPUT, str_make(2, ");"));
writeln(OUTPUT);
}
}
void PSSTR() {
TPSEXPRESSION EXPR;
TPSIDENTIFIER DEST;
WANTTOKENANDREAD(TKLPAREN);
EXPR = PSEXPRESSION();
WANTTOKENANDREAD(TKCOMMA);
DEST = PSIDENTIFIER();
if (!ISSTRINGTYPE(DEST.TYPEINDEX)) {
{
write_s(STDERR, str_make(47, "Destination argument is not a string variable: "));
write_s(STDERR, DEST.NAME);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
WANTTOKENANDREAD(TKRPAREN);
OUTSTR(DEST.VALUE, EXPR);
}
TPSEXPRESSION GENVARIABLE(TPSIDENTIFIER ID) {
TPSEXPRESSION return_GENVARIABLE;
TPSEXPRESSION EXPR;
EXPR.TYPEINDEX = ID.TYPEINDEX;
EXPR.VALUE = ID.VALUE;
return_GENVARIABLE = EXPR;
return return_GENVARIABLE;
}
TPSEXPRESSION PSFACTOR() {
TPSEXPRESSION return_PSFACTOR;
TPSEXPRESSION EXPR;
TPSIDENTIFIER ID;
TPSCONSTANTINDEX CONSTINDEX;
TLXPOS POS;
if (LXTOKEN.ID == TKIDENTIFIER) {
CONSTINDEX = FINDCONSTANT(LXTOKEN.VALUE);
if (CONSTINDEX != 0) {
POS = LXTOKEN.POS;
LXTOKEN = DEFS.CONSTANTS[(CONSTINDEX) - 1].REPLACEMENT;
LXTOKEN.POS = POS;
}
}
if ((LXTOKEN.ID == TKFALSE) || (LXTOKEN.ID == TKTRUE)) {
EXPR = GENBOOLEANCONSTANT(LXTOKEN.ID == TKTRUE);
READTOKEN();
}
 else if (LXTOKEN.ID == TKSTRING) EXPR = GENSTRINGCONSTANT(GETTOKENVALUEANDREAD(TKSTRING));
 else if (LXTOKEN.ID == TKNUMBER) EXPR = GENNUMBERCONSTANT(GETTOKENVALUEANDREAD(TKNUMBER));
 else if (LXTOKEN.ID == TKIDENTIFIER) {
ID = PSIDENTIFIER();
if (ID.CLS == IDCFUNCTION) EXPR = PSFUNCTIONCALL(ID);
 else if (ID.CLS == IDCVARIABLE) EXPR = GENVARIABLE(ID);
 else {
{
write_s(STDERR, str_make(35, "Expected variable or function, got "));
write_e(STDERR, ID.CLS, EnumValues3);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
 else if (LXTOKEN.ID == TKLPAREN) {
WANTTOKENANDREAD(TKLPAREN);
EXPR = GENPARENS(PSEXPRESSION());
WANTTOKENANDREAD(TKRPAREN);
}
 else if (LXTOKEN.ID == TKNOT) {
WANTTOKENANDREAD(TKNOT);
EXPR = UNARYEXPRESSION(TKNOT, PSFACTOR());
}
 else {
{
write_s(STDERR, str_make(29, "Invalid token in expression: "));
write_s(STDERR, LXTOKENSTR());
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
return_PSFACTOR = EXPR;
return return_PSFACTOR;
}
TPSEXPRESSION PSTERM() {
TPSEXPRESSION return_PSTERM;
TLXTOKENID OP;
TPSEXPRESSION EXPR;
EXPR = PSFACTOR();
while (ISOPMULTIPYING(LXTOKEN)) {
OP = LXTOKEN.ID;
READTOKEN();
EXPR = BINARYEXPRESSION(EXPR, OP, PSFACTOR());
}
return_PSTERM = EXPR;
return return_PSTERM;
}
TPSEXPRESSION PSSIMPLEEXPRESSION() {
TPSEXPRESSION return_PSSIMPLEEXPRESSION;
TLXTOKENID OP;
TPSEXPRESSION EXPR;
EXPR = PSTERM();
while (ISOPADDING(LXTOKEN)) {
OP = LXTOKEN.ID;
READTOKEN();
EXPR = BINARYEXPRESSION(EXPR, OP, PSTERM());
}
return_PSSIMPLEEXPRESSION = EXPR;
return return_PSSIMPLEEXPRESSION;
}
TPSEXPRESSION PSEXPRESSION() {
TPSEXPRESSION return_PSEXPRESSION;
TLXTOKENID OP;
TPSEXPRESSION EXPR;
EXPR = PSSIMPLEEXPRESSION();
while (ISOPRELATIONAL(LXTOKEN)) {
OP = LXTOKEN.ID;
READTOKEN();
EXPR = BINARYEXPRESSION(EXPR, OP, PSSIMPLEEXPRESSION());
}
return_PSEXPRESSION = EXPR;
return return_PSEXPRESSION;
}
void OUTEXPRESSION(TPSEXPRESSION EXPR) {
{
write_s(OUTPUT, EXPR.VALUE);
}
}
void OUTASSIGN(TPSIDENTIFIER ID, TPSEXPRESSION EXPR) {
OUTIDENTIFIER(ID);
{
write_s(OUTPUT, str_make(3, " = "));
}
OUTEXPRESSION(COERCETYPE(EXPR, ID.TYPEINDEX));
{
write_c(OUTPUT, ';');
writeln(OUTPUT);
}
}
void OUTIF(TPSEXPRESSION EXPR) {
{
write_s(OUTPUT, str_make(4, "if ("));
write_s(OUTPUT, EXPR.VALUE);
write_s(OUTPUT, str_make(2, ") "));
}
}
void OUTELSE() {
{
write_s(OUTPUT, str_make(6, " else "));
}
}
void OUTREPEATBEGIN() {
{
write_s(OUTPUT, str_make(4, "do {"));
writeln(OUTPUT);
}
}
void OUTREPEATEND(TPSEXPRESSION EXPR) {
if (!ISBOOLEANTYPE(EXPR.TYPEINDEX)) {
{
write_s(STDERR, str_make(33, "Expected boolean expression, got "));
write_s(STDERR, TYPENAME(EXPR.TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
{
write_s(OUTPUT, str_make(11, "} while (!("));
write_s(OUTPUT, EXPR.VALUE);
write_s(OUTPUT, str_make(3, "));"));
writeln(OUTPUT);
}
}
void OUTWHILEBEGIN(TPSEXPRESSION EXPR) {
if (!ISBOOLEANTYPE(EXPR.TYPEINDEX)) {
{
write_s(STDERR, str_make(33, "Expected boolean expression, got "));
write_s(STDERR, TYPENAME(EXPR.TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
{
write_s(OUTPUT, str_make(7, "while ("));
write_s(OUTPUT, EXPR.VALUE);
write_s(OUTPUT, str_make(2, ") "));
}
}
void OUTWHILEEND() {
}
void OUTFORBEGIN(TPSIDENTIFIER ID, TPSEXPRESSION FIRSTEXPR, TPSEXPRESSION LASTEXPR, PBoolean ASCENDING) {
TPSVARIABLE FIRST;
TPSVARIABLE LAST;
FIRST = MAKEVARIABLE(str_make(5, "first"), ID.TYPEINDEX, 0);
LAST = MAKEVARIABLE(str_make(4, "last"), ID.TYPEINDEX, 0);
{
write_c(OUTPUT, '{');
writeln(OUTPUT);
}
OUTVARIABLEDECLARATION(FIRST);
{
write_s(OUTPUT, str_make(3, " = "));
write_s(OUTPUT, FIRSTEXPR.VALUE);
write_c(OUTPUT, ';');
writeln(OUTPUT);
}
OUTVARIABLEDECLARATION(LAST);
{
write_s(OUTPUT, str_make(3, " = "));
write_s(OUTPUT, LASTEXPR.VALUE);
write_c(OUTPUT, ';');
writeln(OUTPUT);
}
{
write_s(OUTPUT, str_make(10, "if (first "));
}
if (ASCENDING) {
write_s(OUTPUT, str_make(2, "<="));
}
 else {
write_s(OUTPUT, str_make(2, "=>"));
}
{
write_s(OUTPUT, str_make(8, " last) {"));
writeln(OUTPUT);
}
{
write_s(OUTPUT, ID.VALUE);
write_s(OUTPUT, str_make(9, " = first;"));
writeln(OUTPUT);
}
{
write_s(OUTPUT, str_make(11, "while (1) {"));
writeln(OUTPUT);
}
}
void OUTFOREND(TPSIDENTIFIER ID, PBoolean ASCENDING) {
{
write_s(OUTPUT, str_make(4, "if ("));
write_s(OUTPUT, ID.VALUE);
write_s(OUTPUT, str_make(16, " == last) break;"));
writeln(OUTPUT);
}
if (ASCENDING) {
write_s(OUTPUT, str_make(2, "++"));
write_s(OUTPUT, ID.VALUE);
write_c(OUTPUT, ';');
writeln(OUTPUT);
}
 else {
write_s(OUTPUT, str_make(2, "--"));
write_s(OUTPUT, ID.VALUE);
write_c(OUTPUT, ';');
}
{
write_c(OUTPUT, '}');
writeln(OUTPUT);
}
{
write_c(OUTPUT, '}');
writeln(OUTPUT);
}
{
write_c(OUTPUT, '}');
writeln(OUTPUT);
}
}
void PSFOR() {
TPSIDENTIFIER ID;
TPSEXPRESSION FIRST;
TPSEXPRESSION LAST;
PBoolean ASCENDING;
WANTTOKENANDREAD(TKFOR);
ID = PSIDENTIFIER();
if (ID.CLS != IDCVARIABLE) {
{
write_s(STDERR, str_make(19, "Expected variable: "));
write_s(STDERR, ID.VALUE);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
WANTTOKENANDREAD(TKASSIGN);
FIRST = PSEXPRESSION();
WANTTOKEN2(TKTO, TKDOWNTO);
ASCENDING = LXTOKEN.ID == TKTO;
READTOKEN();
LAST = PSEXPRESSION();
WANTTOKENANDREAD(TKDO);
OUTFORBEGIN(ID, FIRST, LAST, ASCENDING);
PSSTATEMENT();
OUTFOREND(ID, ASCENDING);
}
void OUTPROCEDURECALL(TPSEXPRESSION EXPR) {
{
write_s(OUTPUT, EXPR.VALUE);
write_c(OUTPUT, ';');
writeln(OUTPUT);
}
}
void PSPROCEDURECALL(TPSIDENTIFIER ID) {
OUTPROCEDURECALL(PSFUNCTIONCALL(ID));
}
void OUTEMPTYSTATEMENT() {
{
write_c(OUTPUT, ';');
writeln(OUTPUT);
}
}
void PSSTATEMENT() {
TPSIDENTIFIER ID;
if (LXTOKEN.ID == TKSEMICOLON) OUTEMPTYSTATEMENT();
 else if (LXTOKEN.ID == TKBEGIN) {
OUTBEGIN();
SKIPTOKEN(TKBEGIN);
while (LXTOKEN.ID != TKEND) {
PSSTATEMENT();
WANTTOKEN2(TKSEMICOLON, TKEND);
SKIPTOKEN(TKSEMICOLON);
}
OUTEND();
SKIPTOKEN(TKEND);
}
 else if (LXTOKEN.ID == TKIDENTIFIER) {
ID = PSIDENTIFIER();
if ((ID.CLS == IDCREAD) || (ID.CLS == IDCREADLN)) PSREAD(ID);
 else if ((ID.CLS == IDCWRITE) || (ID.CLS == IDCWRITELN)) PSWRITE(ID);
 else if (ID.CLS == IDCSTR) PSSTR();
 else if (ID.CLS == IDCFUNCTION) PSPROCEDURECALL(ID);
 else if (LXTOKEN.ID == TKASSIGN) {
WANTTOKENANDREAD(TKASSIGN);
OUTASSIGN(ID, PSEXPRESSION());
}
}
 else if (LXTOKEN.ID == TKIF) {
WANTTOKENANDREAD(TKIF);
OUTIF(PSEXPRESSION());
WANTTOKENANDREAD(TKTHEN);
if (LXTOKEN.ID == TKELSE) OUTEMPTYSTATEMENT();
 else PSSTATEMENT();
if (LXTOKEN.ID == TKELSE) {
WANTTOKENANDREAD(TKELSE);
OUTELSE();
PSSTATEMENT();
}
}
 else if (LXTOKEN.ID == TKREPEAT) {
WANTTOKENANDREAD(TKREPEAT);
OUTREPEATBEGIN();
while (LXTOKEN.ID != TKUNTIL) {
PSSTATEMENT();
WANTTOKEN2(TKSEMICOLON, TKUNTIL);
SKIPTOKEN(TKSEMICOLON);
}
WANTTOKENANDREAD(TKUNTIL);
OUTREPEATEND(PSEXPRESSION());
}
 else if (LXTOKEN.ID == TKWHILE) {
WANTTOKENANDREAD(TKWHILE);
OUTWHILEBEGIN(PSEXPRESSION());
WANTTOKENANDREAD(TKDO);
PSSTATEMENT();
OUTWHILEEND();
}
 else if (LXTOKEN.ID == TKFOR) PSFOR();
 else {
{
write_s(STDERR, str_make(17, "Unexpected token "));
write_s(STDERR, LXTOKENSTR());
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
void OUTPROGRAMBEGIN() {
{
write_s(OUTPUT, str_make(21, "void pascual_main() {"));
writeln(OUTPUT);
}
}
void OUTPROGRAMEND() {
{
write_c(OUTPUT, '}');
writeln(OUTPUT);
}
}
void PSPROGRAMBLOCK() {
PSDEFINITIONS(GLOBALSCOPE);
WANTTOKENANDREAD(TKBEGIN);
OUTPROGRAMBEGIN();
while (LXTOKEN.ID != TKEND) {
PSSTATEMENT();
WANTTOKEN2(TKSEMICOLON, TKEND);
SKIPTOKEN(TKSEMICOLON);
}
OUTPROGRAMEND();
WANTTOKENANDREAD(TKEND);
}
void PARSEPROGRAM() {
LXPOS.ROW = 0;
LXPOS.COL = 0;
STARTGLOBALSCOPE();
READTOKEN();
PSPROGRAMHEADING();
PSPROGRAMBLOCK();
WANTTOKENANDREAD(TKDOT);
WANTTOKEN(TKEOF);
}
void pascual_main() {
PARSEPROGRAM();
}
