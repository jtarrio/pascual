/* Program: COMPILER */
#include "pascual.h"
typedef enum { TKUNKNOWN, TKEOF, TKCOMMENT, TKIDENTIFIER, TKNUMBER, TKSTRING, TKPLUS, TKMINUS, TKASTERISK, TKSLASH, TKEQUALS, TKLESSTHAN, TKMORETHAN, TKLBRACKET, TKRBRACKET, TKDOT, TKCOMMA, TKCOLON, TKSEMICOLON, TKCARET, TKLPAREN, TKRPAREN, TKNOTEQUALS, TKLESSOREQUALS, TKMOREOREQUALS, TKASSIGN, TKRANGE, TKAND, TKFALSE, TKTRUE, TKARRAY, TKBEGIN, TKCASE, TKCONST, TKDIV, TKDO, TKDOWNTO, TKELSE, TKEND, TKFILE, TKFOR, TKFORWARD, TKFUNCTION, TKGOTO, TKIF, TKIN, TKLABEL, TKMOD, TKNIL, TKNOT, TKOF, TKOR, TKPACKED, TKPROCEDURE, TKPROGRAM, TKRECORD, TKREPEAT, TKSET, TKTHEN, TKTO, TKTYPE, TKUNTIL, TKVAR, TKWHILE, TKWITH} TLXTOKENID;
typedef struct { int ROW; int COL; } TLXPOS;
typedef struct { TLXTOKENID ID; PString VALUE; TLXPOS POS; } TLXTOKEN;
typedef struct { PFile SRC; PString NAME; TLXPOS POS; } TLXINPUTFILE;
const char* EnumValues1[] = { "TKUNKNOWN", "TKEOF", "TKCOMMENT", "TKIDENTIFIER", "TKNUMBER", "TKSTRING", "TKPLUS", "TKMINUS", "TKASTERISK", "TKSLASH", "TKEQUALS", "TKLESSTHAN", "TKMORETHAN", "TKLBRACKET", "TKRBRACKET", "TKDOT", "TKCOMMA", "TKCOLON", "TKSEMICOLON", "TKCARET", "TKLPAREN", "TKRPAREN", "TKNOTEQUALS", "TKLESSOREQUALS", "TKMOREOREQUALS", "TKASSIGN", "TKRANGE", "TKAND", "TKFALSE", "TKTRUE", "TKARRAY", "TKBEGIN", "TKCASE", "TKCONST", "TKDIV", "TKDO", "TKDOWNTO", "TKELSE", "TKEND", "TKFILE", "TKFOR", "TKFORWARD", "TKFUNCTION", "TKGOTO", "TKIF", "TKIN", "TKLABEL", "TKMOD", "TKNIL", "TKNOT", "TKOF", "TKOR", "TKPACKED", "TKPROCEDURE", "TKPROGRAM", "TKRECORD", "TKREPEAT", "TKSET", "TKTHEN", "TKTO", "TKTYPE", "TKUNTIL", "TKVAR", "TKWHILE", "TKWITH" };
struct { PString LINE; TLXTOKEN TOKEN; TLXINPUTFILE INPUT; struct { PBoolean EXISTS; TLXINPUTFILE INPUT; } PREV; } LEXER;
PString LXPOSSTR(TLXPOS POS) {
PString return_LXPOSSTR;
PString ROW;
PString COL;
ROW = to_str_i(POS.ROW);
COL = to_str_i(POS.COL);
return_LXPOSSTR = cat_ss(cat_ss(cat_ss(cat_ss(cat_ss(str_make(4, "row "), ROW), str_make(5, " col ")), COL), str_make(4, " in ")), LEXER.INPUT.NAME);
return return_LXPOSSTR;
}
PString LXWHERESTR() {
PString return_LXWHERESTR;
return_LXWHERESTR = cat_ss(str_make(6, " near "), LXPOSSTR(LEXER.TOKEN.POS));
return return_LXWHERESTR;
}
PString LXTOKENSTR() {
PString return_LXTOKENSTR;
PString ID;
ID = to_str_e(LEXER.TOKEN.ID, EnumValues1);
return_LXTOKENSTR = cat_sc(cat_ss(cat_ss(ID, str_make(2, " [")), LEXER.TOKEN.VALUE), ']');
return return_LXTOKENSTR;
}
PBoolean LXISALPHA(char CHR) {
PBoolean return_LXISALPHA;
return_LXISALPHA = ((cmp_cc(CHR, 'a') >= 0) && (cmp_cc(CHR, 'z') <= 0)) || ((cmp_cc(CHR, 'A') >= 0) && (cmp_cc(CHR, 'Z') <= 0));
return return_LXISALPHA;
}
PBoolean LXISDIGIT(char CHR) {
PBoolean return_LXISDIGIT;
return_LXISDIGIT = (cmp_cc(CHR, '0') >= 0) && (cmp_cc(CHR, '9') <= 0);
return return_LXISDIGIT;
}
PBoolean LXISALPHANUM(char CHR) {
PBoolean return_LXISALPHANUM;
return_LXISALPHANUM = LXISALPHA(CHR) || LXISDIGIT(CHR);
return return_LXISALPHANUM;
}
PBoolean LXISIDENTIFIERFIRST(char CHR) {
PBoolean return_LXISIDENTIFIERFIRST;
return_LXISIDENTIFIERFIRST = LXISALPHA(CHR) || (cmp_cc(CHR, '_') == 0);
return return_LXISIDENTIFIERFIRST;
}
PBoolean LXISIDENTIFIERCHAR(char CHR) {
PBoolean return_LXISIDENTIFIERCHAR;
return_LXISIDENTIFIERCHAR = LXISALPHANUM(CHR) || (cmp_cc(CHR, '_') == 0);
return return_LXISIDENTIFIERCHAR;
}
PBoolean LXISTOKENWAITING() {
PBoolean return_LXISTOKENWAITING;
do {
while ((LENGTH(LEXER.LINE) == 0) && !EOF(&LEXER.INPUT.SRC)) {
LEXER.INPUT.POS.ROW = LEXER.INPUT.POS.ROW + 1;
LEXER.INPUT.POS.COL = 1;
{
read_s(&LEXER.INPUT.SRC, &LEXER.LINE);
readln(&LEXER.INPUT.SRC);
}
}
while ((LENGTH(LEXER.LINE) > 0) && (cmp_cc(LEXER.LINE.chr[1], ' ') == 0)) {
LEXER.INPUT.POS.COL = LEXER.INPUT.POS.COL + 1;
DELETE(&LEXER.LINE, 1, 1);
}
} while (!(EOF(&LEXER.INPUT.SRC) || (LENGTH(LEXER.LINE) > 0)));
return_LXISTOKENWAITING = LENGTH(LEXER.LINE) > 0;
return return_LXISTOKENWAITING;
}
void LXGETSYMBOL(TLXTOKENID ID, int LENGTH) {
LEXER.TOKEN.ID = ID;
LEXER.TOKEN.VALUE = COPY(LEXER.LINE, 1, LENGTH);
LEXER.TOKEN.POS = LEXER.INPUT.POS;
DELETE(&LEXER.LINE, 1, LENGTH);
LEXER.INPUT.POS.COL = LEXER.INPUT.POS.COL + LENGTH;
}
void LXGETIDENTIFIER() {
char CHR;
int POS;
PBoolean INTOKEN;
POS = 0;
INTOKEN = 1;
while ((POS < LENGTH(LEXER.LINE)) && INTOKEN) {
CHR = LEXER.LINE.chr[POS + 1];
INTOKEN = LXISIDENTIFIERCHAR(CHR);
if (INTOKEN) POS = POS + 1;
}
LXGETSYMBOL(TKIDENTIFIER, POS);
{
int first = 1;
int last = LENGTH(LEXER.TOKEN.VALUE);
if (first <= last) {
POS = first;
while (1) {
LEXER.TOKEN.VALUE.chr[POS] = UPCASE(LEXER.TOKEN.VALUE.chr[POS]);
if (POS == last) break;
++POS;
}
}
}
if (cmp_ss(LEXER.TOKEN.VALUE, str_make(3, "AND")) == 0) LEXER.TOKEN.ID = TKAND;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(5, "ARRAY")) == 0) LEXER.TOKEN.ID = TKARRAY;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(5, "BEGIN")) == 0) LEXER.TOKEN.ID = TKBEGIN;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(4, "CASE")) == 0) LEXER.TOKEN.ID = TKCASE;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(5, "CONST")) == 0) LEXER.TOKEN.ID = TKCONST;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(3, "DIV")) == 0) LEXER.TOKEN.ID = TKDIV;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(2, "DO")) == 0) LEXER.TOKEN.ID = TKDO;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(6, "DOWNTO")) == 0) LEXER.TOKEN.ID = TKDOWNTO;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(4, "ELSE")) == 0) LEXER.TOKEN.ID = TKELSE;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(3, "END")) == 0) LEXER.TOKEN.ID = TKEND;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(4, "FILE")) == 0) LEXER.TOKEN.ID = TKFILE;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(3, "FOR")) == 0) LEXER.TOKEN.ID = TKFOR;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(7, "FORWARD")) == 0) LEXER.TOKEN.ID = TKFORWARD;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(8, "FUNCTION")) == 0) LEXER.TOKEN.ID = TKFUNCTION;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(4, "GOTO")) == 0) LEXER.TOKEN.ID = TKGOTO;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(2, "IF")) == 0) LEXER.TOKEN.ID = TKIF;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(2, "IN")) == 0) LEXER.TOKEN.ID = TKIN;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(5, "LABEL")) == 0) LEXER.TOKEN.ID = TKLABEL;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(3, "MOD")) == 0) LEXER.TOKEN.ID = TKMOD;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(3, "NIL")) == 0) LEXER.TOKEN.ID = TKNIL;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(3, "NOT")) == 0) LEXER.TOKEN.ID = TKNOT;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(2, "OF")) == 0) LEXER.TOKEN.ID = TKOF;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(2, "OR")) == 0) LEXER.TOKEN.ID = TKOR;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(6, "PACKED")) == 0) LEXER.TOKEN.ID = TKPACKED;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(9, "PROCEDURE")) == 0) LEXER.TOKEN.ID = TKPROCEDURE;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(7, "PROGRAM")) == 0) LEXER.TOKEN.ID = TKPROGRAM;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(6, "RECORD")) == 0) LEXER.TOKEN.ID = TKRECORD;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(6, "REPEAT")) == 0) LEXER.TOKEN.ID = TKREPEAT;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(3, "SET")) == 0) LEXER.TOKEN.ID = TKSET;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(4, "THEN")) == 0) LEXER.TOKEN.ID = TKTHEN;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(2, "TO")) == 0) LEXER.TOKEN.ID = TKTO;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(4, "TYPE")) == 0) LEXER.TOKEN.ID = TKTYPE;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(5, "UNTIL")) == 0) LEXER.TOKEN.ID = TKUNTIL;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(3, "VAR")) == 0) LEXER.TOKEN.ID = TKVAR;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(5, "WHILE")) == 0) LEXER.TOKEN.ID = TKWHILE;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(4, "WITH")) == 0) LEXER.TOKEN.ID = TKWITH;
}
void LXGETNUMBER() {
char CHR;
int POS;
PBoolean INTOKEN;
POS = 0;
INTOKEN = 1;
while ((POS < LENGTH(LEXER.LINE)) && INTOKEN) {
CHR = LEXER.LINE.chr[POS + 1];
INTOKEN = LXISDIGIT(CHR);
if (INTOKEN) POS = POS + 1;
}
LXGETSYMBOL(TKNUMBER, POS);
}
void LXGETSTRING() {
char CHR;
int POS;
PBoolean INSTRING;
POS = 1;
INSTRING = 1;
while (INSTRING) {
POS = POS + 1;
CHR = LEXER.LINE.chr[POS];
if (cmp_cc(CHR, '\'') == 0) {
if ((LENGTH(LEXER.LINE) > POS + 1) && (cmp_cc(LEXER.LINE.chr[POS + 1], '\'') == 0)) POS = POS + 1;
 else INSTRING = 0;
}
}
LXGETSYMBOL(TKSTRING, POS);
}
void LXGETCOMMENT() {
PBoolean DONE;
int DELIMITERLENGTH;
PString COMMENT;
COMMENT = str_make(0, "");
DONE = 0;
if (cmp_cc(LEXER.LINE.chr[1], '{') == 0) DELIMITERLENGTH = 1;
 else DELIMITERLENGTH = 2;
LXGETSYMBOL(TKCOMMENT, DELIMITERLENGTH);
do {
while (cmp_ss(LEXER.LINE, str_make(0, "")) == 0) {
COMMENT = cat_sc(COMMENT, ' ');
{
read_s(&LEXER.INPUT.SRC, &LEXER.LINE);
readln(&LEXER.INPUT.SRC);
}
LEXER.INPUT.POS.ROW = LEXER.INPUT.POS.ROW + 1;
LEXER.INPUT.POS.COL = 1;
}
if (DELIMITERLENGTH == 1) DONE = cmp_cc(LEXER.LINE.chr[1], '}') == 0;
 else DONE = (cmp_cc(LEXER.LINE.chr[1], '*') == 0) && (cmp_cc(LEXER.LINE.chr[2], ')') == 0);
if (!DONE) {
COMMENT = cat_sc(COMMENT, LEXER.LINE.chr[1]);
DELETE(&LEXER.LINE, 1, 1);
LEXER.INPUT.POS.COL = LEXER.INPUT.POS.COL + 1;
}
} while (!(DONE));
DELETE(&LEXER.LINE, 1, DELIMITERLENGTH);
LEXER.INPUT.POS.COL = LEXER.INPUT.POS.COL + DELIMITERLENGTH;
LEXER.TOKEN.VALUE = COMMENT;
}
void LXREADTOKEN() {
char CHR;
PString PFX;
LEXER.TOKEN.VALUE = str_make(0, "");
LEXER.TOKEN.ID = TKUNKNOWN;
if (!LXISTOKENWAITING()) LEXER.TOKEN.ID = TKEOF;
 else {
CHR = LEXER.LINE.chr[1];
if (LENGTH(LEXER.LINE) >= 2) PFX = cat_cc(LEXER.LINE.chr[1], LEXER.LINE.chr[2]);
 else PFX = str_make(0, "");
if (LXISIDENTIFIERFIRST(CHR)) LXGETIDENTIFIER();
 else if (LXISDIGIT(CHR)) LXGETNUMBER();
 else if (cmp_cc(CHR, '\'') == 0) LXGETSTRING();
 else if (cmp_ss(PFX, str_make(2, "<>")) == 0) LXGETSYMBOL(TKNOTEQUALS, 2);
 else if (cmp_ss(PFX, str_make(2, "<=")) == 0) LXGETSYMBOL(TKLESSOREQUALS, 2);
 else if (cmp_ss(PFX, str_make(2, ">=")) == 0) LXGETSYMBOL(TKMOREOREQUALS, 2);
 else if (cmp_ss(PFX, str_make(2, ":=")) == 0) LXGETSYMBOL(TKASSIGN, 2);
 else if (cmp_ss(PFX, str_make(2, "..")) == 0) LXGETSYMBOL(TKRANGE, 2);
 else if (cmp_ss(PFX, str_make(2, "(*")) == 0) LXGETCOMMENT();
 else if (cmp_cc(CHR, '+') == 0) LXGETSYMBOL(TKPLUS, 1);
 else if (cmp_cc(CHR, '-') == 0) LXGETSYMBOL(TKMINUS, 1);
 else if (cmp_cc(CHR, '*') == 0) LXGETSYMBOL(TKASTERISK, 1);
 else if (cmp_cc(CHR, '/') == 0) LXGETSYMBOL(TKSLASH, 1);
 else if (cmp_cc(CHR, '=') == 0) LXGETSYMBOL(TKEQUALS, 1);
 else if (cmp_cc(CHR, '<') == 0) LXGETSYMBOL(TKLESSTHAN, 1);
 else if (cmp_cc(CHR, '>') == 0) LXGETSYMBOL(TKMORETHAN, 1);
 else if (cmp_cc(CHR, '[') == 0) LXGETSYMBOL(TKLBRACKET, 1);
 else if (cmp_cc(CHR, ']') == 0) LXGETSYMBOL(TKRBRACKET, 1);
 else if (cmp_cc(CHR, '.') == 0) LXGETSYMBOL(TKDOT, 1);
 else if (cmp_cc(CHR, ',') == 0) LXGETSYMBOL(TKCOMMA, 1);
 else if (cmp_cc(CHR, ':') == 0) LXGETSYMBOL(TKCOLON, 1);
 else if (cmp_cc(CHR, ';') == 0) LXGETSYMBOL(TKSEMICOLON, 1);
 else if (cmp_cc(CHR, '^') == 0) LXGETSYMBOL(TKCARET, 1);
 else if (cmp_cc(CHR, '(') == 0) LXGETSYMBOL(TKLPAREN, 1);
 else if (cmp_cc(CHR, ')') == 0) LXGETSYMBOL(TKRPAREN, 1);
 else if (cmp_cc(CHR, '{') == 0) LXGETCOMMENT();
 else {
{
write_s(&STDERR, str_make(17, "Could not parse ["));
write_s(&STDERR, LEXER.LINE);
write_s(&STDERR, str_make(5, "] at "));
write_s(&STDERR, LXPOSSTR(LEXER.INPUT.POS));
writeln(&STDERR);
}
HALT(1);
}
}
}
void LXRESET() {
LEXER.LINE = str_make(0, "");
LEXER.INPUT.SRC = INPUT;
LEXER.INPUT.NAME = str_of('-');
LEXER.INPUT.POS.ROW = 0;
LEXER.INPUT.POS.COL = 0;
LEXER.PREV.EXISTS = 0;
}
void LXOPEN(PString FILENAME) {
LEXER.INPUT.NAME = FILENAME;
ASSIGN(&LEXER.INPUT.SRC, LEXER.INPUT.NAME);
RESET(&LEXER.INPUT.SRC);
}
void LXINCLUDE(PString FILENAME) {
if (LEXER.PREV.EXISTS) {
{
write_s(&STDERR, str_make(33, "Include files cannot be recursive"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
LEXER.PREV.EXISTS = 1;
LEXER.PREV.INPUT = LEXER.INPUT;
LEXER.INPUT.POS.ROW = 0;
LEXER.INPUT.POS.COL = 0;
LXOPEN(FILENAME);
}
typedef int TPSENUMINDEX;
typedef int TPSRECORDINDEX;
typedef int TPSARRAYINDEX;
typedef int TPSTYPEINDEX;
typedef enum { TTCBOOLEAN, TTCINTEGER, TTCCHAR, TTCSTRING, TTCTEXT, TTCENUM, TTCRECORD, TTCARRAY, TTCPOINTER, TTCNIL, TTCPLACEHOLDER} TPSTYPECLASS;
typedef struct { PString NAME; TPSTYPECLASS CLS; TPSENUMINDEX ENUMINDEX; TPSRECORDINDEX RECORDINDEX; TPSARRAYINDEX ARRAYINDEX; TPSTYPEINDEX POINTEDTYPEINDEX; TPSTYPEINDEX ALIASFOR; } TPSTYPE;
typedef struct { int SIZE; PString VALUES[1 + 128 - 1]; } TPSENUMDEF;
typedef struct { PString NAME; TPSTYPEINDEX TYPEINDEX; } TPSRECORDFIELD;
typedef struct { int SIZE; TPSRECORDFIELD FIELDS[1 + 16 - 1]; } TPSRECORDDEF;
typedef struct { PString LOWBOUND; PString HIGHBOUND; TPSTYPEINDEX TYPEINDEX; } TPSARRAYDEF;
typedef int TPSCONSTANTINDEX;
typedef struct { PString NAME; TLXTOKEN REPLACEMENT; } TPSCONSTANT;
typedef int TPSVARIABLEINDEX;
typedef struct { PString NAME; TPSTYPEINDEX TYPEINDEX; PBoolean ISREFERENCE; PBoolean ISCONSTANT; } TPSVARIABLE;
typedef int TPSFUNCTIONINDEX;
typedef struct { PString NAME; int ARGCOUNT; TPSVARIABLE ARGS[1 + 4 - 1]; TPSTYPEINDEX RETURNTYPEINDEX; PBoolean ISDECLARATION; } TPSFUNCTION;
typedef int TPSNAMEINDEX;
typedef enum { TNCTYPE, TNCVARIABLE, TNCENUMVALUE, TNCFUNCTION, TNCSPECIALFUNCTION} TPSNAMECLASS;
typedef enum { TSFREAD, TSFREADLN, TSFWRITE, TSFWRITELN, TSFSTR, TSFNEW, TSFDISPOSE} TPSSPECIALFUNCTION;
typedef struct { PString NAME; TPSNAMECLASS CLS; TPSTYPEINDEX TYPEINDEX; TPSVARIABLEINDEX VARIABLEINDEX; TPSFUNCTIONINDEX FUNCTIONINDEX; TPSSPECIALFUNCTION SPECIALFUNCTION; } TPSNAME;
typedef struct { int NUMNAMES; int NUMTYPES; int NUMENUMS; int NUMRECORDS; int NUMARRAYS; int NUMCONSTANTS; int NUMVARIABLES; int NUMFUNCTIONS; } TPSSCOPE;
typedef struct { TPSSCOPE SCOPE; TPSNAME NAMES[1 + 1024 - 1]; TPSTYPE TYPES[1 + 128 - 1]; TPSENUMDEF ENUMS[1 + 16 - 1]; TPSRECORDDEF RECORDS[1 + 32 - 1]; TPSARRAYDEF ARRAYS[1 + 32 - 1]; TPSCONSTANT CONSTANTS[1 + 32 - 1]; TPSVARIABLE VARIABLES[1 + 32 - 1]; TPSFUNCTION FUNCTIONS[1 + 256 - 1]; } TPSDEFS;
typedef enum { IDCVARIABLE, IDCFUNCTION, IDCREAD, IDCREADLN, IDCWRITE, IDCWRITELN, IDCSTR} TPSIDCLASS;
typedef struct { PString NAME; } TPSIDENTIFIER;
const char* EnumValues2[] = { "TTCBOOLEAN", "TTCINTEGER", "TTCCHAR", "TTCSTRING", "TTCTEXT", "TTCENUM", "TTCRECORD", "TTCARRAY", "TTCPOINTER", "TTCNIL", "TTCPLACEHOLDER" };
const char* EnumValues3[] = { "TNCTYPE", "TNCVARIABLE", "TNCENUMVALUE", "TNCFUNCTION", "TNCSPECIALFUNCTION" };
const char* EnumValues4[] = { "TSFREAD", "TSFREADLN", "TSFWRITE", "TSFWRITELN", "TSFSTR", "TSFNEW", "TSFDISPOSE" };
const char* EnumValues5[] = { "IDCVARIABLE", "IDCFUNCTION", "IDCREAD", "IDCREADLN", "IDCWRITE", "IDCWRITELN", "IDCSTR" };
TPSDEFS DEFS;
struct { TPSTYPEINDEX PTNIL; TPSTYPEINDEX PTBOOLEAN; TPSTYPEINDEX PTINTEGER; TPSTYPEINDEX PTCHAR; TPSTYPEINDEX PTSTRING; TPSTYPEINDEX PTTEXT; } PRIMITIVETYPES;
TPSSCOPE GLOBALSCOPE;
void CLEARDEFS() {
DEFS.SCOPE.NUMNAMES = 0;
DEFS.SCOPE.NUMTYPES = 0;
DEFS.SCOPE.NUMENUMS = 0;
DEFS.SCOPE.NUMRECORDS = 0;
DEFS.SCOPE.NUMARRAYS = 0;
DEFS.SCOPE.NUMCONSTANTS = 0;
DEFS.SCOPE.NUMVARIABLES = 0;
DEFS.SCOPE.NUMFUNCTIONS = 0;
}
TPSSCOPE GETCURRENTSCOPE() {
TPSSCOPE return_GETCURRENTSCOPE;
return_GETCURRENTSCOPE = DEFS.SCOPE;
return return_GETCURRENTSCOPE;
}
void SETCURRENTSCOPE(TPSSCOPE SCOPE) {
DEFS.SCOPE = SCOPE;
}
TPSNAMEINDEX FINDNAME(PString NAME, PBoolean REQUIRED) {
TPSNAMEINDEX return_FINDNAME;
TPSNAMEINDEX POS;
TPSNAMEINDEX RET;
RET = 0;
{
TPSNAMEINDEX first = 1;
TPSNAMEINDEX last = DEFS.SCOPE.NUMNAMES;
if (first <= last) {
POS = first;
while (1) {
if (cmp_ss(NAME, DEFS.NAMES[(POS) - 1].NAME) == 0) RET = POS;
if (POS == last) break;
++POS;
}
}
}
if (REQUIRED && (RET == 0)) {
{
write_s(&STDERR, str_make(20, "Unknown identifier: "));
write_s(&STDERR, NAME);
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
return_FINDNAME = RET;
return return_FINDNAME;
}
TPSNAMEINDEX ADDNAME(TPSNAME DEF, TPSSCOPE SCOPE) {
TPSNAMEINDEX return_ADDNAME;
TPSNAMEINDEX POS;
POS = FINDNAME(DEF.NAME, 0);
if (POS > SCOPE.NUMNAMES) {
{
write_s(&STDERR, str_make(11, "Identifier "));
write_s(&STDERR, DEF.NAME);
write_s(&STDERR, str_make(16, " already defined"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
POS = DEFS.SCOPE.NUMNAMES + 1;
if (POS > 1024) {
{
write_s(&STDERR, str_make(38, "Too many identifiers have been defined"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
DEFS.NAMES[(POS) - 1] = DEF;
DEFS.SCOPE.NUMNAMES = POS;
return_ADDNAME = POS;
return return_ADDNAME;
}
TPSNAME MAKENAME(PString NAME, TPSNAMECLASS CLS, int IDX) {
TPSNAME return_MAKENAME;
TPSNAME DEF;
DEF.NAME = NAME;
DEF.CLS = CLS;
if (CLS == TNCTYPE) DEF.TYPEINDEX = IDX;
 else if (CLS == TNCVARIABLE) DEF.VARIABLEINDEX = IDX;
 else if (CLS == TNCENUMVALUE) DEF.TYPEINDEX = IDX;
 else if (CLS == TNCFUNCTION) DEF.FUNCTIONINDEX = IDX;
 else {
{
write_s(&STDERR, str_make(41, "Cannot use MakeName for special functions"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
return_MAKENAME = DEF;
return return_MAKENAME;
}
TPSNAME MAKESPECIALFUNCTIONNAME(PString NAME, TPSSPECIALFUNCTION FN) {
TPSNAME return_MAKESPECIALFUNCTIONNAME;
TPSNAME DEF;
DEF.NAME = NAME;
DEF.CLS = TNCSPECIALFUNCTION;
DEF.SPECIALFUNCTION = FN;
return_MAKESPECIALFUNCTIONNAME = DEF;
return return_MAKESPECIALFUNCTIONNAME;
}
PString DEEPTYPENAME(TPSTYPEINDEX TYPEINDEX, PBoolean USEORIGINAL) {
PString return_DEEPTYPENAME;
TPSTYPE TYP;
PString RET;
int POS;
do {
TYP = DEFS.TYPES[(TYPEINDEX) - 1];
TYPEINDEX = TYP.ALIASFOR;
} while (!(!USEORIGINAL || (TYPEINDEX == 0)));
if (cmp_ss(TYP.NAME, str_make(0, "")) != 0) return_DEEPTYPENAME = TYP.NAME;
 else if (TYP.CLS == TTCENUM) {
RET = str_of('(');
{
int first = 1;
int last = DEFS.ENUMS[(TYP.ENUMINDEX) - 1].SIZE;
if (first <= last) {
POS = first;
while (1) {
{
if (POS != 1) RET = cat_sc(RET, ',');
RET = cat_ss(RET, DEFS.ENUMS[(TYP.ENUMINDEX) - 1].VALUES[(POS) - 1]);
}
if (POS == last) break;
++POS;
}
}
}
return_DEEPTYPENAME = cat_sc(RET, ')');
}
 else if (TYP.CLS == TTCRECORD) {
RET = str_make(7, "record ");
{
int first = 1;
int last = DEFS.RECORDS[(TYP.RECORDINDEX) - 1].SIZE;
if (first <= last) {
POS = first;
while (1) {
{
if (POS != 1) RET = cat_sc(RET, ',');
RET = cat_ss(RET, DEEPTYPENAME(DEFS.RECORDS[(TYP.RECORDINDEX) - 1].FIELDS[(POS) - 1].TYPEINDEX, 1));
RET = cat_ss(cat_sc(RET, ':'), DEFS.RECORDS[(TYP.RECORDINDEX) - 1].FIELDS[(POS) - 1].NAME);
}
if (POS == last) break;
++POS;
}
}
}
return_DEEPTYPENAME = cat_ss(RET, str_make(4, " end"));
}
 else if (TYP.CLS == TTCARRAY) {
RET = cat_ss(str_make(7, "array ["), DEFS.ARRAYS[(TYP.ARRAYINDEX) - 1].LOWBOUND);
RET = cat_ss(cat_ss(RET, str_make(2, "..")), DEFS.ARRAYS[(TYP.ARRAYINDEX) - 1].HIGHBOUND);
RET = cat_ss(cat_ss(RET, str_make(5, "] of ")), DEEPTYPENAME(DEFS.ARRAYS[(TYP.ARRAYINDEX) - 1].TYPEINDEX, 1));
return_DEEPTYPENAME = RET;
}
 else if (TYP.CLS == TTCPOINTER) return_DEEPTYPENAME = cat_cs('^', DEEPTYPENAME(TYP.POINTEDTYPEINDEX, 1));
 else {
{
write_s(&STDERR, str_make(37, "Could not get name for type of class "));
write_e(&STDERR, TYP.CLS, EnumValues2);
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
return return_DEEPTYPENAME;
}
PString TYPENAME(TPSTYPEINDEX TYPEINDEX) {
PString return_TYPENAME;
return_TYPENAME = DEEPTYPENAME(TYPEINDEX, 0);
return return_TYPENAME;
}
TPSTYPE EMPTYTYPE() {
TPSTYPE return_EMPTYTYPE;
TPSTYPE RET;
RET.NAME = str_make(0, "");
RET.CLS = TTCBOOLEAN;
RET.ENUMINDEX = 0;
RET.RECORDINDEX = 0;
RET.ARRAYINDEX = 0;
RET.POINTEDTYPEINDEX = 0;
RET.ALIASFOR = 0;
return_EMPTYTYPE = RET;
return return_EMPTYTYPE;
}
TPSTYPE TYPEOFCLASS(TPSTYPECLASS CLS) {
TPSTYPE return_TYPEOFCLASS;
TPSTYPE RET;
RET = EMPTYTYPE();
RET.CLS = CLS;
return_TYPEOFCLASS = RET;
return return_TYPEOFCLASS;
}
PBoolean TYPEHASCLASS(TPSTYPEINDEX TYPEINDEX, TPSTYPECLASS CLS) {
PBoolean return_TYPEHASCLASS;
return_TYPEHASCLASS = DEFS.TYPES[(TYPEINDEX) - 1].CLS == CLS;
return return_TYPEHASCLASS;
}
TPSTYPE INTEGERTYPE() {
TPSTYPE return_INTEGERTYPE;
return_INTEGERTYPE = TYPEOFCLASS(TTCINTEGER);
return return_INTEGERTYPE;
}
PBoolean ISINTEGERTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISINTEGERTYPE;
return_ISINTEGERTYPE = TYPEHASCLASS(TYPEINDEX, TTCINTEGER);
return return_ISINTEGERTYPE;
}
TPSTYPE STRINGTYPE() {
TPSTYPE return_STRINGTYPE;
return_STRINGTYPE = TYPEOFCLASS(TTCSTRING);
return return_STRINGTYPE;
}
TPSTYPE CHARTYPE() {
TPSTYPE return_CHARTYPE;
return_CHARTYPE = TYPEOFCLASS(TTCCHAR);
return return_CHARTYPE;
}
PBoolean ISSTRINGTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISSTRINGTYPE;
return_ISSTRINGTYPE = TYPEHASCLASS(TYPEINDEX, TTCSTRING);
return return_ISSTRINGTYPE;
}
PBoolean ISCHARTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISCHARTYPE;
return_ISCHARTYPE = TYPEHASCLASS(TYPEINDEX, TTCCHAR);
return return_ISCHARTYPE;
}
PBoolean ISSTRINGYTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISSTRINGYTYPE;
return_ISSTRINGYTYPE = ISSTRINGTYPE(TYPEINDEX) || ISCHARTYPE(TYPEINDEX);
return return_ISSTRINGYTYPE;
}
TPSTYPE BOOLEANTYPE() {
TPSTYPE return_BOOLEANTYPE;
return_BOOLEANTYPE = TYPEOFCLASS(TTCBOOLEAN);
return return_BOOLEANTYPE;
}
PBoolean ISBOOLEANTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISBOOLEANTYPE;
return_ISBOOLEANTYPE = TYPEHASCLASS(TYPEINDEX, TTCBOOLEAN);
return return_ISBOOLEANTYPE;
}
TPSTYPE TEXTTYPE() {
TPSTYPE return_TEXTTYPE;
return_TEXTTYPE = TYPEOFCLASS(TTCTEXT);
return return_TEXTTYPE;
}
PBoolean ISTEXTTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISTEXTTYPE;
return_ISTEXTTYPE = TYPEHASCLASS(TYPEINDEX, TTCTEXT);
return return_ISTEXTTYPE;
}
PBoolean ISENUMTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISENUMTYPE;
return_ISENUMTYPE = TYPEHASCLASS(TYPEINDEX, TTCENUM);
return return_ISENUMTYPE;
}
PBoolean ISRECORDTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISRECORDTYPE;
return_ISRECORDTYPE = TYPEHASCLASS(TYPEINDEX, TTCRECORD);
return return_ISRECORDTYPE;
}
PBoolean ISARRAYTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISARRAYTYPE;
return_ISARRAYTYPE = TYPEHASCLASS(TYPEINDEX, TTCARRAY);
return return_ISARRAYTYPE;
}
TPSTYPE POINTERTYPE(TPSTYPEINDEX TYPEINDEX) {
TPSTYPE return_POINTERTYPE;
TPSTYPE TYP;
TYP = TYPEOFCLASS(TTCPOINTER);
TYP.POINTEDTYPEINDEX = TYPEINDEX;
return_POINTERTYPE = TYP;
return return_POINTERTYPE;
}
PBoolean ISPOINTERTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISPOINTERTYPE;
return_ISPOINTERTYPE = TYPEHASCLASS(TYPEINDEX, TTCPOINTER);
return return_ISPOINTERTYPE;
}
TPSTYPE NILTYPE() {
TPSTYPE return_NILTYPE;
return_NILTYPE = TYPEOFCLASS(TTCNIL);
return return_NILTYPE;
}
PBoolean ISNILTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISNILTYPE;
return_ISNILTYPE = TYPEHASCLASS(TYPEINDEX, TTCNIL);
return return_ISNILTYPE;
}
PBoolean ISPOINTERYTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISPOINTERYTYPE;
return_ISPOINTERYTYPE = ISPOINTERTYPE(TYPEINDEX) || ISNILTYPE(TYPEINDEX);
return return_ISPOINTERYTYPE;
}
TPSTYPE PLACEHOLDERTYPE() {
TPSTYPE return_PLACEHOLDERTYPE;
return_PLACEHOLDERTYPE = TYPEOFCLASS(TTCPLACEHOLDER);
return return_PLACEHOLDERTYPE;
}
PBoolean ISPLACEHOLDERTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISPLACEHOLDERTYPE;
return_ISPLACEHOLDERTYPE = TYPEHASCLASS(TYPEINDEX, TTCPLACEHOLDER);
return return_ISPLACEHOLDERTYPE;
}
PBoolean ISORDINALTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISORDINALTYPE;
return_ISORDINALTYPE = ISBOOLEANTYPE(TYPEINDEX) || ISINTEGERTYPE(TYPEINDEX) || ISCHARTYPE(TYPEINDEX) || ISENUMTYPE(TYPEINDEX);
return return_ISORDINALTYPE;
}
PBoolean ISSIMPLETYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISSIMPLETYPE;
return_ISSIMPLETYPE = ISORDINALTYPE(TYPEINDEX) || ISSTRINGTYPE(TYPEINDEX);
return return_ISSIMPLETYPE;
}
PBoolean ISSAMETYPE(TPSTYPEINDEX AINDEX, TPSTYPEINDEX BINDEX) {
PBoolean return_ISSAMETYPE;
TPSTYPE A;
TPSTYPE B;
A = DEFS.TYPES[(AINDEX) - 1];
B = DEFS.TYPES[(BINDEX) - 1];
return_ISSAMETYPE = (A.CLS == B.CLS) && (A.ENUMINDEX == B.ENUMINDEX) && (A.RECORDINDEX == B.RECORDINDEX) && (A.ARRAYINDEX == B.ARRAYINDEX) && (A.POINTEDTYPEINDEX == B.POINTEDTYPEINDEX);
return return_ISSAMETYPE;
}
PBoolean AREPOINTERSCOMPATIBLE(TPSTYPEINDEX AINDEX, TPSTYPEINDEX BINDEX) {
PBoolean return_AREPOINTERSCOMPATIBLE;
return_AREPOINTERSCOMPATIBLE = ISPOINTERYTYPE(AINDEX) && ISPOINTERYTYPE(BINDEX) && (ISNILTYPE(AINDEX) || ISNILTYPE(BINDEX) || ISSAMETYPE(AINDEX, BINDEX));
return return_AREPOINTERSCOMPATIBLE;
}
TPSTYPEINDEX ADDTYPE(TPSTYPE TYP, TPSSCOPE SCOPE) {
TPSTYPEINDEX return_ADDTYPE;
int POS;
int ENUMPOS;
if (cmp_ss(TYP.NAME, str_make(0, "")) == 0) POS = 0;
 else POS = FINDNAME(TYP.NAME, 0);
if (POS <= SCOPE.NUMNAMES) {
POS = DEFS.SCOPE.NUMTYPES + 1;
if (POS > 128) {
{
write_s(&STDERR, str_make(32, "Too many types have been defined"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
DEFS.SCOPE.NUMTYPES = POS;
if (cmp_ss(TYP.NAME, str_make(0, "")) != 0) ADDNAME(MAKENAME(TYP.NAME, TNCTYPE, POS), SCOPE);
}
 else if ((DEFS.NAMES[(POS) - 1].CLS == TNCTYPE) && ISPLACEHOLDERTYPE(DEFS.NAMES[(POS) - 1].TYPEINDEX)) POS = DEFS.NAMES[(POS) - 1].TYPEINDEX;
 else {
{
write_s(&STDERR, str_make(11, "Identifier "));
write_s(&STDERR, TYP.NAME);
write_s(&STDERR, str_make(16, " already defined"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
DEFS.TYPES[(POS) - 1] = TYP;
return_ADDTYPE = POS;
if ((TYP.CLS == TTCENUM) && (TYP.ALIASFOR == 0)) {
int first = 1;
int last = DEFS.ENUMS[(TYP.ENUMINDEX) - 1].SIZE;
if (first <= last) {
ENUMPOS = first;
while (1) {
ADDNAME(MAKENAME(DEFS.ENUMS[(TYP.ENUMINDEX) - 1].VALUES[(ENUMPOS) - 1], TNCENUMVALUE, POS), SCOPE);
if (ENUMPOS == last) break;
++ENUMPOS;
}
}
}
return return_ADDTYPE;
}
TPSENUMINDEX ADDENUM(TPSENUMDEF ENUM) {
TPSENUMINDEX return_ADDENUM;
DEFS.SCOPE.NUMENUMS = DEFS.SCOPE.NUMENUMS + 1;
if (DEFS.SCOPE.NUMENUMS > 16) {
{
write_s(&STDERR, str_make(32, "Too many enums have been defined"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
DEFS.ENUMS[(DEFS.SCOPE.NUMENUMS) - 1] = ENUM;
return_ADDENUM = DEFS.SCOPE.NUMENUMS;
return return_ADDENUM;
}
TPSRECORDINDEX ADDRECORD(TPSRECORDDEF REC) {
TPSRECORDINDEX return_ADDRECORD;
DEFS.SCOPE.NUMRECORDS = DEFS.SCOPE.NUMRECORDS + 1;
if (DEFS.SCOPE.NUMRECORDS > 32) {
{
write_s(&STDERR, str_make(34, "Too many records have been defined"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
DEFS.RECORDS[(DEFS.SCOPE.NUMRECORDS) - 1] = REC;
return_ADDRECORD = DEFS.SCOPE.NUMRECORDS;
return return_ADDRECORD;
}
TPSARRAYINDEX ADDARRAY(TPSARRAYDEF ARR) {
TPSARRAYINDEX return_ADDARRAY;
DEFS.SCOPE.NUMARRAYS = DEFS.SCOPE.NUMARRAYS + 1;
if (DEFS.SCOPE.NUMARRAYS > 32) {
{
write_s(&STDERR, str_make(33, "Too many arrays have been defined"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
DEFS.ARRAYS[(DEFS.SCOPE.NUMARRAYS) - 1] = ARR;
return_ADDARRAY = DEFS.SCOPE.NUMARRAYS;
return return_ADDARRAY;
}
TPSCONSTANTINDEX FINDCONSTANT(PString NAME) {
TPSCONSTANTINDEX return_FINDCONSTANT;
int POS;
TPSCONSTANTINDEX RET;
RET = 0;
{
int first = 1;
int last = DEFS.SCOPE.NUMCONSTANTS;
if (first <= last) {
POS = first;
while (1) {
if (cmp_ss(NAME, DEFS.CONSTANTS[(POS) - 1].NAME) == 0) RET = POS;
if (POS == last) break;
++POS;
}
}
}
return_FINDCONSTANT = RET;
return return_FINDCONSTANT;
}
TPSCONSTANTINDEX ADDCONSTANT(TPSCONSTANT CONSTANT, TPSSCOPE SCOPE) {
TPSCONSTANTINDEX return_ADDCONSTANT;
int POS;
if (cmp_ss(CONSTANT.NAME, str_make(0, "")) != 0) {
POS = FINDCONSTANT(CONSTANT.NAME);
if (POS > SCOPE.NUMCONSTANTS) {
{
write_s(&STDERR, str_make(9, "Constant "));
write_s(&STDERR, CONSTANT.NAME);
write_s(&STDERR, str_make(16, " already defined"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
}
POS = DEFS.SCOPE.NUMCONSTANTS + 1;
if (POS > 32) {
{
write_s(&STDERR, str_make(36, "Too many constants have been defined"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
DEFS.CONSTANTS[(POS) - 1] = CONSTANT;
DEFS.SCOPE.NUMCONSTANTS = POS;
return_ADDCONSTANT = POS;
return return_ADDCONSTANT;
}
TPSVARIABLEINDEX ADDVARIABLE(TPSVARIABLE VARDEF, TPSSCOPE SCOPE) {
TPSVARIABLEINDEX return_ADDVARIABLE;
int POS;
if (cmp_ss(VARDEF.NAME, str_make(0, "")) != 0) {
POS = FINDNAME(VARDEF.NAME, 0);
if (POS > SCOPE.NUMNAMES) {
{
write_s(&STDERR, str_make(11, "Identifier "));
write_s(&STDERR, VARDEF.NAME);
write_s(&STDERR, str_make(16, " already defined"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
}
POS = DEFS.SCOPE.NUMVARIABLES + 1;
if (POS > 32) {
{
write_s(&STDERR, str_make(36, "Too many variables have been defined"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
DEFS.VARIABLES[(POS) - 1] = VARDEF;
DEFS.SCOPE.NUMVARIABLES = POS;
return_ADDVARIABLE = POS;
if (cmp_ss(VARDEF.NAME, str_make(0, "")) != 0) ADDNAME(MAKENAME(VARDEF.NAME, TNCVARIABLE, POS), SCOPE);
return return_ADDVARIABLE;
}
TPSFUNCTION EMPTYFUNCTION() {
TPSFUNCTION return_EMPTYFUNCTION;
TPSFUNCTION RET;
RET.NAME = str_make(0, "");
RET.ARGCOUNT = 0;
RET.RETURNTYPEINDEX = 0;
RET.ISDECLARATION = 0;
return_EMPTYFUNCTION = RET;
return return_EMPTYFUNCTION;
}
PBoolean ISEMPTYFUNCTION(TPSFUNCTION FN) {
PBoolean return_ISEMPTYFUNCTION;
return_ISEMPTYFUNCTION = cmp_ss(FN.NAME, str_make(0, "")) == 0;
return return_ISEMPTYFUNCTION;
}
PBoolean ISSAMEFUNCTIONDEFINITION(TPSFUNCTIONINDEX DECLINDEX, TPSFUNCTION FUN) {
PBoolean return_ISSAMEFUNCTIONDEFINITION;
TPSFUNCTION DECL;
PBoolean SAME;
int POS;
DECL = DEFS.FUNCTIONS[(DECLINDEX) - 1];
SAME = ISSAMETYPE(DECL.RETURNTYPEINDEX, FUN.RETURNTYPEINDEX) && (DECL.ARGCOUNT == FUN.ARGCOUNT);
{
int first = 1;
int last = DECL.ARGCOUNT;
if (first <= last) {
POS = first;
while (1) {
SAME = SAME && ISSAMETYPE(DECL.ARGS[(POS) - 1].TYPEINDEX, FUN.ARGS[(POS) - 1].TYPEINDEX) && (DECL.ARGS[(POS) - 1].ISREFERENCE == FUN.ARGS[(POS) - 1].ISREFERENCE);
if (POS == last) break;
++POS;
}
}
}
return_ISSAMEFUNCTIONDEFINITION = SAME;
return return_ISSAMEFUNCTIONDEFINITION;
}
PBoolean HASFORWARDDECLARATION(PString NAME) {
PBoolean return_HASFORWARDDECLARATION;
int POS;
POS = FINDNAME(NAME, 0);
return_HASFORWARDDECLARATION = (POS != 0) && (DEFS.NAMES[(POS) - 1].CLS == TNCFUNCTION) && (DEFS.FUNCTIONS[(DEFS.NAMES[(POS) - 1].FUNCTIONINDEX) - 1].ISDECLARATION);
return return_HASFORWARDDECLARATION;
}
TPSFUNCTIONINDEX ADDFUNCTION(TPSFUNCTION FUN) {
TPSFUNCTIONINDEX return_ADDFUNCTION;
int POS;
PBoolean ISNEW;
POS = FINDNAME(FUN.NAME, 0);
if (POS != 0) {
if ((DEFS.NAMES[(POS) - 1].CLS != TNCFUNCTION) || FUN.ISDECLARATION) {
{
write_s(&STDERR, str_make(11, "Identifier "));
write_s(&STDERR, FUN.NAME);
write_s(&STDERR, str_make(16, " already defined"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
ISNEW = 0;
POS = DEFS.NAMES[(POS) - 1].FUNCTIONINDEX;
if (DEFS.FUNCTIONS[(POS) - 1].ISDECLARATION) {
if ((FUN.ARGCOUNT == 0) && (FUN.RETURNTYPEINDEX == 0)) {
FUN = DEFS.FUNCTIONS[(POS) - 1];
FUN.ISDECLARATION = 0;
}
 else if (!ISSAMEFUNCTIONDEFINITION(POS, FUN)) {
if (FUN.RETURNTYPEINDEX == 0) {
write_s(&STDERR, str_make(10, "Procedure "));
write_s(&STDERR, FUN.NAME);
write_s(&STDERR, str_make(42, " incompatible with its forward declaration"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
 else {
write_s(&STDERR, str_make(9, "Function "));
write_s(&STDERR, FUN.NAME);
write_s(&STDERR, str_make(42, " incompatible with its forward declaration"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
}
 else {
if (FUN.RETURNTYPEINDEX == 0) {
write_s(&STDERR, str_make(10, "Procedure "));
write_s(&STDERR, FUN.NAME);
write_s(&STDERR, str_make(16, " already defined"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
 else {
write_s(&STDERR, str_make(9, "Function "));
write_s(&STDERR, FUN.NAME);
write_s(&STDERR, str_make(16, " already defined"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
}
 else {
ISNEW = 1;
POS = DEFS.SCOPE.NUMFUNCTIONS + 1;
if (POS > 256) {
{
write_s(&STDERR, str_make(36, "Too many functions have been defined"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
DEFS.SCOPE.NUMFUNCTIONS = POS;
}
DEFS.FUNCTIONS[(POS) - 1] = FUN;
return_ADDFUNCTION = POS;
if (ISNEW && (cmp_ss(FUN.NAME, str_make(0, "")) != 0)) ADDNAME(MAKENAME(FUN.NAME, TNCFUNCTION, POS), GLOBALSCOPE);
return return_ADDFUNCTION;
}
void ADDSPECIALFUNCTION(PString NAME, TPSSPECIALFUNCTION FN) {
TPSNAME DEF;
DEF.NAME = NAME;
DEF.CLS = TNCSPECIALFUNCTION;
DEF.SPECIALFUNCTION = FN;
ADDNAME(DEF, GLOBALSCOPE);
}
TPSTYPEINDEX FINDFIELDTYPE(TPSTYPEINDEX TYPEINDEX, PString NAME) {
TPSTYPEINDEX return_FINDFIELDTYPE;
TPSTYPE TYP;
TPSRECORDDEF REC;
int POS;
TYP = DEFS.TYPES[(TYPEINDEX) - 1];
if (TYP.CLS != TTCRECORD) {
{
write_s(&STDERR, str_make(14, "Not a record: "));
write_s(&STDERR, TYP.NAME);
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
TYPEINDEX = 0;
REC = DEFS.RECORDS[(TYP.RECORDINDEX) - 1];
{
int first = 1;
int last = REC.SIZE;
if (first <= last) {
POS = first;
while (1) {
if (cmp_ss(REC.FIELDS[(POS) - 1].NAME, NAME) == 0) TYPEINDEX = REC.FIELDS[(POS) - 1].TYPEINDEX;
if (POS == last) break;
++POS;
}
}
}
if (TYPEINDEX == 0) {
{
write_s(&STDERR, str_make(17, "Field not found: "));
write_s(&STDERR, NAME);
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
return_FINDFIELDTYPE = TYPEINDEX;
return return_FINDFIELDTYPE;
}
TPSTYPE MAKETYPE(PString NAME, TPSTYPECLASS CLS) {
TPSTYPE return_MAKETYPE;
TPSTYPE TYP;
TYP = EMPTYTYPE();
TYP.NAME = NAME;
TYP.CLS = CLS;
return_MAKETYPE = TYP;
return return_MAKETYPE;
}
TPSCONSTANT MAKECONSTANT(PString NAME, TLXTOKENID TOKENID, PString TOKENVALUE) {
TPSCONSTANT return_MAKECONSTANT;
TPSCONSTANT CONSTANT;
CONSTANT.NAME = NAME;
CONSTANT.REPLACEMENT.ID = TOKENID;
CONSTANT.REPLACEMENT.VALUE = TOKENVALUE;
return_MAKECONSTANT = CONSTANT;
return return_MAKECONSTANT;
}
TPSVARIABLE MAKETYPEDCONSTANT(PString NAME, TPSTYPEINDEX TYPEINDEX) {
TPSVARIABLE return_MAKETYPEDCONSTANT;
TPSVARIABLE VARDEF;
VARDEF.NAME = NAME;
VARDEF.TYPEINDEX = TYPEINDEX;
VARDEF.ISREFERENCE = 0;
VARDEF.ISCONSTANT = 1;
return_MAKETYPEDCONSTANT = VARDEF;
return return_MAKETYPEDCONSTANT;
}
TPSVARIABLE MAKEVARIABLE(PString NAME, TPSTYPEINDEX TYPEINDEX, PBoolean ISREF) {
TPSVARIABLE return_MAKEVARIABLE;
TPSVARIABLE VARDEF;
VARDEF.NAME = NAME;
VARDEF.TYPEINDEX = TYPEINDEX;
VARDEF.ISREFERENCE = ISREF;
VARDEF.ISCONSTANT = 0;
return_MAKEVARIABLE = VARDEF;
return return_MAKEVARIABLE;
}
typedef enum { TECVALUE, TECFUNCTION, TECSTATEMENT} TPSEXPRESSIONCLASS;
typedef struct { PString VALUE; TPSEXPRESSIONCLASS CLS; PBoolean ISCONSTANT; TPSTYPEINDEX TYPEINDEX; TPSFUNCTIONINDEX FUNCTIONINDEX; } TPSEXPRESSION;
const char* EnumValues6[] = { "TECVALUE", "TECFUNCTION", "TECSTATEMENT" };
void CODEGENRESET();
void CODEGENSETOUTPUT(PString FILENAME);
void OUTBEGIN();
void OUTEND();
void OUTENUMVALUES(TPSENUMINDEX POS);
void OUTENUMVALUESINSCOPE(TPSSCOPE SCOPE);
PString OUTVARIABLENAME(PString NAME, PBoolean ISREFERENCE);
PString OUTRETURNVARIABLENAME(PString NAME);
void OUTNAMEANDTYPE(PString NAME, TPSTYPEINDEX TYPEINDEX);
void OUTTYPEDEFINITION(TPSTYPEINDEX TYPEINDEX);
void OUTCONSTANTVALUE(PString VALUE);
void OUTCONSTANTARRAYBEGIN();
void OUTCONSTANTARRAYSEPARATOR();
void OUTCONSTANTARRAYEND();
void OUTVARIABLEDECLARATION(TPSVARIABLE VARDEF);
void OUTVARIABLEDEFINITION(TPSVARIABLEINDEX VARINDEX);
void OUTCONSTANTDEFINITIONBEGIN(TPSVARIABLEINDEX VARINDEX);
void OUTCONSTANTDEFINITIONEND();
void OUTFUNCTIONPROTOTYPE(TPSFUNCTION DEF);
void OUTFUNCTIONDECLARATION(TPSFUNCTIONINDEX FNINDEX);
void OUTFUNCTIONDEFINITION(TPSFUNCTIONINDEX FNINDEX);
void OUTFUNCTIONEND(TPSFUNCTIONINDEX FNINDEX);
void OUTPROGRAMHEADING(PString NAME);
void SETSTRINGINDEX(TPSEXPRESSION *STR, TPSEXPRESSION IDX);
void SETARRAYINDEX(TPSEXPRESSION *ARR, TPSEXPRESSION IDX);
void SETFIELDACCESS(TPSEXPRESSION *REC, PString FLD);
PString GENFUNCTIONCALLSTART(PString FN);
PString GENFUNCTIONCALLEND(PString FN);
PString GENFUNCTIONCALLARGUMENT(PString FN, TPSEXPRESSION EXPR, PBoolean ISREFERENCE, int ARGNUM);
TPSEXPRESSION GENPARENS(TPSEXPRESSION EXPR);
void OUTREAD(PString SRC, TPSEXPRESSION OUTVAR);
void OUTREADLN(PString SRC);
void OUTWRITE(PString DST, TPSEXPRESSION EXPR);
void OUTWRITELN(PString DST);
void OUTSTR(PString DST, TPSEXPRESSION EXPR);
void OUTNEW(TPSEXPRESSION DST);
void OUTDISPOSE(TPSEXPRESSION DST);
void OUTEXPRESSION(TPSEXPRESSION EXPR);
void OUTASSIGN(TPSEXPRESSION LHS, TPSEXPRESSION RHS);
void OUTASSIGNRETURNVALUE(TPSEXPRESSION LHS, TPSEXPRESSION RHS);
void OUTIF(TPSEXPRESSION EXPR);
void OUTELSE();
void OUTREPEATBEGIN();
void OUTREPEATEND(TPSEXPRESSION EXPR);
void OUTWHILEBEGIN(TPSEXPRESSION EXPR);
void OUTWHILEEND();
void OUTFORBEGIN(TPSEXPRESSION ITER, TPSEXPRESSION FIRSTEXPR, TPSEXPRESSION LASTEXPR, PBoolean ASCENDING);
void OUTFOREND(TPSEXPRESSION ITER, PBoolean ASCENDING);
void OUTPROCEDURECALL(TPSEXPRESSION EXPR);
void OUTEMPTYSTATEMENT();
void OUTPROGRAMBEGIN();
void OUTPROGRAMEND();
TPSEXPRESSION EVALUATE(TPSEXPRESSION EXPR) {
TPSEXPRESSION return_EVALUATE;
if (EXPR.CLS == TECFUNCTION) {
if (DEFS.FUNCTIONS[(EXPR.FUNCTIONINDEX) - 1].ARGCOUNT != 0) {
{
write_s(&STDERR, str_make(27, "Function requires arguments"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
EXPR.VALUE = cat_ss(EXPR.VALUE, str_make(2, "()"));
EXPR.TYPEINDEX = DEFS.FUNCTIONS[(EXPR.FUNCTIONINDEX) - 1].RETURNTYPEINDEX;
if (EXPR.TYPEINDEX == 0) EXPR.CLS = TECSTATEMENT;
 else EXPR.CLS = TECVALUE;
}
return_EVALUATE = EXPR;
return return_EVALUATE;
}
TPSEXPRESSION COERCETYPE(TPSEXPRESSION EXPR, TPSTYPEINDEX TYPEINDEX) {
TPSEXPRESSION return_COERCETYPE;
EXPR = EVALUATE(EXPR);
if (EXPR.CLS != TECVALUE) {
{
write_s(&STDERR, str_make(26, "Cannot assign function to "));
write_s(&STDERR, TYPENAME(TYPEINDEX));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
if (ISCHARTYPE(EXPR.TYPEINDEX) && ISSTRINGTYPE(TYPEINDEX)) {
EXPR.TYPEINDEX = PRIMITIVETYPES.PTSTRING;
EXPR.VALUE = cat_sc(cat_ss(str_make(7, "str_of("), EXPR.VALUE), ')');
}
 else if (ISNILTYPE(EXPR.TYPEINDEX) && ISPOINTERTYPE(TYPEINDEX)) EXPR.TYPEINDEX = TYPEINDEX;
 else if (!ISSAMETYPE(EXPR.TYPEINDEX, TYPEINDEX)) {
{
write_s(&STDERR, str_make(14, "Cannot assign "));
write_s(&STDERR, TYPENAME(EXPR.TYPEINDEX));
write_s(&STDERR, str_make(4, " to "));
write_s(&STDERR, TYPENAME(TYPEINDEX));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
return_COERCETYPE = EXPR;
return return_COERCETYPE;
}
PBoolean ISVARIABLEEXPRESSION(TPSEXPRESSION EXPR) {
PBoolean return_ISVARIABLEEXPRESSION;
return_ISVARIABLEEXPRESSION = (EXPR.CLS == TECVALUE) && (EXPR.TYPEINDEX != 0) && !EXPR.ISCONSTANT;
return return_ISVARIABLEEXPRESSION;
}
TPSEXPRESSION GENNILCONSTANT() {
TPSEXPRESSION return_GENNILCONSTANT;
TPSEXPRESSION EXPR;
EXPR.TYPEINDEX = PRIMITIVETYPES.PTNIL;
EXPR.CLS = TECVALUE;
EXPR.ISCONSTANT = 1;
EXPR.VALUE = str_make(10, "((void*)0)");
return_GENNILCONSTANT = EXPR;
return return_GENNILCONSTANT;
}
TPSEXPRESSION GENBOOLEANCONSTANT(PBoolean VALUE) {
TPSEXPRESSION return_GENBOOLEANCONSTANT;
TPSEXPRESSION EXPR;
EXPR.TYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
EXPR.CLS = TECVALUE;
EXPR.ISCONSTANT = 1;
if (VALUE) EXPR.VALUE = str_of('1');
 else EXPR.VALUE = str_of('0');
return_GENBOOLEANCONSTANT = EXPR;
return return_GENBOOLEANCONSTANT;
}
TPSEXPRESSION GENSTRINGCONSTANT(PString VALUE) {
TPSEXPRESSION return_GENSTRINGCONSTANT;
TPSEXPRESSION EXPR;
PString SIZE;
int POS;
PBoolean INSTR;
PBoolean LASTQUOTE;
int LEN;
INSTR = 0;
LASTQUOTE = 0;
EXPR.VALUE = str_make(0, "");
EXPR.CLS = TECVALUE;
EXPR.ISCONSTANT = 1;
LEN = 0;
{
int first = 1;
int last = LENGTH(VALUE);
if (first <= last) {
POS = first;
while (1) {
{
if (cmp_cc(VALUE.chr[POS], '\'') == 0) {
INSTR = !INSTR;
if (INSTR && LASTQUOTE) {
EXPR.VALUE = cat_ss(EXPR.VALUE, str_make(2, "\\\'"));
LEN = LEN + 1;
}
 else LASTQUOTE = !INSTR;
}
 else {
LASTQUOTE = 0;
if (cmp_cc(VALUE.chr[POS], '\"') == 0) EXPR.VALUE = cat_ss(EXPR.VALUE, str_make(2, "\\\""));
 else if (cmp_cc(VALUE.chr[POS], '\\') == 0) EXPR.VALUE = cat_ss(EXPR.VALUE, str_make(2, "\\\\"));
 else EXPR.VALUE = cat_sc(EXPR.VALUE, VALUE.chr[POS]);
LEN = LEN + 1;
}
}
if (POS == last) break;
++POS;
}
}
}
if (LEN == 1) {
EXPR.VALUE = cat_sc(cat_cs('\'', EXPR.VALUE), '\'');
EXPR.TYPEINDEX = PRIMITIVETYPES.PTCHAR;
}
 else {
SIZE = to_str_i(LEN);
EXPR.VALUE = cat_ss(cat_ss(cat_ss(cat_ss(str_make(9, "str_make("), SIZE), str_make(3, ", \"")), EXPR.VALUE), str_make(2, "\")"));
EXPR.TYPEINDEX = PRIMITIVETYPES.PTSTRING;
}
return_GENSTRINGCONSTANT = EXPR;
return return_GENSTRINGCONSTANT;
}
TPSEXPRESSION GENNUMBERCONSTANT(PString VALUE) {
TPSEXPRESSION return_GENNUMBERCONSTANT;
TPSEXPRESSION EXPR;
EXPR.TYPEINDEX = PRIMITIVETYPES.PTINTEGER;
EXPR.VALUE = VALUE;
EXPR.CLS = TECVALUE;
EXPR.ISCONSTANT = 1;
return_GENNUMBERCONSTANT = EXPR;
return return_GENNUMBERCONSTANT;
}
char SHORTTYPENAME(TPSTYPEINDEX TYPEINDEX) {
char return_SHORTTYPENAME;
if (ISBOOLEANTYPE(TYPEINDEX)) return_SHORTTYPENAME = 'b';
 else if (ISINTEGERTYPE(TYPEINDEX)) return_SHORTTYPENAME = 'i';
 else if (ISCHARTYPE(TYPEINDEX)) return_SHORTTYPENAME = 'c';
 else if (ISSTRINGTYPE(TYPEINDEX)) return_SHORTTYPENAME = 's';
 else if (ISENUMTYPE(TYPEINDEX)) return_SHORTTYPENAME = 'e';
 else {
{
write_s(&STDERR, str_make(30, "No short type name exists for "));
write_s(&STDERR, TYPENAME(TYPEINDEX));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
return return_SHORTTYPENAME;
}
TPSEXPRESSION INTEGERBINARYEXPRESSION(TPSEXPRESSION LEFT, TLXTOKENID OP, TPSEXPRESSION RIGHT) {
TPSEXPRESSION return_INTEGERBINARYEXPRESSION;
PString OPER;
PString CMP;
TPSEXPRESSION EXPR;
OPER = str_make(0, "");
CMP = str_make(0, "");
if (OP == TKPLUS) OPER = str_of('+');
 else if (OP == TKMINUS) OPER = str_of('-');
 else if (OP == TKASTERISK) OPER = str_of('*');
 else if (OP == TKDIV) OPER = str_of('/');
 else if (OP == TKMOD) OPER = str_of('%');
 else if (OP == TKAND) OPER = str_of('&');
 else if (OP == TKOR) OPER = str_of('|');
 else if (OP == TKEQUALS) CMP = str_make(2, "==");
 else if (OP == TKNOTEQUALS) CMP = str_make(2, "!=");
 else if (OP == TKLESSTHAN) CMP = str_of('<');
 else if (OP == TKMORETHAN) CMP = str_of('>');
 else if (OP == TKLESSOREQUALS) CMP = str_make(2, "<=");
 else if (OP == TKMOREOREQUALS) CMP = str_make(2, ">=");
 else {
{
write_s(&STDERR, str_make(40, "Expected integer binary operator, found "));
write_e(&STDERR, OP, EnumValues1);
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
if (cmp_ss(CMP, str_make(0, "")) == 0) EXPR.TYPEINDEX = PRIMITIVETYPES.PTINTEGER;
 else EXPR.TYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
EXPR.VALUE = cat_ss(cat_sc(cat_ss(cat_ss(cat_sc(LEFT.VALUE, ' '), OPER), CMP), ' '), RIGHT.VALUE);
EXPR.CLS = TECVALUE;
EXPR.ISCONSTANT = 1;
return_INTEGERBINARYEXPRESSION = EXPR;
return return_INTEGERBINARYEXPRESSION;
}
TPSEXPRESSION BOOLEANBINARYEXPRESSION(TPSEXPRESSION LEFT, TLXTOKENID OP, TPSEXPRESSION RIGHT) {
TPSEXPRESSION return_BOOLEANBINARYEXPRESSION;
PString OPER;
TPSEXPRESSION EXPR;
if (OP == TKAND) OPER = str_make(2, "&&");
 else if (OP == TKOR) OPER = str_make(2, "||");
 else if (OP == TKEQUALS) OPER = str_make(2, "==");
 else if (OP == TKNOTEQUALS) OPER = str_make(2, "!=");
 else if (OP == TKLESSTHAN) OPER = str_of('<');
 else if (OP == TKMORETHAN) OPER = str_of('>');
 else if (OP == TKLESSOREQUALS) OPER = str_make(2, "<=");
 else if (OP == TKMOREOREQUALS) OPER = str_make(2, ">=");
 else {
{
write_s(&STDERR, str_make(40, "Expected boolean binary operator, found "));
write_e(&STDERR, OP, EnumValues1);
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
EXPR.TYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
EXPR.VALUE = cat_ss(cat_sc(cat_ss(cat_sc(LEFT.VALUE, ' '), OPER), ' '), RIGHT.VALUE);
EXPR.CLS = TECVALUE;
EXPR.ISCONSTANT = 1;
return_BOOLEANBINARYEXPRESSION = EXPR;
return return_BOOLEANBINARYEXPRESSION;
}
TPSEXPRESSION STRINGYBINARYEXPRESSION(TPSEXPRESSION LEFT, TLXTOKENID OP, TPSEXPRESSION RIGHT) {
TPSEXPRESSION return_STRINGYBINARYEXPRESSION;
PString FNAME;
PString CMP;
TPSEXPRESSION EXPR;
FNAME = str_make(3, "cmp");
CMP = str_make(0, "");
if (OP == TKPLUS) FNAME = str_make(3, "cat");
 else if (OP == TKEQUALS) CMP = str_make(2, "==");
 else if (OP == TKNOTEQUALS) CMP = str_make(2, "!=");
 else if (OP == TKLESSTHAN) CMP = str_of('<');
 else if (OP == TKMORETHAN) CMP = str_of('>');
 else if (OP == TKLESSOREQUALS) CMP = str_make(2, "<=");
 else if (OP == TKMOREOREQUALS) CMP = str_make(2, ">=");
 else {
{
write_s(&STDERR, str_make(39, "Expected string binary operator, found "));
write_e(&STDERR, OP, EnumValues1);
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
FNAME = cat_sc(cat_sc(cat_sc(FNAME, '_'), SHORTTYPENAME(LEFT.TYPEINDEX)), SHORTTYPENAME(RIGHT.TYPEINDEX));
EXPR.TYPEINDEX = PRIMITIVETYPES.PTSTRING;
EXPR.VALUE = cat_sc(cat_ss(cat_ss(cat_ss(cat_sc(FNAME, '('), LEFT.VALUE), str_make(2, ", ")), RIGHT.VALUE), ')');
if (cmp_ss(CMP, str_make(0, "")) != 0) {
EXPR.TYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
EXPR.VALUE = cat_ss(cat_ss(cat_sc(EXPR.VALUE, ' '), CMP), str_make(2, " 0"));
}
EXPR.CLS = TECVALUE;
EXPR.ISCONSTANT = 1;
return_STRINGYBINARYEXPRESSION = EXPR;
return return_STRINGYBINARYEXPRESSION;
}
TPSEXPRESSION ENUMBINARYEXPRESSION(TPSEXPRESSION LEFT, TLXTOKENID OP, TPSEXPRESSION RIGHT) {
TPSEXPRESSION return_ENUMBINARYEXPRESSION;
PString CMP;
TPSEXPRESSION EXPR;
CMP = str_make(0, "");
if (OP == TKEQUALS) CMP = str_make(2, "==");
 else if (OP == TKNOTEQUALS) CMP = str_make(2, "!=");
 else if (OP == TKLESSTHAN) CMP = str_of('<');
 else if (OP == TKMORETHAN) CMP = str_of('>');
 else if (OP == TKLESSOREQUALS) CMP = str_make(2, "<=");
 else if (OP == TKMOREOREQUALS) CMP = str_make(2, ">=");
 else {
{
write_s(&STDERR, str_make(40, "Expected ordinal binary operator, found "));
write_e(&STDERR, OP, EnumValues1);
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
EXPR.TYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
EXPR.VALUE = cat_ss(cat_sc(cat_ss(cat_sc(LEFT.VALUE, ' '), CMP), ' '), RIGHT.VALUE);
EXPR.CLS = TECVALUE;
EXPR.ISCONSTANT = 1;
return_ENUMBINARYEXPRESSION = EXPR;
return return_ENUMBINARYEXPRESSION;
}
TPSEXPRESSION POINTERBINARYEXPRESSION(TPSEXPRESSION LEFT, TLXTOKENID OP, TPSEXPRESSION RIGHT) {
TPSEXPRESSION return_POINTERBINARYEXPRESSION;
PString CMP;
TPSEXPRESSION EXPR;
CMP = str_make(0, "");
if (OP == TKEQUALS) CMP = str_make(2, "==");
 else if (OP == TKNOTEQUALS) CMP = str_make(2, "!=");
 else {
{
write_s(&STDERR, str_make(40, "Expected pointer binary operator, found "));
write_e(&STDERR, OP, EnumValues1);
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
EXPR.TYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
EXPR.VALUE = cat_ss(cat_sc(cat_ss(cat_sc(LEFT.VALUE, ' '), CMP), ' '), RIGHT.VALUE);
EXPR.CLS = TECVALUE;
EXPR.ISCONSTANT = 1;
return_POINTERBINARYEXPRESSION = EXPR;
return return_POINTERBINARYEXPRESSION;
}
TPSEXPRESSION BINARYEXPRESSION(TPSEXPRESSION LEFT, TLXTOKENID OP, TPSEXPRESSION RIGHT) {
TPSEXPRESSION return_BINARYEXPRESSION;
LEFT = EVALUATE(LEFT);
RIGHT = EVALUATE(RIGHT);
if (ISBOOLEANTYPE(LEFT.TYPEINDEX) && ISBOOLEANTYPE(RIGHT.TYPEINDEX)) return_BINARYEXPRESSION = BOOLEANBINARYEXPRESSION(LEFT, OP, RIGHT);
 else if (ISINTEGERTYPE(LEFT.TYPEINDEX) && ISINTEGERTYPE(RIGHT.TYPEINDEX)) return_BINARYEXPRESSION = INTEGERBINARYEXPRESSION(LEFT, OP, RIGHT);
 else if (ISSTRINGYTYPE(LEFT.TYPEINDEX) && ISSTRINGYTYPE(RIGHT.TYPEINDEX)) return_BINARYEXPRESSION = STRINGYBINARYEXPRESSION(LEFT, OP, RIGHT);
 else if (ISENUMTYPE(LEFT.TYPEINDEX) && ISSAMETYPE(LEFT.TYPEINDEX, RIGHT.TYPEINDEX)) return_BINARYEXPRESSION = ENUMBINARYEXPRESSION(LEFT, OP, RIGHT);
 else if (AREPOINTERSCOMPATIBLE(LEFT.TYPEINDEX, RIGHT.TYPEINDEX)) return_BINARYEXPRESSION = POINTERBINARYEXPRESSION(LEFT, OP, RIGHT);
 else {
{
write_s(&STDERR, str_make(27, "Type mismatch for operator "));
write_e(&STDERR, OP, EnumValues1);
write_s(&STDERR, str_make(2, ": "));
write_s(&STDERR, TYPENAME(LEFT.TYPEINDEX));
write_s(&STDERR, str_make(5, " and "));
write_s(&STDERR, TYPENAME(RIGHT.TYPEINDEX));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
return return_BINARYEXPRESSION;
}
TPSEXPRESSION UNARYEXPRESSION(TLXTOKENID OP, TPSEXPRESSION EXPR) {
TPSEXPRESSION return_UNARYEXPRESSION;
EXPR = EVALUATE(EXPR);
if (OP == TKNOT) {
if (!ISBOOLEANTYPE(EXPR.TYPEINDEX)) {
{
write_s(&STDERR, str_make(33, "Expected boolean expression, got "));
write_s(&STDERR, TYPENAME(EXPR.TYPEINDEX));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
EXPR.VALUE = cat_cs('!', EXPR.VALUE);
}
 else if (OP == TKMINUS) {
if (!ISINTEGERTYPE(EXPR.TYPEINDEX)) {
{
write_s(&STDERR, str_make(33, "Expected numeric expression, got "));
write_s(&STDERR, TYPENAME(EXPR.TYPEINDEX));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
EXPR.VALUE = cat_cs('-', EXPR.VALUE);
}
 else {
{
write_s(&STDERR, str_make(31, "Expected unary operator, found "));
write_e(&STDERR, OP, EnumValues1);
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
EXPR.ISCONSTANT = 1;
return_UNARYEXPRESSION = EXPR;
return return_UNARYEXPRESSION;
}
void READTOKEN();
void WANTTOKEN(TLXTOKENID ID) {
if (LEXER.TOKEN.ID != ID) {
{
write_s(&STDERR, str_make(13, "Wanted token "));
write_e(&STDERR, ID, EnumValues1);
write_s(&STDERR, str_make(8, ", found "));
write_s(&STDERR, LXTOKENSTR());
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
}
void WANTTOKEN2(TLXTOKENID ID1, TLXTOKENID ID2) {
if ((LEXER.TOKEN.ID != ID1) && (LEXER.TOKEN.ID != ID2)) {
{
write_s(&STDERR, str_make(13, "Wanted token "));
write_e(&STDERR, ID1, EnumValues1);
write_s(&STDERR, str_make(4, " or "));
write_e(&STDERR, ID2, EnumValues1);
write_s(&STDERR, str_make(8, ", found "));
write_s(&STDERR, LXTOKENSTR());
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
}
void WANTTOKENANDREAD(TLXTOKENID ID) {
WANTTOKEN(ID);
READTOKEN();
}
PString GETTOKENVALUEANDREAD(TLXTOKENID ID) {
PString return_GETTOKENVALUEANDREAD;
WANTTOKEN(ID);
return_GETTOKENVALUEANDREAD = LEXER.TOKEN.VALUE;
READTOKEN();
return return_GETTOKENVALUEANDREAD;
}
void SKIPTOKEN(TLXTOKENID ID) {
if (LEXER.TOKEN.ID == ID) READTOKEN();
}
TPSTYPEINDEX PSTYPEDENOTER(TPSSCOPE SCOPE);
TPSTYPEINDEX PSTYPEIDENTIFIER() {
TPSTYPEINDEX return_PSTYPEIDENTIFIER;
TPSNAME FOUND;
TPSTYPEINDEX TYPEINDEX;
WANTTOKEN(TKIDENTIFIER);
TYPEINDEX = 0;
FOUND = DEFS.NAMES[(FINDNAME(LEXER.TOKEN.VALUE, 1)) - 1];
if (FOUND.CLS != TNCTYPE) {
{
write_s(&STDERR, str_make(12, "Not a type: "));
write_s(&STDERR, FOUND.NAME);
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
return_PSTYPEIDENTIFIER = FOUND.TYPEINDEX;
READTOKEN();
return return_PSTYPEIDENTIFIER;
}
TPSTYPEINDEX PSENUMERATEDTYPE(TPSSCOPE SCOPE) {
TPSTYPEINDEX return_PSENUMERATEDTYPE;
TPSTYPE TYP;
TPSENUMDEF ENUM;
WANTTOKENANDREAD(TKLPAREN);
ENUM.SIZE = 0;
do {
ENUM.SIZE = ENUM.SIZE + 1;
if (ENUM.SIZE > 128) {
{
write_s(&STDERR, str_make(23, "Too many values in enum"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
ENUM.VALUES[(ENUM.SIZE) - 1] = GETTOKENVALUEANDREAD(TKIDENTIFIER);
WANTTOKEN2(TKCOMMA, TKRPAREN);
SKIPTOKEN(TKCOMMA);
} while (!(LEXER.TOKEN.ID == TKRPAREN));
TYP = EMPTYTYPE();
TYP.CLS = TTCENUM;
TYP.ENUMINDEX = ADDENUM(ENUM);
return_PSENUMERATEDTYPE = ADDTYPE(TYP, SCOPE);
SKIPTOKEN(TKRPAREN);
return return_PSENUMERATEDTYPE;
}
TPSTYPEINDEX PSRECORDTYPE(TPSSCOPE SCOPE) {
TPSTYPEINDEX return_PSRECORDTYPE;
TPSTYPE TYP;
TPSRECORDDEF REC;
WANTTOKENANDREAD(TKRECORD);
REC.SIZE = 0;
do {
REC.SIZE = REC.SIZE + 1;
if (REC.SIZE > 16) {
{
write_s(&STDERR, str_make(25, "Too many fields in record"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
REC.FIELDS[(REC.SIZE) - 1].NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
WANTTOKENANDREAD(TKCOLON);
REC.FIELDS[(REC.SIZE) - 1].TYPEINDEX = PSTYPEDENOTER(SCOPE);
WANTTOKEN2(TKSEMICOLON, TKEND);
SKIPTOKEN(TKSEMICOLON);
} while (!(LEXER.TOKEN.ID == TKEND));
TYP = TYPEOFCLASS(TTCRECORD);
TYP.RECORDINDEX = ADDRECORD(REC);
return_PSRECORDTYPE = ADDTYPE(TYP, SCOPE);
SKIPTOKEN(TKEND);
return return_PSRECORDTYPE;
}
TPSTYPEINDEX PSARRAYTYPE(TPSSCOPE SCOPE) {
TPSTYPEINDEX return_PSARRAYTYPE;
TPSNAME FOUND;
TPSTYPEINDEX TYPEINDEX;
TPSTYPE TYP;
TPSENUMDEF ENUM;
TPSRECORDDEF REC;
TPSARRAYDEF ARR;
WANTTOKENANDREAD(TKARRAY);
WANTTOKENANDREAD(TKLBRACKET);
ARR.LOWBOUND = GETTOKENVALUEANDREAD(TKNUMBER);
WANTTOKENANDREAD(TKRANGE);
ARR.HIGHBOUND = GETTOKENVALUEANDREAD(TKNUMBER);
WANTTOKENANDREAD(TKRBRACKET);
WANTTOKENANDREAD(TKOF);
ARR.TYPEINDEX = PSTYPEDENOTER(SCOPE);
TYP = TYPEOFCLASS(TTCARRAY);
TYP.ARRAYINDEX = ADDARRAY(ARR);
return_PSARRAYTYPE = ADDTYPE(TYP, SCOPE);
return return_PSARRAYTYPE;
}
TPSTYPEINDEX PSPOINTERTYPE(TPSSCOPE SCOPE) {
TPSTYPEINDEX return_PSPOINTERTYPE;
TPSTYPE TYP;
TPSTYPEINDEX TYPEINDEX;
TPSNAMEINDEX NAMEINDEX;
WANTTOKENANDREAD(TKCARET);
WANTTOKEN(TKIDENTIFIER);
NAMEINDEX = FINDNAME(LEXER.TOKEN.VALUE, 0);
if (NAMEINDEX == 0) {
TYP = PLACEHOLDERTYPE();
TYP.NAME = LEXER.TOKEN.VALUE;
TYPEINDEX = ADDTYPE(TYP, SCOPE);
}
 else if (DEFS.NAMES[(NAMEINDEX) - 1].CLS == TNCTYPE) TYPEINDEX = DEFS.NAMES[(NAMEINDEX) - 1].TYPEINDEX;
 else {
{
write_s(&STDERR, str_make(12, "Not a type: "));
write_s(&STDERR, LEXER.TOKEN.VALUE);
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
READTOKEN();
TYP = POINTERTYPE(TYPEINDEX);
return_PSPOINTERTYPE = ADDTYPE(TYP, SCOPE);
return return_PSPOINTERTYPE;
}
TPSTYPEINDEX PSTYPEDENOTER(TPSSCOPE SCOPE) {
TPSTYPEINDEX return_PSTYPEDENOTER;
TPSTYPEINDEX TYPEINDEX;
TYPEINDEX = 0;
if (LEXER.TOKEN.ID == TKIDENTIFIER) TYPEINDEX = PSTYPEIDENTIFIER();
 else if (LEXER.TOKEN.ID == TKLPAREN) TYPEINDEX = PSENUMERATEDTYPE(SCOPE);
 else if (LEXER.TOKEN.ID == TKRECORD) TYPEINDEX = PSRECORDTYPE(SCOPE);
 else if (LEXER.TOKEN.ID == TKARRAY) TYPEINDEX = PSARRAYTYPE(SCOPE);
 else if (LEXER.TOKEN.ID == TKCARET) TYPEINDEX = PSPOINTERTYPE(SCOPE);
 else {
{
write_s(&STDERR, str_make(30, "Wanted type definition, found "));
write_s(&STDERR, LXTOKENSTR());
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
return_PSTYPEDENOTER = TYPEINDEX;
return return_PSTYPEDENOTER;
}
void PSTYPEDEFINITIONS(TPSSCOPE SCOPE) {
PString NAME;
TPSTYPEINDEX TYPEINDEX;
TPSTYPE NEWTYPE;
TPSSCOPE PREVIOUSSCOPE;
PREVIOUSSCOPE = GETCURRENTSCOPE();
WANTTOKENANDREAD(TKTYPE);
do {
NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
WANTTOKENANDREAD(TKEQUALS);
TYPEINDEX = PSTYPEDENOTER(SCOPE);
NEWTYPE = DEFS.TYPES[(TYPEINDEX) - 1];
NEWTYPE.NAME = NAME;
NEWTYPE.ALIASFOR = TYPEINDEX;
TYPEINDEX = ADDTYPE(NEWTYPE, SCOPE);
WANTTOKENANDREAD(TKSEMICOLON);
} while (!(LEXER.TOKEN.ID != TKIDENTIFIER));
{
TPSTYPEINDEX first = PREVIOUSSCOPE.NUMTYPES + 1;
TPSTYPEINDEX last = DEFS.SCOPE.NUMTYPES;
if (first <= last) {
TYPEINDEX = first;
while (1) {
{
if (ISPLACEHOLDERTYPE(TYPEINDEX)) {
{
write_s(&STDERR, str_make(41, "Type has been mentioned but not defined: "));
write_s(&STDERR, TYPENAME(TYPEINDEX));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
if (DEFS.TYPES[(TYPEINDEX) - 1].ALIASFOR != 0) OUTTYPEDEFINITION(TYPEINDEX);
}
if (TYPEINDEX == last) break;
++TYPEINDEX;
}
}
}
OUTENUMVALUESINSCOPE(PREVIOUSSCOPE);
}
void PSCONSTANT(PString NAME, TPSSCOPE SCOPE) {
TPSCONSTANT CONSTANT;
WANTTOKENANDREAD(TKEQUALS);
CONSTANT.NAME = NAME;
if ((LEXER.TOKEN.ID == TKFALSE) || (LEXER.TOKEN.ID == TKTRUE) || (LEXER.TOKEN.ID == TKNUMBER) || (LEXER.TOKEN.ID == TKSTRING)) CONSTANT.REPLACEMENT = LEXER.TOKEN;
 else {
{
write_s(&STDERR, str_make(31, "Expected constant value, found "));
write_s(&STDERR, LXTOKENSTR());
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
ADDCONSTANT(CONSTANT, SCOPE);
READTOKEN();
}
void PSCONSTANTVALUE(TPSTYPEINDEX TYPEINDEX) {
TPSEXPRESSION EXPR;
if (ISBOOLEANTYPE(TYPEINDEX)) {
WANTTOKEN2(TKFALSE, TKTRUE);
EXPR = GENBOOLEANCONSTANT(LEXER.TOKEN.ID == TKTRUE);
READTOKEN();
OUTCONSTANTVALUE(EXPR.VALUE);
}
 else if (ISINTEGERTYPE(TYPEINDEX)) {
EXPR = GENNUMBERCONSTANT(GETTOKENVALUEANDREAD(TKNUMBER));
OUTCONSTANTVALUE(EXPR.VALUE);
}
 else if (ISCHARTYPE(TYPEINDEX)) {
EXPR = GENSTRINGCONSTANT(GETTOKENVALUEANDREAD(TKSTRING));
if (!ISCHARTYPE(EXPR.TYPEINDEX)) {
{
write_s(&STDERR, str_make(28, "Expected char constant, got "));
write_s(&STDERR, TYPENAME(EXPR.TYPEINDEX));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
OUTCONSTANTVALUE(EXPR.VALUE);
}
 else if (ISSTRINGTYPE(TYPEINDEX)) {
EXPR = GENSTRINGCONSTANT(GETTOKENVALUEANDREAD(TKSTRING));
OUTCONSTANTVALUE(EXPR.VALUE);
}
 else if (ISARRAYTYPE(TYPEINDEX)) {
WANTTOKENANDREAD(TKLPAREN);
TYPEINDEX = DEFS.ARRAYS[(DEFS.TYPES[(TYPEINDEX) - 1].ARRAYINDEX) - 1].TYPEINDEX;
OUTCONSTANTARRAYBEGIN();
while (LEXER.TOKEN.ID != TKRPAREN) {
PSCONSTANTVALUE(TYPEINDEX);
WANTTOKEN2(TKCOMMA, TKRPAREN);
if (LEXER.TOKEN.ID == TKCOMMA) OUTCONSTANTARRAYSEPARATOR();
SKIPTOKEN(TKCOMMA);
}
OUTCONSTANTARRAYEND();
WANTTOKENANDREAD(TKRPAREN);
}
 else {
{
write_s(&STDERR, str_make(27, "Invalid type for constant: "));
write_s(&STDERR, TYPENAME(TYPEINDEX));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
}
void PSTYPEDCONSTANT(PString NAME, TPSSCOPE SCOPE) {
TPSTYPEINDEX TYPEINDEX;
WANTTOKENANDREAD(TKCOLON);
TYPEINDEX = PSTYPEDENOTER(SCOPE);
WANTTOKENANDREAD(TKEQUALS);
OUTCONSTANTDEFINITIONBEGIN(ADDVARIABLE(MAKETYPEDCONSTANT(NAME, TYPEINDEX), SCOPE));
PSCONSTANTVALUE(TYPEINDEX);
OUTCONSTANTDEFINITIONEND();
}
void PSCONSTDEFINITIONS(TPSSCOPE SCOPE) {
PString NAME;
WANTTOKENANDREAD(TKCONST);
do {
NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
WANTTOKEN2(TKEQUALS, TKCOLON);
if (LEXER.TOKEN.ID == TKEQUALS) PSCONSTANT(NAME, SCOPE);
 else PSTYPEDCONSTANT(NAME, SCOPE);
WANTTOKENANDREAD(TKSEMICOLON);
} while (!(LEXER.TOKEN.ID != TKIDENTIFIER));
}
void PSVARDEFINITIONS(TPSSCOPE SCOPE) {
int NUMNAMES;
PString NAMES[1 + 8 - 1];
TPSTYPEINDEX TYPEINDEX;
TPSSCOPE PREVIOUSSCOPE;
PREVIOUSSCOPE = GETCURRENTSCOPE();
WANTTOKENANDREAD(TKVAR);
do {
NUMNAMES = 0;
do {
NUMNAMES = NUMNAMES + 1;
if (NUMNAMES > 8) {
{
write_s(&STDERR, str_make(37, "Too many names in variable definition"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
NAMES[(NUMNAMES) - 1] = GETTOKENVALUEANDREAD(TKIDENTIFIER);
WANTTOKEN2(TKCOMMA, TKCOLON);
SKIPTOKEN(TKCOMMA);
} while (!(LEXER.TOKEN.ID == TKCOLON));
WANTTOKENANDREAD(TKCOLON);
TYPEINDEX = PSTYPEDENOTER(SCOPE);
WANTTOKENANDREAD(TKSEMICOLON);
{
int first = 1;
int last = NUMNAMES;
if (first <= last) {
NUMNAMES = first;
while (1) {
OUTVARIABLEDEFINITION(ADDVARIABLE(MAKEVARIABLE(NAMES[(NUMNAMES) - 1], TYPEINDEX, 0), SCOPE));
if (NUMNAMES == last) break;
++NUMNAMES;
}
}
}
} while (!(LEXER.TOKEN.ID != TKIDENTIFIER));
OUTENUMVALUESINSCOPE(PREVIOUSSCOPE);
}
void PSSTATEMENT();
void PSDEFINITIONS(TPSSCOPE SCOPE);
void PSFUNCTIONBODY(TPSFUNCTIONINDEX FNINDEX) {
TPSSCOPE PREVIOUSSCOPE;
int POS;
PREVIOUSSCOPE = GETCURRENTSCOPE();
{
int first = 1;
int last = DEFS.FUNCTIONS[(FNINDEX) - 1].ARGCOUNT;
if (first <= last) {
POS = first;
while (1) {
ADDVARIABLE(DEFS.FUNCTIONS[(FNINDEX) - 1].ARGS[(POS) - 1], PREVIOUSSCOPE);
if (POS == last) break;
++POS;
}
}
}
OUTFUNCTIONDEFINITION(FNINDEX);
OUTENUMVALUESINSCOPE(PREVIOUSSCOPE);
PSDEFINITIONS(PREVIOUSSCOPE);
WANTTOKENANDREAD(TKBEGIN);
while (LEXER.TOKEN.ID != TKEND) {
PSSTATEMENT();
WANTTOKEN2(TKSEMICOLON, TKEND);
SKIPTOKEN(TKSEMICOLON);
}
WANTTOKENANDREAD(TKEND);
WANTTOKENANDREAD(TKSEMICOLON);
OUTFUNCTIONEND(FNINDEX);
SETCURRENTSCOPE(PREVIOUSSCOPE);
}
void PSARGUMENTS(TPSFUNCTION *DEF) {
PBoolean ISREFERENCE;
int LASTARG;
int ARG;
TPSTYPEINDEX TYPEINDEX;
WANTTOKENANDREAD(TKLPAREN);
do {
ISREFERENCE = LEXER.TOKEN.ID == TKVAR;
SKIPTOKEN(TKVAR);
LASTARG = (*DEF).ARGCOUNT;
do {
(*DEF).ARGCOUNT = (*DEF).ARGCOUNT + 1;
if ((*DEF).ARGCOUNT > 4) {
{
write_s(&STDERR, str_make(41, "Too many arguments declared for function "));
write_s(&STDERR, (*DEF).NAME);
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
(*DEF).ARGS[((*DEF).ARGCOUNT) - 1].NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
(*DEF).ARGS[((*DEF).ARGCOUNT) - 1].ISREFERENCE = ISREFERENCE;
WANTTOKEN2(TKCOLON, TKCOMMA);
SKIPTOKEN(TKCOMMA);
} while (!(LEXER.TOKEN.ID == TKCOLON));
SKIPTOKEN(TKCOLON);
TYPEINDEX = PSTYPEIDENTIFIER();
{
int first = LASTARG + 1;
int last = (*DEF).ARGCOUNT;
if (first <= last) {
ARG = first;
while (1) {
(*DEF).ARGS[(ARG) - 1].TYPEINDEX = TYPEINDEX;
if (ARG == last) break;
++ARG;
}
}
}
WANTTOKEN2(TKSEMICOLON, TKRPAREN);
SKIPTOKEN(TKSEMICOLON);
} while (!(LEXER.TOKEN.ID == TKRPAREN));
SKIPTOKEN(TKRPAREN);
}
void PSPROCEDUREDEFINITION() {
PBoolean ISPROCEDURE;
TPSFUNCTION DEF;
DEF = EMPTYFUNCTION();
WANTTOKENANDREAD(TKPROCEDURE);
DEF.NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
WANTTOKEN2(TKLPAREN, TKSEMICOLON);
if (LEXER.TOKEN.ID == TKLPAREN) PSARGUMENTS(&DEF);
WANTTOKENANDREAD(TKSEMICOLON);
if (LEXER.TOKEN.ID == TKFORWARD) {
SKIPTOKEN(TKFORWARD);
WANTTOKENANDREAD(TKSEMICOLON);
DEF.ISDECLARATION = 1;
OUTFUNCTIONDECLARATION(ADDFUNCTION(DEF));
}
 else PSFUNCTIONBODY(ADDFUNCTION(DEF));
}
TPSTYPEINDEX PSRESULTTYPE() {
TPSTYPEINDEX return_PSRESULTTYPE;
return_PSRESULTTYPE = PSTYPEIDENTIFIER();
return return_PSRESULTTYPE;
}
void PSFUNCTIONDEFINITION() {
PBoolean ISPROCEDURE;
TPSFUNCTION DEF;
DEF = EMPTYFUNCTION();
WANTTOKENANDREAD(TKFUNCTION);
DEF.NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
if ((LEXER.TOKEN.ID == TKSEMICOLON) && HASFORWARDDECLARATION(DEF.NAME)) DEF.RETURNTYPEINDEX = 0;
 else {
WANTTOKEN2(TKLPAREN, TKCOLON);
if (LEXER.TOKEN.ID == TKLPAREN) PSARGUMENTS(&DEF);
WANTTOKENANDREAD(TKCOLON);
DEF.RETURNTYPEINDEX = PSRESULTTYPE();
}
WANTTOKENANDREAD(TKSEMICOLON);
if (LEXER.TOKEN.ID == TKFORWARD) {
SKIPTOKEN(TKFORWARD);
WANTTOKENANDREAD(TKSEMICOLON);
DEF.ISDECLARATION = 1;
OUTFUNCTIONDECLARATION(ADDFUNCTION(DEF));
}
 else PSFUNCTIONBODY(ADDFUNCTION(DEF));
}
void PSDEFINITIONS(TPSSCOPE SCOPE) {
PBoolean DONE;
DONE = 0;
do {
if (LEXER.TOKEN.ID == TKTYPE) PSTYPEDEFINITIONS(SCOPE);
 else if (LEXER.TOKEN.ID == TKCONST) PSCONSTDEFINITIONS(SCOPE);
 else if (LEXER.TOKEN.ID == TKVAR) PSVARDEFINITIONS(SCOPE);
 else if (LEXER.TOKEN.ID == TKPROCEDURE) PSPROCEDUREDEFINITION();
 else if (LEXER.TOKEN.ID == TKFUNCTION) PSFUNCTIONDEFINITION();
 else DONE = 1;
} while (!(DONE));
}
void PSPROGRAMHEADING() {
WANTTOKENANDREAD(TKPROGRAM);
OUTPROGRAMHEADING(GETTOKENVALUEANDREAD(TKIDENTIFIER));
if (LEXER.TOKEN.ID == TKLPAREN) {
do {
READTOKEN();
WANTTOKEN2(TKIDENTIFIER, TKRPAREN);
SKIPTOKEN(TKIDENTIFIER);
WANTTOKEN2(TKCOMMA, TKRPAREN);
} while (!(LEXER.TOKEN.ID == TKRPAREN));
SKIPTOKEN(TKRPAREN);
}
WANTTOKENANDREAD(TKSEMICOLON);
}
TPSEXPRESSION PSEXPRESSION();
TPSIDENTIFIER PSIDENTIFIER() {
TPSIDENTIFIER return_PSIDENTIFIER;
TPSIDENTIFIER IDENT;
IDENT.NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
return_PSIDENTIFIER = IDENT;
return return_PSIDENTIFIER;
}
TPSEXPRESSION PSFUNCTIONCALL(TPSEXPRESSION FN) {
TPSEXPRESSION return_PSFUNCTIONCALL;
TPSFUNCTION FUN;
TPSEXPRESSION EXPR;
int ARGNUM;
if (FN.CLS != TECFUNCTION) {
{
write_s(&STDERR, str_make(14, "Not a function"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
FUN = DEFS.FUNCTIONS[(FN.FUNCTIONINDEX) - 1];
FN.VALUE = GENFUNCTIONCALLSTART(FN.VALUE);
WANTTOKENANDREAD(TKLPAREN);
{
int first = 1;
int last = FUN.ARGCOUNT;
if (first <= last) {
ARGNUM = first;
while (1) {
{
if (ARGNUM != 1) WANTTOKENANDREAD(TKCOMMA);
EXPR = COERCETYPE(PSEXPRESSION(), FUN.ARGS[(ARGNUM) - 1].TYPEINDEX);
FN.VALUE = GENFUNCTIONCALLARGUMENT(FN.VALUE, EXPR, FUN.ARGS[(ARGNUM) - 1].ISREFERENCE, ARGNUM);
}
if (ARGNUM == last) break;
++ARGNUM;
}
}
}
WANTTOKENANDREAD(TKRPAREN);
FN.VALUE = GENFUNCTIONCALLEND(FN.VALUE);
FN.CLS = TECVALUE;
FN.TYPEINDEX = FUN.RETURNTYPEINDEX;
FN.ISCONSTANT = 1;
return_PSFUNCTIONCALL = FN;
return return_PSFUNCTIONCALL;
}
TPSEXPRESSION PSPOINTERDEREF(TPSEXPRESSION PTR) {
TPSEXPRESSION return_PSPOINTERDEREF;
PTR = EVALUATE(PTR);
if ((PTR.CLS != TECVALUE) || !ISPOINTERTYPE(PTR.TYPEINDEX)) {
{
write_s(&STDERR, str_make(13, "Not a pointer"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
WANTTOKENANDREAD(TKCARET);
PTR.VALUE = cat_sc(cat_ss(str_make(2, "*("), PTR.VALUE), ')');
PTR.TYPEINDEX = DEFS.TYPES[(PTR.TYPEINDEX) - 1].POINTEDTYPEINDEX;
return_PSPOINTERDEREF = PTR;
return return_PSPOINTERDEREF;
}
void PSREAD(TPSSPECIALFUNCTION FN) {
PString SRC;
PBoolean LINEFEED;
TPSEXPRESSION OUTVAR;
LINEFEED = FN == TSFREADLN;
SRC = str_make(5, "INPUT");
if (LEXER.TOKEN.ID != TKLPAREN) {
if (LINEFEED) OUTREADLN(SRC);
}
 else {
OUTBEGIN();
WANTTOKENANDREAD(TKLPAREN);
if (LEXER.TOKEN.ID != TKRPAREN) {
OUTVAR = PSEXPRESSION();
if (ISVARIABLEEXPRESSION(OUTVAR) && ISTEXTTYPE(OUTVAR.TYPEINDEX)) SRC = OUTVAR.VALUE;
 else {
if (!ISVARIABLEEXPRESSION(OUTVAR) || !ISSTRINGYTYPE(OUTVAR.TYPEINDEX)) {
{
write_s(&STDERR, str_make(36, "Invalid expression for read argument"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
OUTREAD(SRC, OUTVAR);
}
WANTTOKEN2(TKCOMMA, TKRPAREN);
SKIPTOKEN(TKCOMMA);
while (LEXER.TOKEN.ID != TKRPAREN) {
OUTVAR = PSEXPRESSION();
if (!ISVARIABLEEXPRESSION(OUTVAR) || !ISSTRINGYTYPE(OUTVAR.TYPEINDEX)) {
{
write_s(&STDERR, str_make(36, "Invalid expression for read argument"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
OUTREAD(SRC, OUTVAR);
WANTTOKEN2(TKCOMMA, TKRPAREN);
SKIPTOKEN(TKCOMMA);
}
}
WANTTOKENANDREAD(TKRPAREN);
if (LINEFEED) OUTREADLN(SRC);
OUTEND();
}
}
void PSWRITE(TPSSPECIALFUNCTION FN) {
PString DST;
PBoolean LINEFEED;
TPSEXPRESSION EXPR;
LINEFEED = FN == TSFWRITELN;
DST = str_make(6, "OUTPUT");
if (LEXER.TOKEN.ID != TKLPAREN) {
if (LINEFEED) OUTWRITELN(DST);
}
 else {
OUTBEGIN();
WANTTOKENANDREAD(TKLPAREN);
if (LEXER.TOKEN.ID != TKRPAREN) {
EXPR = PSEXPRESSION();
if (ISVARIABLEEXPRESSION(EXPR) && ISTEXTTYPE(EXPR.TYPEINDEX)) DST = EXPR.VALUE;
 else OUTWRITE(DST, EXPR);
WANTTOKEN2(TKCOMMA, TKRPAREN);
SKIPTOKEN(TKCOMMA);
while (LEXER.TOKEN.ID != TKRPAREN) {
OUTWRITE(DST, PSEXPRESSION());
WANTTOKEN2(TKCOMMA, TKRPAREN);
SKIPTOKEN(TKCOMMA);
}
}
WANTTOKENANDREAD(TKRPAREN);
if (LINEFEED) OUTWRITELN(DST);
OUTEND();
}
}
void PSSTR() {
TPSEXPRESSION EXPR;
TPSEXPRESSION DEST;
WANTTOKENANDREAD(TKLPAREN);
EXPR = PSEXPRESSION();
WANTTOKENANDREAD(TKCOMMA);
DEST = PSEXPRESSION();
if (!ISVARIABLEEXPRESSION(DEST) || !ISSTRINGTYPE(DEST.TYPEINDEX)) {
{
write_s(&STDERR, str_make(45, "Destination argument is not a string variable"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
WANTTOKENANDREAD(TKRPAREN);
OUTSTR(DEST.VALUE, EXPR);
}
void PSNEW() {
TPSEXPRESSION DEST;
WANTTOKENANDREAD(TKLPAREN);
DEST = PSEXPRESSION();
WANTTOKENANDREAD(TKRPAREN);
if (!ISVARIABLEEXPRESSION(DEST) || !ISPOINTERTYPE(DEST.TYPEINDEX)) {
{
write_s(&STDERR, str_make(25, "Argument is not a pointer"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
OUTNEW(DEST);
}
void PSDISPOSE() {
TPSEXPRESSION DEST;
WANTTOKENANDREAD(TKLPAREN);
DEST = PSEXPRESSION();
WANTTOKENANDREAD(TKRPAREN);
if (!ISVARIABLEEXPRESSION(DEST) || !ISPOINTERTYPE(DEST.TYPEINDEX)) {
{
write_s(&STDERR, str_make(25, "Argument is not a pointer"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
OUTDISPOSE(DEST);
}
TPSEXPRESSION PSARRAYACCESS(TPSEXPRESSION ARR) {
TPSEXPRESSION return_PSARRAYACCESS;
TPSEXPRESSION IDX;
WANTTOKENANDREAD(TKLBRACKET);
IDX = PSEXPRESSION();
WANTTOKENANDREAD(TKRBRACKET);
if ((IDX.CLS != TECVALUE) || !ISINTEGERTYPE(IDX.TYPEINDEX)) {
{
write_s(&STDERR, str_make(28, "Subscript must be an integer"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
if ((ARR.CLS == TECVALUE) && ISSTRINGTYPE(ARR.TYPEINDEX)) {
SETSTRINGINDEX(&ARR, IDX);
ARR.TYPEINDEX = PRIMITIVETYPES.PTCHAR;
}
 else if ((ARR.CLS == TECVALUE) && ISARRAYTYPE(ARR.TYPEINDEX)) {
SETARRAYINDEX(&ARR, IDX);
ARR.TYPEINDEX = DEFS.ARRAYS[(DEFS.TYPES[(ARR.TYPEINDEX) - 1].ARRAYINDEX) - 1].TYPEINDEX;
}
 else {
{
write_s(&STDERR, str_make(21, "Not a string or array"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
return_PSARRAYACCESS = ARR;
return return_PSARRAYACCESS;
}
TPSEXPRESSION PSFIELDACCESS(TPSEXPRESSION REC) {
TPSEXPRESSION return_PSFIELDACCESS;
TPSIDENTIFIER FLD;
TPSTYPEINDEX FLDTYPE;
if ((REC.CLS != TECVALUE) || (DEFS.TYPES[(REC.TYPEINDEX) - 1].CLS != TTCRECORD)) {
{
write_s(&STDERR, str_make(12, "Not a record"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
WANTTOKENANDREAD(TKDOT);
FLD = PSIDENTIFIER();
FLDTYPE = FINDFIELDTYPE(REC.TYPEINDEX, FLD.NAME);
if (FLDTYPE == 0) {
{
write_s(&STDERR, str_make(6, "Field "));
write_s(&STDERR, FLD.NAME);
write_s(&STDERR, str_make(20, " not found in record"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
SETFIELDACCESS(&REC, FLD.NAME);
REC.TYPEINDEX = FLDTYPE;
return_PSFIELDACCESS = REC;
return return_PSFIELDACCESS;
}
TPSEXPRESSION PSVARIABLEORFUNCTIONCALL() {
TPSEXPRESSION return_PSVARIABLEORFUNCTIONCALL;
TPSIDENTIFIER ID;
TPSNAME FOUND;
TPSEXPRESSION EXPR;
PBoolean DONE;
DONE = 0;
EXPR.VALUE = str_make(0, "");
EXPR.ISCONSTANT = 0;
ID = PSIDENTIFIER();
FOUND = DEFS.NAMES[(FINDNAME(ID.NAME, 1)) - 1];
if (FOUND.CLS == TNCVARIABLE) {
if (DEFS.VARIABLES[(FOUND.VARIABLEINDEX) - 1].ISREFERENCE) EXPR.VALUE = cat_cs('*', ID.NAME);
 else EXPR.VALUE = ID.NAME;
EXPR.CLS = TECVALUE;
EXPR.TYPEINDEX = DEFS.VARIABLES[(FOUND.VARIABLEINDEX) - 1].TYPEINDEX;
}
 else if (FOUND.CLS == TNCFUNCTION) {
EXPR.VALUE = ID.NAME;
EXPR.CLS = TECFUNCTION;
EXPR.FUNCTIONINDEX = FOUND.FUNCTIONINDEX;
}
 else if (FOUND.CLS == TNCENUMVALUE) {
EXPR.VALUE = ID.NAME;
EXPR.CLS = TECVALUE;
EXPR.TYPEINDEX = FOUND.TYPEINDEX;
EXPR.ISCONSTANT = 1;
}
 else if (FOUND.CLS == TNCSPECIALFUNCTION) {
EXPR.CLS = TECSTATEMENT;
EXPR.TYPEINDEX = 0;
if ((FOUND.SPECIALFUNCTION == TSFREAD) || (FOUND.SPECIALFUNCTION == TSFREADLN)) PSREAD(FOUND.SPECIALFUNCTION);
 else if ((FOUND.SPECIALFUNCTION == TSFWRITE) || (FOUND.SPECIALFUNCTION == TSFWRITELN)) PSWRITE(FOUND.SPECIALFUNCTION);
 else if (FOUND.SPECIALFUNCTION == TSFSTR) PSSTR();
 else if (FOUND.SPECIALFUNCTION == TSFNEW) PSNEW();
 else if (FOUND.SPECIALFUNCTION == TSFDISPOSE) PSDISPOSE();
}
 else {
{
write_s(&STDERR, str_make(20, "Invalid identifier: "));
write_s(&STDERR, ID.NAME);
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
do {
if (LEXER.TOKEN.ID == TKDOT) EXPR = PSFIELDACCESS(EXPR);
 else if (LEXER.TOKEN.ID == TKLBRACKET) EXPR = PSARRAYACCESS(EXPR);
 else if (LEXER.TOKEN.ID == TKLPAREN) EXPR = PSFUNCTIONCALL(EXPR);
 else if (LEXER.TOKEN.ID == TKCARET) EXPR = PSPOINTERDEREF(EXPR);
 else DONE = 1;
} while (!(DONE));
return_PSVARIABLEORFUNCTIONCALL = EXPR;
return return_PSVARIABLEORFUNCTIONCALL;
}
PBoolean ISOPADDING(TLXTOKEN TOK) {
PBoolean return_ISOPADDING;
return_ISOPADDING = (TOK.ID == TKPLUS) || (TOK.ID == TKMINUS) || (TOK.ID == TKOR);
return return_ISOPADDING;
}
PBoolean ISOPMULTIPLYING(TLXTOKEN TOK) {
PBoolean return_ISOPMULTIPLYING;
return_ISOPMULTIPLYING = (TOK.ID == TKASTERISK) || (TOK.ID == TKSLASH) || (TOK.ID == TKDIV) || (TOK.ID == TKMOD) || (TOK.ID == TKAND);
return return_ISOPMULTIPLYING;
}
PBoolean ISOPRELATIONAL(TLXTOKEN TOK) {
PBoolean return_ISOPRELATIONAL;
return_ISOPRELATIONAL = (TOK.ID == TKEQUALS) || (TOK.ID == TKNOTEQUALS) || (TOK.ID == TKLESSTHAN) || (TOK.ID == TKMORETHAN) || (TOK.ID == TKLESSOREQUALS) || (TOK.ID == TKMOREOREQUALS) || (TOK.ID == TKIN);
return return_ISOPRELATIONAL;
}
TPSEXPRESSION PSFACTOR() {
TPSEXPRESSION return_PSFACTOR;
TPSEXPRESSION EXPR;
if (LEXER.TOKEN.ID == TKNIL) {
EXPR = GENNILCONSTANT();
READTOKEN();
}
 else if ((LEXER.TOKEN.ID == TKFALSE) || (LEXER.TOKEN.ID == TKTRUE)) {
EXPR = GENBOOLEANCONSTANT(LEXER.TOKEN.ID == TKTRUE);
READTOKEN();
}
 else if (LEXER.TOKEN.ID == TKSTRING) EXPR = GENSTRINGCONSTANT(GETTOKENVALUEANDREAD(TKSTRING));
 else if (LEXER.TOKEN.ID == TKNUMBER) EXPR = GENNUMBERCONSTANT(GETTOKENVALUEANDREAD(TKNUMBER));
 else if (LEXER.TOKEN.ID == TKIDENTIFIER) EXPR = PSVARIABLEORFUNCTIONCALL();
 else if (LEXER.TOKEN.ID == TKLPAREN) {
WANTTOKENANDREAD(TKLPAREN);
EXPR = GENPARENS(PSEXPRESSION());
WANTTOKENANDREAD(TKRPAREN);
}
 else if (LEXER.TOKEN.ID == TKNOT) {
WANTTOKENANDREAD(TKNOT);
EXPR = UNARYEXPRESSION(TKNOT, PSFACTOR());
}
 else {
{
write_s(&STDERR, str_make(29, "Invalid token in expression: "));
write_s(&STDERR, LXTOKENSTR());
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
return_PSFACTOR = EXPR;
return return_PSFACTOR;
}
TPSEXPRESSION PSTERM() {
TPSEXPRESSION return_PSTERM;
TLXTOKENID OP;
TPSEXPRESSION EXPR;
EXPR = PSFACTOR();
while (ISOPMULTIPLYING(LEXER.TOKEN)) {
OP = LEXER.TOKEN.ID;
READTOKEN();
EXPR = BINARYEXPRESSION(EXPR, OP, PSFACTOR());
}
return_PSTERM = EXPR;
return return_PSTERM;
}
TPSEXPRESSION PSSIMPLEEXPRESSION() {
TPSEXPRESSION return_PSSIMPLEEXPRESSION;
PBoolean NEGATIVE;
TLXTOKENID OP;
TPSEXPRESSION EXPR;
NEGATIVE = LEXER.TOKEN.ID == TKMINUS;
if (NEGATIVE) READTOKEN();
EXPR = PSTERM();
if (NEGATIVE) EXPR = UNARYEXPRESSION(TKMINUS, EXPR);
while (ISOPADDING(LEXER.TOKEN)) {
OP = LEXER.TOKEN.ID;
READTOKEN();
EXPR = BINARYEXPRESSION(EXPR, OP, PSTERM());
}
return_PSSIMPLEEXPRESSION = EXPR;
return return_PSSIMPLEEXPRESSION;
}
TPSEXPRESSION PSEXPRESSION() {
TPSEXPRESSION return_PSEXPRESSION;
TLXTOKENID OP;
TPSEXPRESSION EXPR;
EXPR = PSSIMPLEEXPRESSION();
while (ISOPRELATIONAL(LEXER.TOKEN)) {
OP = LEXER.TOKEN.ID;
READTOKEN();
EXPR = BINARYEXPRESSION(EXPR, OP, PSSIMPLEEXPRESSION());
}
return_PSEXPRESSION = EXPR;
return return_PSEXPRESSION;
}
void PSASSIGN(TPSEXPRESSION LHS, TPSEXPRESSION RHS) {
if (LHS.ISCONSTANT) {
{
write_s(&STDERR, str_make(33, "Cannot assign to a constant value"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
if (LHS.CLS == TECFUNCTION) OUTASSIGNRETURNVALUE(LHS, COERCETYPE(RHS, DEFS.FUNCTIONS[(LHS.FUNCTIONINDEX) - 1].RETURNTYPEINDEX));
 else if (LHS.CLS == TECVALUE) OUTASSIGN(LHS, COERCETYPE(RHS, LHS.TYPEINDEX));
 else {
{
write_s(&STDERR, str_make(36, "Cannot assign to result of statement"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
}
void PSSTATEMENTSEQUENCE() {
OUTBEGIN();
SKIPTOKEN(TKBEGIN);
while (LEXER.TOKEN.ID != TKEND) {
PSSTATEMENT();
WANTTOKEN2(TKSEMICOLON, TKEND);
SKIPTOKEN(TKSEMICOLON);
}
OUTEND();
SKIPTOKEN(TKEND);
}
void PSIDENTIFIERSTATEMENT() {
TPSEXPRESSION LHS;
LHS = PSEXPRESSION();
if (LEXER.TOKEN.ID == TKASSIGN) {
WANTTOKENANDREAD(TKASSIGN);
PSASSIGN(LHS, PSEXPRESSION());
}
 else if (LHS.CLS != TECSTATEMENT) {
if (LHS.CLS == TECFUNCTION) LHS = EVALUATE(LHS);
OUTPROCEDURECALL(LHS);
}
}
void PSIFSTATEMENT() {
WANTTOKENANDREAD(TKIF);
OUTIF(COERCETYPE(PSEXPRESSION(), PRIMITIVETYPES.PTBOOLEAN));
WANTTOKENANDREAD(TKTHEN);
if (LEXER.TOKEN.ID == TKELSE) OUTEMPTYSTATEMENT();
 else PSSTATEMENT();
if (LEXER.TOKEN.ID == TKELSE) {
WANTTOKENANDREAD(TKELSE);
OUTELSE();
PSSTATEMENT();
}
}
void PSREPEATSTATEMENT() {
WANTTOKENANDREAD(TKREPEAT);
OUTREPEATBEGIN();
while (LEXER.TOKEN.ID != TKUNTIL) {
PSSTATEMENT();
WANTTOKEN2(TKSEMICOLON, TKUNTIL);
SKIPTOKEN(TKSEMICOLON);
}
WANTTOKENANDREAD(TKUNTIL);
OUTREPEATEND(COERCETYPE(PSEXPRESSION(), PRIMITIVETYPES.PTBOOLEAN));
}
void PSWHILESTATEMENT() {
WANTTOKENANDREAD(TKWHILE);
OUTWHILEBEGIN(COERCETYPE(PSEXPRESSION(), PRIMITIVETYPES.PTBOOLEAN));
WANTTOKENANDREAD(TKDO);
PSSTATEMENT();
OUTWHILEEND();
}
void PSFORSTATEMENT() {
TPSEXPRESSION ITER;
TPSEXPRESSION FIRST;
TPSEXPRESSION LAST;
PBoolean ASCENDING;
WANTTOKENANDREAD(TKFOR);
ITER = PSEXPRESSION();
if (!ISVARIABLEEXPRESSION(ITER)) {
{
write_s(&STDERR, str_make(17, "Expected variable"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
if (!ISORDINALTYPE(ITER.TYPEINDEX)) {
{
write_s(&STDERR, str_make(33, "Type of iterator is not ordinal: "));
write_s(&STDERR, TYPENAME(ITER.TYPEINDEX));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
WANTTOKENANDREAD(TKASSIGN);
FIRST = EVALUATE(PSEXPRESSION());
WANTTOKEN2(TKTO, TKDOWNTO);
ASCENDING = LEXER.TOKEN.ID == TKTO;
READTOKEN();
LAST = EVALUATE(PSEXPRESSION());
WANTTOKENANDREAD(TKDO);
OUTFORBEGIN(ITER, FIRST, LAST, ASCENDING);
PSSTATEMENT();
OUTFOREND(ITER, ASCENDING);
}
void PSSTATEMENT() {
if (LEXER.TOKEN.ID == TKSEMICOLON) OUTEMPTYSTATEMENT();
 else if (LEXER.TOKEN.ID == TKBEGIN) PSSTATEMENTSEQUENCE();
 else if (LEXER.TOKEN.ID == TKIDENTIFIER) PSIDENTIFIERSTATEMENT();
 else if (LEXER.TOKEN.ID == TKIF) PSIFSTATEMENT();
 else if (LEXER.TOKEN.ID == TKREPEAT) PSREPEATSTATEMENT();
 else if (LEXER.TOKEN.ID == TKWHILE) PSWHILESTATEMENT();
 else if (LEXER.TOKEN.ID == TKFOR) PSFORSTATEMENT();
 else {
{
write_s(&STDERR, str_make(17, "Unexpected token "));
write_s(&STDERR, LXTOKENSTR());
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
}
void PSPROGRAMBLOCK() {
PSDEFINITIONS(GLOBALSCOPE);
WANTTOKENANDREAD(TKBEGIN);
OUTPROGRAMBEGIN();
while (LEXER.TOKEN.ID != TKEND) {
PSSTATEMENT();
WANTTOKEN2(TKSEMICOLON, TKEND);
SKIPTOKEN(TKSEMICOLON);
}
OUTPROGRAMEND();
WANTTOKENANDREAD(TKEND);
}
void EXECUTEDIRECTIVE(PString DIR) {
if ((LENGTH(DIR) > 3) && (cmp_cc(DIR.chr[2], 'I') == 0) && (cmp_cc(DIR.chr[3], ' ') == 0)) LXINCLUDE(COPY(DIR, 4, 255));
}
void READTOKEN() {
TPSCONSTANTINDEX CONSTINDEX;
TLXPOS TOKENPOS;
PBoolean STOP;
do {
LXREADTOKEN();
STOP = LEXER.TOKEN.ID != TKCOMMENT;
if (LEXER.TOKEN.ID == TKIDENTIFIER) {
CONSTINDEX = FINDCONSTANT(LEXER.TOKEN.VALUE);
if (CONSTINDEX != 0) {
TOKENPOS = LEXER.TOKEN.POS;
LEXER.TOKEN = DEFS.CONSTANTS[(CONSTINDEX) - 1].REPLACEMENT;
LEXER.TOKEN.POS = TOKENPOS;
}
}
if (LEXER.TOKEN.ID == TKCOMMENT) if ((LENGTH(LEXER.TOKEN.VALUE) >= 2) && (cmp_cc(LEXER.TOKEN.VALUE.chr[1], '$') == 0)) EXECUTEDIRECTIVE(LEXER.TOKEN.VALUE);
if ((LEXER.TOKEN.ID == TKEOF) && LEXER.PREV.EXISTS) {
LEXER.INPUT = LEXER.PREV.INPUT;
LEXER.PREV.EXISTS = 0;
STOP = 0;
}
} while (!(STOP));
}
void PARSEPROGRAM() {
READTOKEN();
PSPROGRAMHEADING();
PSPROGRAMBLOCK();
WANTTOKENANDREAD(TKDOT);
WANTTOKEN(TKEOF);
}
void STARTGLOBALSCOPE() {
TPSFUNCTION FUN;
CLEARDEFS();
GLOBALSCOPE = GETCURRENTSCOPE();
PRIMITIVETYPES.PTNIL = ADDTYPE(MAKETYPE(str_make(3, "NIL"), TTCNIL), GLOBALSCOPE);
PRIMITIVETYPES.PTBOOLEAN = ADDTYPE(MAKETYPE(str_make(7, "BOOLEAN"), TTCBOOLEAN), GLOBALSCOPE);
PRIMITIVETYPES.PTINTEGER = ADDTYPE(MAKETYPE(str_make(7, "INTEGER"), TTCINTEGER), GLOBALSCOPE);
PRIMITIVETYPES.PTCHAR = ADDTYPE(MAKETYPE(str_make(4, "CHAR"), TTCCHAR), GLOBALSCOPE);
PRIMITIVETYPES.PTSTRING = ADDTYPE(MAKETYPE(str_make(6, "STRING"), TTCSTRING), GLOBALSCOPE);
PRIMITIVETYPES.PTTEXT = ADDTYPE(MAKETYPE(str_make(4, "TEXT"), TTCTEXT), GLOBALSCOPE);
ADDCONSTANT(MAKECONSTANT(str_make(5, "FALSE"), TKFALSE, str_make(5, "FALSE")), GLOBALSCOPE);
ADDCONSTANT(MAKECONSTANT(str_make(4, "TRUE"), TKTRUE, str_make(4, "TRUE")), GLOBALSCOPE);
ADDCONSTANT(MAKECONSTANT(str_make(6, "MAXINT"), TKNUMBER, str_make(10, "2147483647")), GLOBALSCOPE);
ADDVARIABLE(MAKEVARIABLE(str_make(5, "INPUT"), PRIMITIVETYPES.PTTEXT, 0), GLOBALSCOPE);
ADDVARIABLE(MAKEVARIABLE(str_make(6, "OUTPUT"), PRIMITIVETYPES.PTTEXT, 0), GLOBALSCOPE);
ADDVARIABLE(MAKEVARIABLE(str_make(6, "STDERR"), PRIMITIVETYPES.PTTEXT, 0), GLOBALSCOPE);
ADDSPECIALFUNCTION(str_make(4, "READ"), TSFREAD);
ADDSPECIALFUNCTION(str_make(6, "READLN"), TSFREADLN);
ADDSPECIALFUNCTION(str_make(5, "WRITE"), TSFWRITE);
ADDSPECIALFUNCTION(str_make(7, "WRITELN"), TSFWRITELN);
ADDSPECIALFUNCTION(str_make(3, "STR"), TSFSTR);
ADDSPECIALFUNCTION(str_make(3, "NEW"), TSFNEW);
ADDSPECIALFUNCTION(str_make(7, "DISPOSE"), TSFDISPOSE);
FUN.NAME = str_make(6, "ASSIGN");
FUN.ARGCOUNT = 2;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_of('F'), PRIMITIVETYPES.PTTEXT, 1);
FUN.ARGS[(2) - 1] = MAKEVARIABLE(str_make(4, "NAME"), PRIMITIVETYPES.PTSTRING, 0);
FUN.RETURNTYPEINDEX = 0;
ADDFUNCTION(FUN);
FUN.NAME = str_make(5, "CLOSE");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_of('F'), PRIMITIVETYPES.PTTEXT, 1);
FUN.RETURNTYPEINDEX = 0;
ADDFUNCTION(FUN);
FUN.NAME = str_make(4, "COPY");
FUN.ARGCOUNT = 3;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_make(3, "STR"), PRIMITIVETYPES.PTSTRING, 0);
FUN.ARGS[(2) - 1] = MAKEVARIABLE(str_make(3, "POS"), PRIMITIVETYPES.PTINTEGER, 0);
FUN.ARGS[(3) - 1] = MAKEVARIABLE(str_make(3, "NUM"), PRIMITIVETYPES.PTINTEGER, 0);
FUN.RETURNTYPEINDEX = PRIMITIVETYPES.PTSTRING;
ADDFUNCTION(FUN);
FUN.NAME = str_make(6, "DELETE");
FUN.ARGCOUNT = 3;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_make(3, "STR"), PRIMITIVETYPES.PTSTRING, 1);
FUN.ARGS[(2) - 1] = MAKEVARIABLE(str_make(3, "POS"), PRIMITIVETYPES.PTINTEGER, 0);
FUN.ARGS[(3) - 1] = MAKEVARIABLE(str_make(3, "NUM"), PRIMITIVETYPES.PTINTEGER, 0);
FUN.RETURNTYPEINDEX = 0;
ADDFUNCTION(FUN);
FUN.NAME = str_make(3, "EOF");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_of('F'), PRIMITIVETYPES.PTTEXT, 1);
FUN.RETURNTYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
ADDFUNCTION(FUN);
FUN.NAME = str_make(4, "HALT");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_make(4, "CODE"), PRIMITIVETYPES.PTINTEGER, 0);
FUN.RETURNTYPEINDEX = 0;
ADDFUNCTION(FUN);
FUN.NAME = str_make(6, "LENGTH");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_make(3, "STR"), PRIMITIVETYPES.PTSTRING, 0);
FUN.RETURNTYPEINDEX = PRIMITIVETYPES.PTINTEGER;
ADDFUNCTION(FUN);
FUN.NAME = str_make(10, "PARAMCOUNT");
FUN.ARGCOUNT = 0;
FUN.RETURNTYPEINDEX = PRIMITIVETYPES.PTINTEGER;
ADDFUNCTION(FUN);
FUN.NAME = str_make(8, "PARAMSTR");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_of('I'), PRIMITIVETYPES.PTINTEGER, 0);
FUN.RETURNTYPEINDEX = PRIMITIVETYPES.PTSTRING;
ADDFUNCTION(FUN);
FUN.NAME = str_make(5, "RESET");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_of('F'), PRIMITIVETYPES.PTTEXT, 1);
FUN.RETURNTYPEINDEX = 0;
ADDFUNCTION(FUN);
FUN.NAME = str_make(7, "REWRITE");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_of('F'), PRIMITIVETYPES.PTTEXT, 1);
FUN.RETURNTYPEINDEX = 0;
ADDFUNCTION(FUN);
FUN.NAME = str_make(6, "UPCASE");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_make(3, "CHR"), PRIMITIVETYPES.PTCHAR, 0);
FUN.RETURNTYPEINDEX = PRIMITIVETYPES.PTCHAR;
ADDFUNCTION(FUN);
}
struct { PFile OUTPUT; } CODEGEN;
void OUTBEGIN() {
{
write_c(&CODEGEN.OUTPUT, '{');
writeln(&CODEGEN.OUTPUT);
}
}
void OUTEND() {
{
write_c(&CODEGEN.OUTPUT, '}');
writeln(&CODEGEN.OUTPUT);
}
}
void OUTENUMVALUES(TPSENUMINDEX POS) {
int POSINENUM;
{
write_s(&CODEGEN.OUTPUT, str_make(22, "const char* EnumValues"));
write_i(&CODEGEN.OUTPUT, POS);
write_s(&CODEGEN.OUTPUT, str_make(7, "[] = { "));
}
{
int first = 1;
int last = DEFS.ENUMS[(POS) - 1].SIZE;
if (first <= last) {
POSINENUM = first;
while (1) {
{
if (POSINENUM != 1) {
write_s(&CODEGEN.OUTPUT, str_make(2, ", "));
}
{
write_c(&CODEGEN.OUTPUT, '\"');
write_s(&CODEGEN.OUTPUT, DEFS.ENUMS[(POS) - 1].VALUES[(POSINENUM) - 1]);
write_c(&CODEGEN.OUTPUT, '\"');
}
}
if (POSINENUM == last) break;
++POSINENUM;
}
}
}
{
write_s(&CODEGEN.OUTPUT, str_make(3, " };"));
writeln(&CODEGEN.OUTPUT);
}
}
void OUTENUMVALUESINSCOPE(TPSSCOPE SCOPE) {
TPSENUMINDEX POS;
{
TPSENUMINDEX first = SCOPE.NUMENUMS + 1;
TPSENUMINDEX last = DEFS.SCOPE.NUMENUMS;
if (first <= last) {
POS = first;
while (1) {
OUTENUMVALUES(POS);
if (POS == last) break;
++POS;
}
}
}
}
PString OUTVARIABLENAME(PString NAME, PBoolean ISREFERENCE) {
PString return_OUTVARIABLENAME;
if (ISREFERENCE) return_OUTVARIABLENAME = cat_cs('*', NAME);
 else return_OUTVARIABLENAME = NAME;
return return_OUTVARIABLENAME;
}
PString OUTRETURNVARIABLENAME(PString NAME) {
PString return_OUTRETURNVARIABLENAME;
return_OUTRETURNVARIABLENAME = cat_ss(str_make(7, "return_"), NAME);
return return_OUTRETURNVARIABLENAME;
}
void OUTTYPEREFERENCE(TPSTYPEINDEX TYPEINDEX) {
TPSTYPE TYP;
if (TYPEINDEX != 0) TYP = DEFS.TYPES[(TYPEINDEX) - 1];
if (TYPEINDEX == 0) {
write_s(&CODEGEN.OUTPUT, str_make(4, "void"));
}
 else if (TYP.CLS == TTCPOINTER) {
OUTTYPEREFERENCE(TYP.POINTEDTYPEINDEX);
{
write_c(&CODEGEN.OUTPUT, '*');
}
}
 else if (TYP.CLS == TTCBOOLEAN) {
write_s(&CODEGEN.OUTPUT, str_make(8, "PBoolean"));
}
 else if (TYP.CLS == TTCINTEGER) {
write_s(&CODEGEN.OUTPUT, str_make(3, "int"));
}
 else if (TYP.CLS == TTCCHAR) {
write_s(&CODEGEN.OUTPUT, str_make(4, "char"));
}
 else if (TYP.CLS == TTCSTRING) {
write_s(&CODEGEN.OUTPUT, str_make(7, "PString"));
}
 else if (TYP.CLS == TTCTEXT) {
write_s(&CODEGEN.OUTPUT, str_make(5, "PFile"));
}
 else if (TYP.CLS == TTCENUM) {
write_s(&CODEGEN.OUTPUT, str_make(9, "enum enum"));
write_i(&CODEGEN.OUTPUT, TYP.ENUMINDEX);
}
 else if (TYP.CLS == TTCRECORD) {
write_s(&CODEGEN.OUTPUT, str_make(13, "struct record"));
write_i(&CODEGEN.OUTPUT, TYP.RECORDINDEX);
}
 else if (TYP.CLS == TTCARRAY) {
OUTTYPEREFERENCE(DEFS.ARRAYS[(TYP.ARRAYINDEX) - 1].TYPEINDEX);
{
write_c(&CODEGEN.OUTPUT, '*');
}
}
 else {
{
write_s(&STDERR, str_make(30, "Error writing type reference: "));
write_s(&STDERR, TYPENAME(TYPEINDEX));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
}
void OUTNAMEANDTYPE(PString NAME, TPSTYPEINDEX TYPEINDEX) {
TPSTYPE TYP;
TPSENUMDEF ENUM;
TPSRECORDDEF REC;
TPSARRAYDEF ARR;
int POS;
if (TYPEINDEX != 0) TYP = DEFS.TYPES[(TYPEINDEX) - 1];
if (TYPEINDEX == 0) {
write_s(&CODEGEN.OUTPUT, str_make(5, "void "));
write_s(&CODEGEN.OUTPUT, NAME);
}
 else if (TYP.CLS == TTCPOINTER) {
OUTTYPEREFERENCE(TYP.POINTEDTYPEINDEX);
{
write_s(&CODEGEN.OUTPUT, str_make(2, " *"));
write_s(&CODEGEN.OUTPUT, NAME);
}
}
 else if ((TYP.ALIASFOR != 0) && (cmp_ss(TYP.NAME, str_make(0, "")) != 0)) {
write_s(&CODEGEN.OUTPUT, TYP.NAME);
write_c(&CODEGEN.OUTPUT, ' ');
write_s(&CODEGEN.OUTPUT, NAME);
}
 else if (TYP.CLS == TTCBOOLEAN) {
write_s(&CODEGEN.OUTPUT, str_make(9, "PBoolean "));
write_s(&CODEGEN.OUTPUT, NAME);
}
 else if (TYP.CLS == TTCINTEGER) {
write_s(&CODEGEN.OUTPUT, str_make(4, "int "));
write_s(&CODEGEN.OUTPUT, NAME);
}
 else if (TYP.CLS == TTCCHAR) {
write_s(&CODEGEN.OUTPUT, str_make(5, "char "));
write_s(&CODEGEN.OUTPUT, NAME);
}
 else if (TYP.CLS == TTCSTRING) {
write_s(&CODEGEN.OUTPUT, str_make(8, "PString "));
write_s(&CODEGEN.OUTPUT, NAME);
}
 else if (TYP.CLS == TTCTEXT) {
write_s(&CODEGEN.OUTPUT, str_make(6, "PFile "));
write_s(&CODEGEN.OUTPUT, NAME);
}
 else if (TYP.CLS == TTCENUM) {
ENUM = DEFS.ENUMS[(TYP.ENUMINDEX) - 1];
{
write_s(&CODEGEN.OUTPUT, str_make(9, "enum enum"));
write_i(&CODEGEN.OUTPUT, TYP.ENUMINDEX);
write_s(&CODEGEN.OUTPUT, str_make(3, " { "));
}
{
int first = 1;
int last = ENUM.SIZE;
if (first <= last) {
POS = first;
while (1) {
{
if (POS > 1) {
write_s(&CODEGEN.OUTPUT, str_make(2, ", "));
}
{
write_s(&CODEGEN.OUTPUT, ENUM.VALUES[(POS) - 1]);
}
}
if (POS == last) break;
++POS;
}
}
}
{
write_s(&CODEGEN.OUTPUT, str_make(2, "} "));
write_s(&CODEGEN.OUTPUT, NAME);
}
}
 else if (TYP.CLS == TTCRECORD) {
REC = DEFS.RECORDS[(TYP.RECORDINDEX) - 1];
{
write_s(&CODEGEN.OUTPUT, str_make(13, "struct record"));
write_i(&CODEGEN.OUTPUT, TYP.RECORDINDEX);
write_s(&CODEGEN.OUTPUT, str_make(3, " { "));
}
{
int first = 1;
int last = REC.SIZE;
if (first <= last) {
POS = first;
while (1) {
{
OUTNAMEANDTYPE(REC.FIELDS[(POS) - 1].NAME, REC.FIELDS[(POS) - 1].TYPEINDEX);
{
write_s(&CODEGEN.OUTPUT, str_make(2, "; "));
}
}
if (POS == last) break;
++POS;
}
}
}
{
write_s(&CODEGEN.OUTPUT, str_make(2, "} "));
write_s(&CODEGEN.OUTPUT, NAME);
}
}
 else if (TYP.CLS == TTCARRAY) {
ARR = DEFS.ARRAYS[(TYP.ARRAYINDEX) - 1];
OUTNAMEANDTYPE(NAME, ARR.TYPEINDEX);
{
write_s(&CODEGEN.OUTPUT, str_make(5, "[1 + "));
write_s(&CODEGEN.OUTPUT, ARR.HIGHBOUND);
write_s(&CODEGEN.OUTPUT, str_make(3, " - "));
write_s(&CODEGEN.OUTPUT, ARR.LOWBOUND);
write_c(&CODEGEN.OUTPUT, ']');
}
}
 else {
{
write_s(&STDERR, str_make(29, "Error writing name and type: "));
write_s(&STDERR, NAME);
write_s(&STDERR, str_make(2, ", "));
write_s(&STDERR, TYPENAME(TYPEINDEX));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
}
void OUTTYPEDEFINITION(TPSTYPEINDEX TYPEINDEX) {
PString NAME;
NAME = DEFS.TYPES[(TYPEINDEX) - 1].NAME;
if (DEFS.TYPES[(TYPEINDEX) - 1].ALIASFOR == 0) {
{
write_s(&STDERR, str_make(5, "Type "));
write_s(&STDERR, NAME);
write_s(&STDERR, str_make(16, " is not an alias"));
write_s(&STDERR, LXWHERESTR());
writeln(&STDERR);
}
HALT(1);
}
{
write_s(&CODEGEN.OUTPUT, str_make(8, "typedef "));
}
OUTNAMEANDTYPE(NAME, DEFS.TYPES[(TYPEINDEX) - 1].ALIASFOR);
{
write_c(&CODEGEN.OUTPUT, ';');
writeln(&CODEGEN.OUTPUT);
}
}
void OUTCONSTANTVALUE(PString VALUE) {
{
write_s(&CODEGEN.OUTPUT, VALUE);
}
}
void OUTCONSTANTARRAYBEGIN() {
{
write_s(&CODEGEN.OUTPUT, str_make(2, "{ "));
}
}
void OUTCONSTANTARRAYSEPARATOR() {
{
write_s(&CODEGEN.OUTPUT, str_make(2, ", "));
}
}
void OUTCONSTANTARRAYEND() {
{
write_s(&CODEGEN.OUTPUT, str_make(2, " }"));
}
}
void OUTVARIABLEDECLARATION(TPSVARIABLE VARDEF) {
OUTNAMEANDTYPE(OUTVARIABLENAME(VARDEF.NAME, VARDEF.ISREFERENCE), VARDEF.TYPEINDEX);
}
void OUTVARIABLEDEFINITION(TPSVARIABLEINDEX VARINDEX) {
if (DEFS.VARIABLES[(VARINDEX) - 1].ISCONSTANT) {
write_s(&CODEGEN.OUTPUT, str_make(6, "const "));
}
OUTVARIABLEDECLARATION(DEFS.VARIABLES[(VARINDEX) - 1]);
{
write_c(&CODEGEN.OUTPUT, ';');
writeln(&CODEGEN.OUTPUT);
}
}
void OUTCONSTANTDEFINITIONBEGIN(TPSVARIABLEINDEX VARINDEX) {
{
write_s(&CODEGEN.OUTPUT, str_make(6, "const "));
}
OUTVARIABLEDECLARATION(DEFS.VARIABLES[(VARINDEX) - 1]);
{
write_s(&CODEGEN.OUTPUT, str_make(3, " = "));
}
}
void OUTCONSTANTDEFINITIONEND() {
{
write_c(&CODEGEN.OUTPUT, ';');
writeln(&CODEGEN.OUTPUT);
}
}
void OUTFUNCTIONPROTOTYPE(TPSFUNCTION DEF) {
int POS;
OUTNAMEANDTYPE(DEF.NAME, DEF.RETURNTYPEINDEX);
{
write_c(&CODEGEN.OUTPUT, '(');
}
{
int first = 1;
int last = DEF.ARGCOUNT;
if (first <= last) {
POS = first;
while (1) {
{
OUTVARIABLEDECLARATION(DEF.ARGS[(POS) - 1]);
if (POS != DEF.ARGCOUNT) {
write_s(&CODEGEN.OUTPUT, str_make(2, ", "));
}
}
if (POS == last) break;
++POS;
}
}
}
{
write_c(&CODEGEN.OUTPUT, ')');
}
}
void OUTFUNCTIONDECLARATION(TPSFUNCTIONINDEX FNINDEX) {
OUTFUNCTIONPROTOTYPE(DEFS.FUNCTIONS[(FNINDEX) - 1]);
{
write_c(&CODEGEN.OUTPUT, ';');
writeln(&CODEGEN.OUTPUT);
}
}
void OUTFUNCTIONDEFINITION(TPSFUNCTIONINDEX FNINDEX) {
TPSFUNCTION FUN;
FUN = DEFS.FUNCTIONS[(FNINDEX) - 1];
OUTFUNCTIONPROTOTYPE(FUN);
{
write_s(&CODEGEN.OUTPUT, str_make(2, " {"));
writeln(&CODEGEN.OUTPUT);
}
if (FUN.RETURNTYPEINDEX != 0) {
OUTNAMEANDTYPE(OUTRETURNVARIABLENAME(FUN.NAME), FUN.RETURNTYPEINDEX);
{
write_c(&CODEGEN.OUTPUT, ';');
writeln(&CODEGEN.OUTPUT);
}
}
}
void OUTFUNCTIONEND(TPSFUNCTIONINDEX FNINDEX) {
if (DEFS.FUNCTIONS[(FNINDEX) - 1].RETURNTYPEINDEX != 0) {
write_s(&CODEGEN.OUTPUT, str_make(7, "return "));
write_s(&CODEGEN.OUTPUT, OUTRETURNVARIABLENAME(DEFS.FUNCTIONS[(FNINDEX) - 1].NAME));
write_c(&CODEGEN.OUTPUT, ';');
writeln(&CODEGEN.OUTPUT);
}
{
write_c(&CODEGEN.OUTPUT, '}');
writeln(&CODEGEN.OUTPUT);
}
}
void OUTPROGRAMHEADING(PString NAME) {
{
write_s(&CODEGEN.OUTPUT, str_make(12, "/* Program: "));
write_s(&CODEGEN.OUTPUT, NAME);
write_s(&CODEGEN.OUTPUT, str_make(3, " */"));
writeln(&CODEGEN.OUTPUT);
}
{
write_s(&CODEGEN.OUTPUT, str_make(20, "#include \"pascual.h\""));
writeln(&CODEGEN.OUTPUT);
}
}
void SETSTRINGINDEX(TPSEXPRESSION *STR, TPSEXPRESSION IDX) {
(*STR).VALUE = cat_sc(cat_ss(cat_ss((*STR).VALUE, str_make(5, ".chr[")), IDX.VALUE), ']');
}
void SETARRAYINDEX(TPSEXPRESSION *ARR, TPSEXPRESSION IDX) {
(*ARR).VALUE = cat_sc(cat_ss(cat_ss(cat_ss(cat_ss((*ARR).VALUE, str_make(2, "[(")), IDX.VALUE), str_make(4, ") - ")), DEFS.ARRAYS[(DEFS.TYPES[((*ARR).TYPEINDEX) - 1].ARRAYINDEX) - 1].LOWBOUND), ']');
}
void SETFIELDACCESS(TPSEXPRESSION *REC, PString FLD) {
if (cmp_cc((*REC).VALUE.chr[1], '*') == 0) (*REC).VALUE = cat_sc(cat_cs('(', (*REC).VALUE), ')');
(*REC).VALUE = cat_ss(cat_sc((*REC).VALUE, '.'), FLD);
}
PString GENFUNCTIONCALLSTART(PString FN) {
PString return_GENFUNCTIONCALLSTART;
return_GENFUNCTIONCALLSTART = cat_sc(FN, '(');
return return_GENFUNCTIONCALLSTART;
}
PString GENFUNCTIONCALLEND(PString FN) {
PString return_GENFUNCTIONCALLEND;
return_GENFUNCTIONCALLEND = cat_sc(FN, ')');
return return_GENFUNCTIONCALLEND;
}
PString GENFUNCTIONCALLARGUMENT(PString FN, TPSEXPRESSION EXPR, PBoolean ISREFERENCE, int ARGNUM) {
PString return_GENFUNCTIONCALLARGUMENT;
if (ARGNUM != 1) FN = cat_ss(FN, str_make(2, ", "));
if (ISREFERENCE) FN = cat_ss(cat_sc(FN, '&'), EXPR.VALUE);
 else FN = cat_ss(FN, EXPR.VALUE);
return_GENFUNCTIONCALLARGUMENT = FN;
return return_GENFUNCTIONCALLARGUMENT;
}
TPSEXPRESSION GENPARENS(TPSEXPRESSION EXPR) {
TPSEXPRESSION return_GENPARENS;
EXPR.VALUE = cat_sc(cat_cs('(', EXPR.VALUE), ')');
return_GENPARENS = EXPR;
return return_GENPARENS;
}
void OUTREAD(PString SRC, TPSEXPRESSION OUTVAR) {
{
write_s(&CODEGEN.OUTPUT, str_make(5, "read_"));
write_c(&CODEGEN.OUTPUT, SHORTTYPENAME(OUTVAR.TYPEINDEX));
write_s(&CODEGEN.OUTPUT, str_make(2, "(&"));
write_s(&CODEGEN.OUTPUT, SRC);
write_s(&CODEGEN.OUTPUT, str_make(3, ", &"));
write_s(&CODEGEN.OUTPUT, OUTVAR.VALUE);
write_s(&CODEGEN.OUTPUT, str_make(2, ");"));
writeln(&CODEGEN.OUTPUT);
}
}
void OUTREADLN(PString SRC) {
{
write_s(&CODEGEN.OUTPUT, str_make(8, "readln(&"));
write_s(&CODEGEN.OUTPUT, SRC);
write_s(&CODEGEN.OUTPUT, str_make(2, ");"));
writeln(&CODEGEN.OUTPUT);
}
}
void OUTWRITE(PString DST, TPSEXPRESSION EXPR) {
EXPR = EVALUATE(EXPR);
if (DEFS.TYPES[(EXPR.TYPEINDEX) - 1].CLS == TTCENUM) {
write_s(&CODEGEN.OUTPUT, str_make(9, "write_e(&"));
write_s(&CODEGEN.OUTPUT, DST);
write_s(&CODEGEN.OUTPUT, str_make(2, ", "));
write_s(&CODEGEN.OUTPUT, EXPR.VALUE);
write_s(&CODEGEN.OUTPUT, str_make(12, ", EnumValues"));
write_i(&CODEGEN.OUTPUT, DEFS.TYPES[(EXPR.TYPEINDEX) - 1].ENUMINDEX);
write_s(&CODEGEN.OUTPUT, str_make(2, ");"));
writeln(&CODEGEN.OUTPUT);
}
 else {
write_s(&CODEGEN.OUTPUT, str_make(6, "write_"));
write_c(&CODEGEN.OUTPUT, SHORTTYPENAME(EXPR.TYPEINDEX));
write_s(&CODEGEN.OUTPUT, str_make(2, "(&"));
write_s(&CODEGEN.OUTPUT, DST);
write_s(&CODEGEN.OUTPUT, str_make(2, ", "));
write_s(&CODEGEN.OUTPUT, EXPR.VALUE);
write_s(&CODEGEN.OUTPUT, str_make(2, ");"));
writeln(&CODEGEN.OUTPUT);
}
}
void OUTWRITELN(PString DST) {
{
write_s(&CODEGEN.OUTPUT, str_make(9, "writeln(&"));
write_s(&CODEGEN.OUTPUT, DST);
write_s(&CODEGEN.OUTPUT, str_make(2, ");"));
writeln(&CODEGEN.OUTPUT);
}
}
void OUTSTR(PString DST, TPSEXPRESSION EXPR) {
EXPR = EVALUATE(EXPR);
if (DEFS.TYPES[(EXPR.TYPEINDEX) - 1].CLS == TTCENUM) {
write_s(&CODEGEN.OUTPUT, DST);
write_s(&CODEGEN.OUTPUT, str_make(12, " = to_str_e("));
write_s(&CODEGEN.OUTPUT, EXPR.VALUE);
write_s(&CODEGEN.OUTPUT, str_make(12, ", EnumValues"));
write_i(&CODEGEN.OUTPUT, DEFS.TYPES[(EXPR.TYPEINDEX) - 1].ENUMINDEX);
write_s(&CODEGEN.OUTPUT, str_make(2, ");"));
writeln(&CODEGEN.OUTPUT);
}
 else {
write_s(&CODEGEN.OUTPUT, DST);
write_s(&CODEGEN.OUTPUT, str_make(10, " = to_str_"));
write_c(&CODEGEN.OUTPUT, SHORTTYPENAME(EXPR.TYPEINDEX));
write_c(&CODEGEN.OUTPUT, '(');
write_s(&CODEGEN.OUTPUT, EXPR.VALUE);
write_s(&CODEGEN.OUTPUT, str_make(2, ");"));
writeln(&CODEGEN.OUTPUT);
}
}
void OUTNEW(TPSEXPRESSION DST) {
{
write_s(&CODEGEN.OUTPUT, DST.VALUE);
write_s(&CODEGEN.OUTPUT, str_make(17, " = malloc(sizeof("));
}
OUTTYPEREFERENCE(DEFS.TYPES[(DST.TYPEINDEX) - 1].POINTEDTYPEINDEX);
{
write_s(&CODEGEN.OUTPUT, str_make(3, "));"));
writeln(&CODEGEN.OUTPUT);
}
}
void OUTDISPOSE(TPSEXPRESSION DST) {
{
write_s(&CODEGEN.OUTPUT, str_make(5, "free("));
write_s(&CODEGEN.OUTPUT, DST.VALUE);
write_s(&CODEGEN.OUTPUT, str_make(2, ");"));
writeln(&CODEGEN.OUTPUT);
}
}
void OUTEXPRESSION(TPSEXPRESSION EXPR) {
{
write_s(&CODEGEN.OUTPUT, EXPR.VALUE);
}
}
void OUTASSIGN(TPSEXPRESSION LHS, TPSEXPRESSION RHS) {
{
write_s(&CODEGEN.OUTPUT, LHS.VALUE);
write_s(&CODEGEN.OUTPUT, str_make(3, " = "));
write_s(&CODEGEN.OUTPUT, RHS.VALUE);
write_c(&CODEGEN.OUTPUT, ';');
writeln(&CODEGEN.OUTPUT);
}
}
void OUTASSIGNRETURNVALUE(TPSEXPRESSION LHS, TPSEXPRESSION RHS) {
{
write_s(&CODEGEN.OUTPUT, str_make(7, "return_"));
write_s(&CODEGEN.OUTPUT, DEFS.FUNCTIONS[(LHS.FUNCTIONINDEX) - 1].NAME);
write_s(&CODEGEN.OUTPUT, str_make(3, " = "));
write_s(&CODEGEN.OUTPUT, RHS.VALUE);
write_c(&CODEGEN.OUTPUT, ';');
writeln(&CODEGEN.OUTPUT);
}
}
void OUTIF(TPSEXPRESSION EXPR) {
{
write_s(&CODEGEN.OUTPUT, str_make(4, "if ("));
write_s(&CODEGEN.OUTPUT, EXPR.VALUE);
write_s(&CODEGEN.OUTPUT, str_make(2, ") "));
}
}
void OUTELSE() {
{
write_s(&CODEGEN.OUTPUT, str_make(6, " else "));
}
}
void OUTREPEATBEGIN() {
{
write_s(&CODEGEN.OUTPUT, str_make(4, "do {"));
writeln(&CODEGEN.OUTPUT);
}
}
void OUTREPEATEND(TPSEXPRESSION EXPR) {
{
write_s(&CODEGEN.OUTPUT, str_make(11, "} while (!("));
write_s(&CODEGEN.OUTPUT, EXPR.VALUE);
write_s(&CODEGEN.OUTPUT, str_make(3, "));"));
writeln(&CODEGEN.OUTPUT);
}
}
void OUTWHILEBEGIN(TPSEXPRESSION EXPR) {
{
write_s(&CODEGEN.OUTPUT, str_make(7, "while ("));
write_s(&CODEGEN.OUTPUT, EXPR.VALUE);
write_s(&CODEGEN.OUTPUT, str_make(2, ") "));
}
}
void OUTWHILEEND() {
}
void OUTFORBEGIN(TPSEXPRESSION ITER, TPSEXPRESSION FIRSTEXPR, TPSEXPRESSION LASTEXPR, PBoolean ASCENDING) {
TPSTYPEINDEX LIMITTYPE;
TPSVARIABLE FIRST;
TPSVARIABLE LAST;
LIMITTYPE = ITER.TYPEINDEX;
if (ISENUMTYPE(LIMITTYPE)) LIMITTYPE = PRIMITIVETYPES.PTINTEGER;
FIRST = MAKEVARIABLE(str_make(5, "first"), LIMITTYPE, 0);
LAST = MAKEVARIABLE(str_make(4, "last"), LIMITTYPE, 0);
{
write_c(&CODEGEN.OUTPUT, '{');
writeln(&CODEGEN.OUTPUT);
}
OUTVARIABLEDECLARATION(FIRST);
{
write_s(&CODEGEN.OUTPUT, str_make(3, " = "));
write_s(&CODEGEN.OUTPUT, FIRSTEXPR.VALUE);
write_c(&CODEGEN.OUTPUT, ';');
writeln(&CODEGEN.OUTPUT);
}
OUTVARIABLEDECLARATION(LAST);
{
write_s(&CODEGEN.OUTPUT, str_make(3, " = "));
write_s(&CODEGEN.OUTPUT, LASTEXPR.VALUE);
write_c(&CODEGEN.OUTPUT, ';');
writeln(&CODEGEN.OUTPUT);
}
{
write_s(&CODEGEN.OUTPUT, str_make(10, "if (first "));
}
if (ASCENDING) {
write_s(&CODEGEN.OUTPUT, str_make(2, "<="));
}
 else {
write_s(&CODEGEN.OUTPUT, str_make(2, ">="));
}
{
write_s(&CODEGEN.OUTPUT, str_make(8, " last) {"));
writeln(&CODEGEN.OUTPUT);
}
{
write_s(&CODEGEN.OUTPUT, ITER.VALUE);
write_s(&CODEGEN.OUTPUT, str_make(9, " = first;"));
writeln(&CODEGEN.OUTPUT);
}
{
write_s(&CODEGEN.OUTPUT, str_make(11, "while (1) {"));
writeln(&CODEGEN.OUTPUT);
}
}
void OUTFOREND(TPSEXPRESSION ITER, PBoolean ASCENDING) {
{
write_s(&CODEGEN.OUTPUT, str_make(4, "if ("));
write_s(&CODEGEN.OUTPUT, ITER.VALUE);
write_s(&CODEGEN.OUTPUT, str_make(16, " == last) break;"));
writeln(&CODEGEN.OUTPUT);
}
if (ASCENDING) {
write_s(&CODEGEN.OUTPUT, str_make(2, "++"));
write_s(&CODEGEN.OUTPUT, ITER.VALUE);
write_c(&CODEGEN.OUTPUT, ';');
writeln(&CODEGEN.OUTPUT);
}
 else {
write_s(&CODEGEN.OUTPUT, str_make(2, "--"));
write_s(&CODEGEN.OUTPUT, ITER.VALUE);
write_c(&CODEGEN.OUTPUT, ';');
}
{
write_c(&CODEGEN.OUTPUT, '}');
writeln(&CODEGEN.OUTPUT);
}
{
write_c(&CODEGEN.OUTPUT, '}');
writeln(&CODEGEN.OUTPUT);
}
{
write_c(&CODEGEN.OUTPUT, '}');
writeln(&CODEGEN.OUTPUT);
}
}
void OUTPROCEDURECALL(TPSEXPRESSION EXPR) {
{
write_s(&CODEGEN.OUTPUT, EXPR.VALUE);
write_c(&CODEGEN.OUTPUT, ';');
writeln(&CODEGEN.OUTPUT);
}
}
void OUTEMPTYSTATEMENT() {
{
write_c(&CODEGEN.OUTPUT, ';');
writeln(&CODEGEN.OUTPUT);
}
}
void OUTPROGRAMBEGIN() {
{
write_s(&CODEGEN.OUTPUT, str_make(21, "void pascual_main() {"));
writeln(&CODEGEN.OUTPUT);
}
}
void OUTPROGRAMEND() {
{
write_c(&CODEGEN.OUTPUT, '}');
writeln(&CODEGEN.OUTPUT);
}
}
void CODEGENRESET() {
CODEGEN.OUTPUT = OUTPUT;
}
void CODEGENSETOUTPUT(PString FILENAME) {
ASSIGN(&CODEGEN.OUTPUT, FILENAME);
REWRITE(&CODEGEN.OUTPUT);
}
void USAGE(PString MSG) {
if (cmp_ss(MSG, str_make(0, "")) != 0) {
write_s(&OUTPUT, MSG);
writeln(&OUTPUT);
}
{
write_s(&OUTPUT, str_make(6, "Usage:"));
writeln(&OUTPUT);
}
{
write_s(&OUTPUT, PARAMSTR(0));
write_s(&OUTPUT, str_make(24, " input.pas [-o output.c]"));
writeln(&OUTPUT);
}
writeln(&OUTPUT);
{
write_s(&OUTPUT, str_make(48, "If you specify \"-\" as the input or output file, "));
write_s(&OUTPUT, str_make(26, "stdin/stdout will be used."));
writeln(&OUTPUT);
}
HALT(0);
}
PString REPLACEEXTENSION(PString STR, PString OLD, PString NEW) {
PString return_REPLACEEXTENSION;
int BASELEN;
int POS;
PBoolean MATCHES;
return_REPLACEEXTENSION = str_make(0, "");
BASELEN = LENGTH(STR) - LENGTH(OLD);
if (BASELEN > 0) {
MATCHES = 1;
{
int first = 1;
int last = LENGTH(OLD);
if (first <= last) {
POS = first;
while (1) {
MATCHES = MATCHES && (cmp_cc(UPCASE(STR.chr[POS + BASELEN]), UPCASE(OLD.chr[POS])) == 0);
if (POS == last) break;
++POS;
}
}
}
if (MATCHES) return_REPLACEEXTENSION = cat_ss(COPY(STR, 1, BASELEN), NEW);
}
return return_REPLACEEXTENSION;
}
void PARSECMDLINE() {
int POS;
PString INPUTFILE;
PString OUTPUTFILE;
enum { FLAGNONE, FLAGOUTPUT} FLAG;
PString PARAM;
const char* EnumValues7[] = { "FLAGNONE", "FLAGOUTPUT" };
INPUTFILE = str_make(0, "");
OUTPUTFILE = str_make(0, "");
FLAG = FLAGNONE;
{
int first = 1;
int last = PARAMCOUNT();
if (first <= last) {
POS = first;
while (1) {
{
PARAM = PARAMSTR(POS);
if ((cmp_cc(PARAM.chr[1], '-') == 0) && (cmp_sc(PARAM, '-') != 0)) {
if (cmp_ss(PARAM, str_make(2, "-o")) == 0) FLAG = FLAGOUTPUT;
 else if (cmp_ss(PARAM, str_make(2, "-h")) == 0) USAGE(str_make(0, ""));
 else USAGE(cat_ss(str_make(16, "Unknown option: "), PARAM));
}
 else if (FLAG == FLAGOUTPUT) {
if (cmp_ss(OUTPUTFILE, str_make(0, "")) != 0) USAGE(str_make(39, "Output file must be specified only once"));
 else OUTPUTFILE = PARAM;
FLAG = FLAGNONE;
}
 else {
if (cmp_ss(INPUTFILE, str_make(0, "")) != 0) USAGE(str_make(38, "Input file must be specified only once"));
 else INPUTFILE = PARAM;
}
}
if (POS == last) break;
++POS;
}
}
}
if (cmp_ss(INPUTFILE, str_make(0, "")) == 0) USAGE(str_make(28, "Input file must be specified"));
if (cmp_ss(OUTPUTFILE, str_make(0, "")) == 0) {
if (cmp_sc(INPUTFILE, '-') == 0) OUTPUTFILE = str_of('-');
 else OUTPUTFILE = REPLACEEXTENSION(INPUTFILE, str_make(4, ".pas"), str_make(2, ".c"));
}
if (cmp_ss(OUTPUTFILE, str_make(0, "")) == 0) USAGE(str_make(29, "Output file must be specified"));
if (cmp_sc(INPUTFILE, '-') != 0) LXOPEN(INPUTFILE);
if (cmp_sc(OUTPUTFILE, '-') != 0) CODEGENSETOUTPUT(OUTPUTFILE);
}
void CLEARSTATE() {
LXRESET();
CODEGENRESET();
}
void pascual_main() {
CLEARSTATE();
PARSECMDLINE();
STARTGLOBALSCOPE();
PARSEPROGRAM();
CLOSE(&LEXER.INPUT.SRC);
CLOSE(&CODEGEN.OUTPUT);
}
