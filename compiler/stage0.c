/* Program: COMPILER */
#include "pascual.h"
typedef enum { TKUNKNOWN, TKEOF, TKCOMMENT, TKIDENTIFIER, TKNUMBER, TKSTRING, TKPLUS, TKMINUS, TKASTERISK, TKSLASH, TKEQUALS, TKLESSTHAN, TKMORETHAN, TKLBRACKET, TKRBRACKET, TKDOT, TKCOMMA, TKCOLON, TKSEMICOLON, TKCARET, TKLPAREN, TKRPAREN, TKNOTEQUALS, TKLESSOREQUALS, TKMOREOREQUALS, TKASSIGN, TKRANGE, TKAND, TKFALSE, TKTRUE, TKARRAY, TKBEGIN, TKCASE, TKCONST, TKDIV, TKDO, TKDOWNTO, TKELSE, TKEND, TKFILE, TKFOR, TKFORWARD, TKFUNCTION, TKGOTO, TKIF, TKIN, TKLABEL, TKMOD, TKNIL, TKNOT, TKOF, TKOR, TKPACKED, TKPROCEDURE, TKPROGRAM, TKRECORD, TKREPEAT, TKSET, TKTHEN, TKTO, TKTYPE, TKUNTIL, TKVAR, TKWHILE, TKWITH} TLXTOKENID;
typedef struct { int ROW; int COL; } TLXPOS;
typedef struct { TLXTOKENID ID; STRING VALUE; TLXPOS POS; } TLXTOKEN;
const char* EnumValues1[] = { "TKUNKNOWN", "TKEOF", "TKCOMMENT", "TKIDENTIFIER", "TKNUMBER", "TKSTRING", "TKPLUS", "TKMINUS", "TKASTERISK", "TKSLASH", "TKEQUALS", "TKLESSTHAN", "TKMORETHAN", "TKLBRACKET", "TKRBRACKET", "TKDOT", "TKCOMMA", "TKCOLON", "TKSEMICOLON", "TKCARET", "TKLPAREN", "TKRPAREN", "TKNOTEQUALS", "TKLESSOREQUALS", "TKMOREOREQUALS", "TKASSIGN", "TKRANGE", "TKAND", "TKFALSE", "TKTRUE", "TKARRAY", "TKBEGIN", "TKCASE", "TKCONST", "TKDIV", "TKDO", "TKDOWNTO", "TKELSE", "TKEND", "TKFILE", "TKFOR", "TKFORWARD", "TKFUNCTION", "TKGOTO", "TKIF", "TKIN", "TKLABEL", "TKMOD", "TKNIL", "TKNOT", "TKOF", "TKOR", "TKPACKED", "TKPROCEDURE", "TKPROGRAM", "TKRECORD", "TKREPEAT", "TKSET", "TKTHEN", "TKTO", "TKTYPE", "TKUNTIL", "TKVAR", "TKWHILE", "TKWITH" };
struct { STRING LINE; TLXTOKEN TOKEN; TLXPOS POS; PFile INPUT; } LEXER;
struct { PFile OUTPUT; } CODEGEN;
STRING LXPOSSTR(TLXPOS POS) {
STRING return_LXPOSSTR;
STRING ROW;
STRING COL;
ROW = to_str_i(POS.ROW);
COL = to_str_i(POS.COL);
return_LXPOSSTR = cat_ss(cat_ss(cat_ss(str_make(4, "row "), ROW), str_make(5, " col ")), COL);
return return_LXPOSSTR;
}
STRING LXWHERESTR() {
STRING return_LXWHERESTR;
return_LXWHERESTR = cat_ss(str_make(6, " near "), LXPOSSTR(LEXER.TOKEN.POS));
return return_LXWHERESTR;
}
STRING LXTOKENSTR() {
STRING return_LXTOKENSTR;
STRING ID;
ID = to_str_e(LEXER.TOKEN.ID, EnumValues1);
return_LXTOKENSTR = cat_sc(cat_ss(cat_ss(ID, str_make(2, " [")), LEXER.TOKEN.VALUE), ']');
return return_LXTOKENSTR;
}
PBoolean LXISALPHA(char CHR) {
PBoolean return_LXISALPHA;
return_LXISALPHA = ((cmp_cc(CHR, 'a') >= 0) && (cmp_cc(CHR, 'z') <= 0)) || ((cmp_cc(CHR, 'A') >= 0) && (cmp_cc(CHR, 'Z') <= 0));
return return_LXISALPHA;
}
PBoolean LXISDIGIT(char CHR) {
PBoolean return_LXISDIGIT;
return_LXISDIGIT = (cmp_cc(CHR, '0') >= 0) && (cmp_cc(CHR, '9') <= 0);
return return_LXISDIGIT;
}
PBoolean LXISALPHANUM(char CHR) {
PBoolean return_LXISALPHANUM;
return_LXISALPHANUM = LXISALPHA(CHR) || LXISDIGIT(CHR);
return return_LXISALPHANUM;
}
PBoolean LXISTOKENWAITING() {
PBoolean return_LXISTOKENWAITING;
do {
while ((LENGTH(LEXER.LINE) == 0) && !EOF(&LEXER.INPUT)) {
LEXER.POS.ROW = LEXER.POS.ROW + 1;
LEXER.POS.COL = 1;
{
read_s(LEXER.INPUT, &LEXER.LINE);
readln(LEXER.INPUT);
}
}
while ((LENGTH(LEXER.LINE) > 0) && (cmp_cc(LEXER.LINE.chr[1], ' ') == 0)) {
LEXER.POS.COL = LEXER.POS.COL + 1;
DELETE(&LEXER.LINE, 1, 1);
}
} while (!(EOF(&LEXER.INPUT) || (LENGTH(LEXER.LINE) > 0)));
return_LXISTOKENWAITING = LENGTH(LEXER.LINE) > 0;
return return_LXISTOKENWAITING;
}
void LXGETSYMBOL(TLXTOKENID ID, int LENGTH) {
LEXER.TOKEN.ID = ID;
LEXER.TOKEN.VALUE = COPY(LEXER.LINE, 1, LENGTH);
LEXER.TOKEN.POS = LEXER.POS;
DELETE(&LEXER.LINE, 1, LENGTH);
LEXER.POS.COL = LEXER.POS.COL + LENGTH;
}
void LXGETIDENTIFIER() {
char CHR;
int POS;
PBoolean INTOKEN;
POS = 0;
INTOKEN = 1;
while ((POS < LENGTH(LEXER.LINE)) && INTOKEN) {
CHR = LEXER.LINE.chr[POS + 1];
INTOKEN = LXISALPHANUM(CHR);
if (INTOKEN) POS = POS + 1;
}
LXGETSYMBOL(TKIDENTIFIER, POS);
{
int first = 1;
int last = LENGTH(LEXER.TOKEN.VALUE);
if (first <= last) {
POS = first;
while (1) {
LEXER.TOKEN.VALUE.chr[POS] = UPCASE(LEXER.TOKEN.VALUE.chr[POS]);
if (POS == last) break;
++POS;
}
}
}
if (cmp_ss(LEXER.TOKEN.VALUE, str_make(3, "AND")) == 0) LEXER.TOKEN.ID = TKAND;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(5, "ARRAY")) == 0) LEXER.TOKEN.ID = TKARRAY;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(5, "BEGIN")) == 0) LEXER.TOKEN.ID = TKBEGIN;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(4, "CASE")) == 0) LEXER.TOKEN.ID = TKCASE;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(5, "CONST")) == 0) LEXER.TOKEN.ID = TKCONST;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(3, "DIV")) == 0) LEXER.TOKEN.ID = TKDIV;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(2, "DO")) == 0) LEXER.TOKEN.ID = TKDO;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(6, "DOWNTO")) == 0) LEXER.TOKEN.ID = TKDOWNTO;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(4, "ELSE")) == 0) LEXER.TOKEN.ID = TKELSE;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(3, "END")) == 0) LEXER.TOKEN.ID = TKEND;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(4, "FILE")) == 0) LEXER.TOKEN.ID = TKFILE;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(3, "FOR")) == 0) LEXER.TOKEN.ID = TKFOR;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(7, "FORWARD")) == 0) LEXER.TOKEN.ID = TKFORWARD;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(8, "FUNCTION")) == 0) LEXER.TOKEN.ID = TKFUNCTION;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(4, "GOTO")) == 0) LEXER.TOKEN.ID = TKGOTO;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(2, "IF")) == 0) LEXER.TOKEN.ID = TKIF;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(2, "IN")) == 0) LEXER.TOKEN.ID = TKIN;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(5, "LABEL")) == 0) LEXER.TOKEN.ID = TKLABEL;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(3, "MOD")) == 0) LEXER.TOKEN.ID = TKMOD;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(3, "NIL")) == 0) LEXER.TOKEN.ID = TKNIL;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(3, "NOT")) == 0) LEXER.TOKEN.ID = TKNOT;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(2, "OF")) == 0) LEXER.TOKEN.ID = TKOF;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(2, "OR")) == 0) LEXER.TOKEN.ID = TKOR;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(6, "PACKED")) == 0) LEXER.TOKEN.ID = TKPACKED;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(9, "PROCEDURE")) == 0) LEXER.TOKEN.ID = TKPROCEDURE;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(7, "PROGRAM")) == 0) LEXER.TOKEN.ID = TKPROGRAM;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(6, "RECORD")) == 0) LEXER.TOKEN.ID = TKRECORD;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(6, "REPEAT")) == 0) LEXER.TOKEN.ID = TKREPEAT;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(3, "SET")) == 0) LEXER.TOKEN.ID = TKSET;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(4, "THEN")) == 0) LEXER.TOKEN.ID = TKTHEN;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(2, "TO")) == 0) LEXER.TOKEN.ID = TKTO;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(4, "TYPE")) == 0) LEXER.TOKEN.ID = TKTYPE;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(5, "UNTIL")) == 0) LEXER.TOKEN.ID = TKUNTIL;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(3, "VAR")) == 0) LEXER.TOKEN.ID = TKVAR;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(5, "WHILE")) == 0) LEXER.TOKEN.ID = TKWHILE;
 else if (cmp_ss(LEXER.TOKEN.VALUE, str_make(4, "WITH")) == 0) LEXER.TOKEN.ID = TKWITH;
}
void LXGETNUMBER() {
char CHR;
int POS;
PBoolean INTOKEN;
POS = 0;
INTOKEN = 1;
while ((POS < LENGTH(LEXER.LINE)) && INTOKEN) {
CHR = LEXER.LINE.chr[POS + 1];
INTOKEN = LXISDIGIT(CHR);
if (INTOKEN) POS = POS + 1;
}
LXGETSYMBOL(TKNUMBER, POS);
}
void LXGETSTRING() {
char CHR;
int POS;
PBoolean INSTRING;
POS = 1;
INSTRING = 1;
while (INSTRING) {
POS = POS + 1;
CHR = LEXER.LINE.chr[POS];
if (cmp_cc(CHR, '\'') == 0) {
if ((LENGTH(LEXER.LINE) > POS + 1) && (cmp_cc(LEXER.LINE.chr[POS + 1], '\'') == 0)) POS = POS + 1;
 else INSTRING = 0;
}
}
LXGETSYMBOL(TKSTRING, POS);
}
void LXGETCOMMENT() {
char CHR;
PBoolean SHORTCOMMENT;
char DELIM;
PBoolean CANEND;
CHR = LEXER.LINE.chr[1];
SHORTCOMMENT = cmp_cc(CHR, '{') == 0;
if (SHORTCOMMENT) {
DELIM = '}';
LXGETSYMBOL(TKCOMMENT, 1);
}
 else {
DELIM = ')';
LXGETSYMBOL(TKCOMMENT, 2);
}
do {
if (!LXISTOKENWAITING()) {
{
write_s(STDERR, str_make(22, "End of file in comment"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
CANEND = SHORTCOMMENT || (cmp_cc(CHR, '*') == 0);
CHR = LEXER.LINE.chr[1];
DELETE(&LEXER.LINE, 1, 1);
LEXER.POS.COL = LEXER.POS.COL + 1;
} while (!(CANEND && (cmp_cc(CHR, DELIM) == 0)));
LEXER.TOKEN.VALUE = str_make(0, "");
}
void LXREADTOKEN() {
char CHR;
char NXT;
LEXER.TOKEN.VALUE = str_make(0, "");
LEXER.TOKEN.ID = TKUNKNOWN;
if (!LXISTOKENWAITING()) LEXER.TOKEN.ID = TKEOF;
 else {
CHR = LEXER.LINE.chr[1];
if (LXISALPHA(CHR)) LXGETIDENTIFIER();
if ((LEXER.TOKEN.ID == TKUNKNOWN) && LXISDIGIT(CHR)) LXGETNUMBER();
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '\'') == 0)) LXGETSTRING();
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (LENGTH(LEXER.LINE) > 1)) {
NXT = LEXER.LINE.chr[2];
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '<') == 0) && (cmp_cc(NXT, '>') == 0)) LXGETSYMBOL(TKNOTEQUALS, 2);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '<') == 0) && (cmp_cc(NXT, '=') == 0)) LXGETSYMBOL(TKLESSOREQUALS, 2);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '>') == 0) && (cmp_cc(NXT, '=') == 0)) LXGETSYMBOL(TKMOREOREQUALS, 2);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, ':') == 0) && (cmp_cc(NXT, '=') == 0)) LXGETSYMBOL(TKASSIGN, 2);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '.') == 0) && (cmp_cc(NXT, '.') == 0)) LXGETSYMBOL(TKRANGE, 2);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '(') == 0) && (cmp_cc(NXT, '*') == 0)) LXGETCOMMENT();
}
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '+') == 0)) LXGETSYMBOL(TKPLUS, 1);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '-') == 0)) LXGETSYMBOL(TKMINUS, 1);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '*') == 0)) LXGETSYMBOL(TKASTERISK, 1);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '/') == 0)) LXGETSYMBOL(TKSLASH, 1);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '=') == 0)) LXGETSYMBOL(TKEQUALS, 1);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '<') == 0)) LXGETSYMBOL(TKLESSTHAN, 1);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '>') == 0)) LXGETSYMBOL(TKMORETHAN, 1);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '[') == 0)) LXGETSYMBOL(TKLBRACKET, 1);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, ']') == 0)) LXGETSYMBOL(TKRBRACKET, 1);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '.') == 0)) LXGETSYMBOL(TKDOT, 1);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, ',') == 0)) LXGETSYMBOL(TKCOMMA, 1);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, ':') == 0)) LXGETSYMBOL(TKCOLON, 1);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, ';') == 0)) LXGETSYMBOL(TKSEMICOLON, 1);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '^') == 0)) LXGETSYMBOL(TKCARET, 1);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '(') == 0)) LXGETSYMBOL(TKLPAREN, 1);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, ')') == 0)) LXGETSYMBOL(TKRPAREN, 1);
if ((LEXER.TOKEN.ID == TKUNKNOWN) && (cmp_cc(CHR, '{') == 0)) LXGETCOMMENT();
if (LEXER.TOKEN.ID == TKUNKNOWN) {
{
write_s(STDERR, str_make(17, "Could not parse ["));
write_s(STDERR, LEXER.LINE);
write_s(STDERR, str_make(5, "] at "));
write_s(STDERR, LXPOSSTR(LEXER.POS));
writeln(STDERR);
}
HALT(1);
}
}
}
void READTOKEN();
void WANTTOKEN(TLXTOKENID ID) {
if (LEXER.TOKEN.ID != ID) {
{
write_s(STDERR, str_make(13, "Wanted token "));
write_e(STDERR, ID, EnumValues1);
write_s(STDERR, str_make(8, ", found "));
write_s(STDERR, LXTOKENSTR());
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
void WANTTOKEN2(TLXTOKENID ID1, TLXTOKENID ID2) {
if ((LEXER.TOKEN.ID != ID1) && (LEXER.TOKEN.ID != ID2)) {
{
write_s(STDERR, str_make(13, "Wanted token "));
write_e(STDERR, ID1, EnumValues1);
write_s(STDERR, str_make(4, " or "));
write_e(STDERR, ID2, EnumValues1);
write_s(STDERR, str_make(8, ", found "));
write_s(STDERR, LXTOKENSTR());
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
void WANTTOKENANDREAD(TLXTOKENID ID) {
WANTTOKEN(ID);
READTOKEN();
}
STRING GETTOKENVALUEANDREAD(TLXTOKENID ID) {
STRING return_GETTOKENVALUEANDREAD;
WANTTOKEN(ID);
return_GETTOKENVALUEANDREAD = LEXER.TOKEN.VALUE;
READTOKEN();
return return_GETTOKENVALUEANDREAD;
}
void SKIPTOKEN(TLXTOKENID ID) {
if (LEXER.TOKEN.ID == ID) READTOKEN();
}
typedef int TPSENUMINDEX;
typedef int TPSRECORDINDEX;
typedef int TPSARRAYINDEX;
typedef int TPSTYPEINDEX;
typedef enum { TTCBOOLEAN, TTCINTEGER, TTCCHAR, TTCSTRING, TTCTEXT, TTCENUM, TTCRECORD, TTCARRAY} TPSTYPECLASS;
typedef struct { STRING NAME; TPSTYPECLASS CLS; TPSENUMINDEX ENUMINDEX; TPSRECORDINDEX RECORDINDEX; TPSARRAYINDEX ARRAYINDEX; TPSTYPEINDEX ALIASFOR; } TPSTYPE;
typedef struct { int SIZE; STRING VALUES[1 + 128 - 1]; } TPSENUMDEF;
typedef struct { STRING NAME; TPSTYPEINDEX TYPEINDEX; } TPSRECORDFIELD;
typedef struct { int SIZE; TPSRECORDFIELD FIELDS[1 + 16 - 1]; } TPSRECORDDEF;
typedef struct { STRING LOWBOUND; STRING HIGHBOUND; TPSTYPEINDEX TYPEINDEX; } TPSARRAYDEF;
typedef int TPSCONSTANTINDEX;
typedef struct { STRING NAME; TLXTOKEN REPLACEMENT; } TPSCONSTANT;
typedef int TPSVARIABLEINDEX;
typedef struct { STRING NAME; TPSTYPEINDEX TYPEINDEX; PBoolean ISREFERENCE; PBoolean ISCONSTANT; } TPSVARIABLE;
typedef int TPSFUNCTIONINDEX;
typedef struct { STRING NAME; int ARGCOUNT; TPSVARIABLE ARGS[1 + 4 - 1]; TPSTYPEINDEX RETURNTYPEINDEX; PBoolean ISDECLARATION; } TPSFUNCTION;
typedef struct { int NUMTYPES; int NUMENUMS; int NUMRECORDS; int NUMARRAYS; int NUMCONSTANTS; int NUMVARIABLES; int NUMFUNCTIONS; } TPSSCOPE;
typedef struct { TPSSCOPE SCOPE; TPSTYPE TYPES[1 + 64 - 1]; TPSENUMDEF ENUMS[1 + 16 - 1]; TPSRECORDDEF RECORDS[1 + 32 - 1]; TPSARRAYDEF ARRAYS[1 + 32 - 1]; TPSCONSTANT CONSTANTS[1 + 32 - 1]; TPSVARIABLE VARIABLES[1 + 32 - 1]; TPSFUNCTION FUNCTIONS[1 + 256 - 1]; } TPSDEFS;
typedef enum { IDCVARIABLE, IDCFUNCTION, IDCREAD, IDCREADLN, IDCWRITE, IDCWRITELN, IDCSTR} TPSIDCLASS;
typedef struct { STRING NAME; } TPSIDENTIFIER;
typedef enum { TECVALUE, TECFUNCTION, TECSTATEMENT} TPSEXPRESSIONCLASS;
typedef struct { STRING VALUE; TPSEXPRESSIONCLASS CLS; PBoolean ISCONSTANT; TPSTYPEINDEX TYPEINDEX; TPSFUNCTIONINDEX FUNCTIONINDEX; } TPSEXPRESSION;
const char* EnumValues2[] = { "TTCBOOLEAN", "TTCINTEGER", "TTCCHAR", "TTCSTRING", "TTCTEXT", "TTCENUM", "TTCRECORD", "TTCARRAY" };
const char* EnumValues3[] = { "IDCVARIABLE", "IDCFUNCTION", "IDCREAD", "IDCREADLN", "IDCWRITE", "IDCWRITELN", "IDCSTR" };
const char* EnumValues4[] = { "TECVALUE", "TECFUNCTION", "TECSTATEMENT" };
TPSDEFS DEFS;
struct { TPSTYPEINDEX PTBOOLEAN; TPSTYPEINDEX PTINTEGER; TPSTYPEINDEX PTCHAR; TPSTYPEINDEX PTSTRING; TPSTYPEINDEX PTTEXT; } PRIMITIVETYPES;
TPSSCOPE GLOBALSCOPE;
void CLEARDEFS() {
DEFS.SCOPE.NUMTYPES = 0;
DEFS.SCOPE.NUMENUMS = 0;
DEFS.SCOPE.NUMRECORDS = 0;
DEFS.SCOPE.NUMARRAYS = 0;
DEFS.SCOPE.NUMCONSTANTS = 0;
DEFS.SCOPE.NUMVARIABLES = 0;
DEFS.SCOPE.NUMFUNCTIONS = 0;
}
TPSSCOPE GETCURRENTSCOPE() {
TPSSCOPE return_GETCURRENTSCOPE;
return_GETCURRENTSCOPE = DEFS.SCOPE;
return return_GETCURRENTSCOPE;
}
void SETCURRENTSCOPE(TPSSCOPE SCOPE) {
DEFS.SCOPE = SCOPE;
}
STRING DEEPTYPENAME(TPSTYPEINDEX TYPEINDEX, PBoolean USEORIGINAL) {
STRING return_DEEPTYPENAME;
TPSTYPE TYP;
STRING RET;
int POS;
do {
TYP = DEFS.TYPES[(TYPEINDEX) - 1];
TYPEINDEX = TYP.ALIASFOR;
} while (!(!USEORIGINAL || (TYPEINDEX == 0)));
if (cmp_ss(TYP.NAME, str_make(0, "")) != 0) return_DEEPTYPENAME = TYP.NAME;
 else if (TYP.CLS == TTCENUM) {
RET = str_of('(');
{
int first = 1;
int last = DEFS.ENUMS[(TYP.ENUMINDEX) - 1].SIZE;
if (first <= last) {
POS = first;
while (1) {
{
if (POS != 1) RET = cat_sc(RET, ',');
RET = cat_ss(RET, DEFS.ENUMS[(TYP.ENUMINDEX) - 1].VALUES[(POS) - 1]);
}
if (POS == last) break;
++POS;
}
}
}
return_DEEPTYPENAME = cat_sc(RET, ')');
}
 else if (TYP.CLS == TTCRECORD) {
RET = str_make(7, "record ");
{
int first = 1;
int last = DEFS.RECORDS[(TYP.RECORDINDEX) - 1].SIZE;
if (first <= last) {
POS = first;
while (1) {
{
if (POS != 1) RET = cat_sc(RET, ',');
RET = cat_ss(RET, DEEPTYPENAME(DEFS.RECORDS[(TYP.RECORDINDEX) - 1].FIELDS[(POS) - 1].TYPEINDEX, 1));
RET = cat_ss(cat_sc(RET, ':'), DEFS.RECORDS[(TYP.RECORDINDEX) - 1].FIELDS[(POS) - 1].NAME);
}
if (POS == last) break;
++POS;
}
}
}
return_DEEPTYPENAME = cat_ss(RET, str_make(4, " end"));
}
 else if (TYP.CLS == TTCARRAY) {
RET = cat_ss(str_make(7, "array ["), DEFS.ARRAYS[(TYP.ARRAYINDEX) - 1].LOWBOUND);
RET = cat_ss(cat_ss(RET, str_make(2, "..")), DEFS.ARRAYS[(TYP.ARRAYINDEX) - 1].HIGHBOUND);
RET = cat_ss(cat_ss(RET, str_make(5, "] of ")), DEEPTYPENAME(DEFS.ARRAYS[(TYP.ARRAYINDEX) - 1].TYPEINDEX, 1));
return_DEEPTYPENAME = RET;
}
 else {
{
write_s(STDERR, str_make(37, "Could not get name for type of class "));
write_e(STDERR, TYP.CLS, EnumValues2);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
return return_DEEPTYPENAME;
}
STRING TYPENAME(TPSTYPEINDEX TYPEINDEX) {
STRING return_TYPENAME;
return_TYPENAME = DEEPTYPENAME(TYPEINDEX, 0);
return return_TYPENAME;
}
TPSTYPE EMPTYTYPE() {
TPSTYPE return_EMPTYTYPE;
TPSTYPE RET;
RET.NAME = str_make(0, "");
RET.CLS = TTCBOOLEAN;
RET.ENUMINDEX = 0;
RET.RECORDINDEX = 0;
RET.ALIASFOR = 0;
return_EMPTYTYPE = RET;
return return_EMPTYTYPE;
}
TPSTYPE TYPEOFCLASS(TPSTYPECLASS CLS) {
TPSTYPE return_TYPEOFCLASS;
TPSTYPE RET;
RET = EMPTYTYPE();
RET.CLS = CLS;
return_TYPEOFCLASS = RET;
return return_TYPEOFCLASS;
}
PBoolean TYPEHASCLASS(TPSTYPEINDEX TYPEINDEX, TPSTYPECLASS CLS) {
PBoolean return_TYPEHASCLASS;
return_TYPEHASCLASS = DEFS.TYPES[(TYPEINDEX) - 1].CLS == CLS;
return return_TYPEHASCLASS;
}
TPSTYPE INTEGERTYPE() {
TPSTYPE return_INTEGERTYPE;
return_INTEGERTYPE = TYPEOFCLASS(TTCINTEGER);
return return_INTEGERTYPE;
}
PBoolean ISINTEGERTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISINTEGERTYPE;
return_ISINTEGERTYPE = TYPEHASCLASS(TYPEINDEX, TTCINTEGER);
return return_ISINTEGERTYPE;
}
TPSTYPE STRINGTYPE() {
TPSTYPE return_STRINGTYPE;
return_STRINGTYPE = TYPEOFCLASS(TTCSTRING);
return return_STRINGTYPE;
}
TPSTYPE CHARTYPE() {
TPSTYPE return_CHARTYPE;
return_CHARTYPE = TYPEOFCLASS(TTCCHAR);
return return_CHARTYPE;
}
PBoolean ISSTRINGTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISSTRINGTYPE;
return_ISSTRINGTYPE = TYPEHASCLASS(TYPEINDEX, TTCSTRING);
return return_ISSTRINGTYPE;
}
PBoolean ISCHARTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISCHARTYPE;
return_ISCHARTYPE = TYPEHASCLASS(TYPEINDEX, TTCCHAR);
return return_ISCHARTYPE;
}
PBoolean ISSTRINGYTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISSTRINGYTYPE;
return_ISSTRINGYTYPE = ISSTRINGTYPE(TYPEINDEX) || ISCHARTYPE(TYPEINDEX);
return return_ISSTRINGYTYPE;
}
TPSTYPE BOOLEANTYPE() {
TPSTYPE return_BOOLEANTYPE;
return_BOOLEANTYPE = TYPEOFCLASS(TTCBOOLEAN);
return return_BOOLEANTYPE;
}
PBoolean ISBOOLEANTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISBOOLEANTYPE;
return_ISBOOLEANTYPE = TYPEHASCLASS(TYPEINDEX, TTCBOOLEAN);
return return_ISBOOLEANTYPE;
}
TPSTYPE TEXTTYPE() {
TPSTYPE return_TEXTTYPE;
return_TEXTTYPE = TYPEOFCLASS(TTCTEXT);
return return_TEXTTYPE;
}
PBoolean ISTEXTTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISTEXTTYPE;
return_ISTEXTTYPE = TYPEHASCLASS(TYPEINDEX, TTCTEXT);
return return_ISTEXTTYPE;
}
PBoolean ISENUMTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISENUMTYPE;
return_ISENUMTYPE = TYPEHASCLASS(TYPEINDEX, TTCENUM);
return return_ISENUMTYPE;
}
PBoolean ISRECORDTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISRECORDTYPE;
return_ISRECORDTYPE = TYPEHASCLASS(TYPEINDEX, TTCRECORD);
return return_ISRECORDTYPE;
}
PBoolean ISARRAYTYPE(TPSTYPEINDEX TYPEINDEX) {
PBoolean return_ISARRAYTYPE;
return_ISARRAYTYPE = TYPEHASCLASS(TYPEINDEX, TTCARRAY);
return return_ISARRAYTYPE;
}
PBoolean ISSAMETYPE(TPSTYPEINDEX AINDEX, TPSTYPEINDEX BINDEX) {
PBoolean return_ISSAMETYPE;
TPSTYPE A;
TPSTYPE B;
A = DEFS.TYPES[(AINDEX) - 1];
B = DEFS.TYPES[(BINDEX) - 1];
return_ISSAMETYPE = (A.CLS == B.CLS) && (A.ENUMINDEX == B.ENUMINDEX) && (A.RECORDINDEX == B.RECORDINDEX);
return return_ISSAMETYPE;
}
TPSTYPEINDEX FINDTYPE(STRING NAME) {
TPSTYPEINDEX return_FINDTYPE;
int POS;
TPSTYPEINDEX RET;
RET = 0;
{
int first = 1;
int last = DEFS.SCOPE.NUMTYPES;
if (first <= last) {
POS = first;
while (1) {
if (cmp_ss(NAME, DEFS.TYPES[(POS) - 1].NAME) == 0) RET = POS;
if (POS == last) break;
++POS;
}
}
}
return_FINDTYPE = RET;
return return_FINDTYPE;
}
TPSTYPEINDEX ADDTYPE(TPSTYPE TYP, TPSSCOPE SCOPE) {
TPSTYPEINDEX return_ADDTYPE;
int POS;
if (cmp_ss(TYP.NAME, str_make(0, "")) != 0) {
POS = FINDTYPE(TYP.NAME);
if (POS > SCOPE.NUMTYPES) {
{
write_s(STDERR, str_make(9, "Variable "));
write_s(STDERR, TYP.NAME);
write_s(STDERR, str_make(20, " already defined as "));
write_s(STDERR, TYPENAME(POS));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
POS = DEFS.SCOPE.NUMTYPES + 1;
if (POS > 64) {
{
write_s(STDERR, str_make(32, "Too many types have been defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
DEFS.TYPES[(POS) - 1] = TYP;
DEFS.SCOPE.NUMTYPES = POS;
return_ADDTYPE = POS;
return return_ADDTYPE;
}
TPSTYPEINDEX FINDTYPEOFENUMVALUE(STRING NAME) {
TPSTYPEINDEX return_FINDTYPEOFENUMVALUE;
TPSTYPEINDEX POS;
int ENUMPOS;
return_FINDTYPEOFENUMVALUE = 0;
{
TPSTYPEINDEX first = 1;
TPSTYPEINDEX last = DEFS.SCOPE.NUMTYPES;
if (first <= last) {
POS = first;
while (1) {
if (DEFS.TYPES[(POS) - 1].ENUMINDEX != 0) {
int first = 1;
int last = DEFS.ENUMS[(DEFS.TYPES[(POS) - 1].ENUMINDEX) - 1].SIZE;
if (first <= last) {
ENUMPOS = first;
while (1) {
if (cmp_ss(NAME, DEFS.ENUMS[(DEFS.TYPES[(POS) - 1].ENUMINDEX) - 1].VALUES[(ENUMPOS) - 1]) == 0) return_FINDTYPEOFENUMVALUE = POS;
if (ENUMPOS == last) break;
++ENUMPOS;
}
}
}
if (POS == last) break;
++POS;
}
}
}
return return_FINDTYPEOFENUMVALUE;
}
TPSENUMINDEX ADDENUM(TPSENUMDEF ENUM) {
TPSENUMINDEX return_ADDENUM;
DEFS.SCOPE.NUMENUMS = DEFS.SCOPE.NUMENUMS + 1;
if (DEFS.SCOPE.NUMENUMS > 16) {
{
write_s(STDERR, str_make(32, "Too many enums have been defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
DEFS.ENUMS[(DEFS.SCOPE.NUMENUMS) - 1] = ENUM;
return_ADDENUM = DEFS.SCOPE.NUMENUMS;
return return_ADDENUM;
}
TPSRECORDINDEX ADDRECORD(TPSRECORDDEF REC) {
TPSRECORDINDEX return_ADDRECORD;
DEFS.SCOPE.NUMRECORDS = DEFS.SCOPE.NUMRECORDS + 1;
if (DEFS.SCOPE.NUMRECORDS > 32) {
{
write_s(STDERR, str_make(34, "Too many records have been defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
DEFS.RECORDS[(DEFS.SCOPE.NUMRECORDS) - 1] = REC;
return_ADDRECORD = DEFS.SCOPE.NUMRECORDS;
return return_ADDRECORD;
}
TPSARRAYINDEX ADDARRAY(TPSARRAYDEF ARR) {
TPSARRAYINDEX return_ADDARRAY;
DEFS.SCOPE.NUMARRAYS = DEFS.SCOPE.NUMARRAYS + 1;
if (DEFS.SCOPE.NUMARRAYS > 32) {
{
write_s(STDERR, str_make(33, "Too many arrays have been defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
DEFS.ARRAYS[(DEFS.SCOPE.NUMARRAYS) - 1] = ARR;
return_ADDARRAY = DEFS.SCOPE.NUMARRAYS;
return return_ADDARRAY;
}
TPSCONSTANTINDEX FINDCONSTANT(STRING NAME) {
TPSCONSTANTINDEX return_FINDCONSTANT;
int POS;
TPSCONSTANTINDEX RET;
RET = 0;
{
int first = 1;
int last = DEFS.SCOPE.NUMCONSTANTS;
if (first <= last) {
POS = first;
while (1) {
if (cmp_ss(NAME, DEFS.CONSTANTS[(POS) - 1].NAME) == 0) RET = POS;
if (POS == last) break;
++POS;
}
}
}
return_FINDCONSTANT = RET;
return return_FINDCONSTANT;
}
TPSCONSTANTINDEX ADDCONSTANT(TPSCONSTANT CONSTANT, TPSSCOPE SCOPE) {
TPSCONSTANTINDEX return_ADDCONSTANT;
int POS;
if (cmp_ss(CONSTANT.NAME, str_make(0, "")) != 0) {
POS = FINDCONSTANT(CONSTANT.NAME);
if (POS > SCOPE.NUMCONSTANTS) {
{
write_s(STDERR, str_make(9, "Constant "));
write_s(STDERR, CONSTANT.NAME);
write_s(STDERR, str_make(16, " already defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
POS = DEFS.SCOPE.NUMCONSTANTS + 1;
if (POS > 32) {
{
write_s(STDERR, str_make(36, "Too many constants have been defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
DEFS.CONSTANTS[(POS) - 1] = CONSTANT;
DEFS.SCOPE.NUMCONSTANTS = POS;
return_ADDCONSTANT = POS;
return return_ADDCONSTANT;
}
TPSVARIABLEINDEX FINDVARIABLE(STRING NAME) {
TPSVARIABLEINDEX return_FINDVARIABLE;
int POS;
TPSVARIABLEINDEX RET;
RET = 0;
{
int first = 1;
int last = DEFS.SCOPE.NUMVARIABLES;
if (first <= last) {
POS = first;
while (1) {
if (cmp_ss(NAME, DEFS.VARIABLES[(POS) - 1].NAME) == 0) RET = POS;
if (POS == last) break;
++POS;
}
}
}
return_FINDVARIABLE = RET;
return return_FINDVARIABLE;
}
TPSVARIABLEINDEX ADDVARIABLE(TPSVARIABLE VARDEF, TPSSCOPE SCOPE) {
TPSVARIABLEINDEX return_ADDVARIABLE;
int POS;
if (cmp_ss(VARDEF.NAME, str_make(0, "")) != 0) {
POS = FINDVARIABLE(VARDEF.NAME);
if (POS > SCOPE.NUMVARIABLES) {
{
write_s(STDERR, str_make(9, "Variable "));
write_s(STDERR, VARDEF.NAME);
write_s(STDERR, str_make(20, " already defined as "));
write_s(STDERR, TYPENAME(DEFS.VARIABLES[(POS) - 1].TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
POS = DEFS.SCOPE.NUMVARIABLES + 1;
if (POS > 32) {
{
write_s(STDERR, str_make(36, "Too many variables have been defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
DEFS.VARIABLES[(POS) - 1] = VARDEF;
DEFS.SCOPE.NUMVARIABLES = POS;
return_ADDVARIABLE = POS;
return return_ADDVARIABLE;
}
TPSFUNCTION EMPTYFUNCTION() {
TPSFUNCTION return_EMPTYFUNCTION;
TPSFUNCTION RET;
RET.NAME = str_make(0, "");
RET.ARGCOUNT = 0;
RET.RETURNTYPEINDEX = 0;
RET.ISDECLARATION = 0;
return_EMPTYFUNCTION = RET;
return return_EMPTYFUNCTION;
}
PBoolean ISEMPTYFUNCTION(TPSFUNCTION FN) {
PBoolean return_ISEMPTYFUNCTION;
return_ISEMPTYFUNCTION = cmp_ss(FN.NAME, str_make(0, "")) == 0;
return return_ISEMPTYFUNCTION;
}
TPSFUNCTIONINDEX FINDFUNCTION(STRING NAME) {
TPSFUNCTIONINDEX return_FINDFUNCTION;
int POS;
return_FINDFUNCTION = 0;
{
int first = 1;
int last = DEFS.SCOPE.NUMFUNCTIONS;
if (first <= last) {
POS = first;
while (1) {
{
if (cmp_ss(DEFS.FUNCTIONS[(POS) - 1].NAME, NAME) == 0) return_FINDFUNCTION = POS;
}
if (POS == last) break;
++POS;
}
}
}
return return_FINDFUNCTION;
}
PBoolean ISSAMEFUNCTIONDEFINITION(TPSFUNCTIONINDEX DECLINDEX, TPSFUNCTION FUN) {
PBoolean return_ISSAMEFUNCTIONDEFINITION;
TPSFUNCTION DECL;
PBoolean SAME;
int POS;
DECL = DEFS.FUNCTIONS[(DECLINDEX) - 1];
SAME = ISSAMETYPE(DECL.RETURNTYPEINDEX, FUN.RETURNTYPEINDEX) && (DECL.ARGCOUNT == FUN.ARGCOUNT);
{
int first = 1;
int last = DECL.ARGCOUNT;
if (first <= last) {
POS = first;
while (1) {
SAME = SAME && ISSAMETYPE(DECL.ARGS[(POS) - 1].TYPEINDEX, FUN.ARGS[(POS) - 1].TYPEINDEX) && (DECL.ARGS[(POS) - 1].ISREFERENCE == FUN.ARGS[(POS) - 1].ISREFERENCE);
if (POS == last) break;
++POS;
}
}
}
return_ISSAMEFUNCTIONDEFINITION = SAME;
return return_ISSAMEFUNCTIONDEFINITION;
}
TPSFUNCTIONINDEX ADDFUNCTION(TPSFUNCTION FUN) {
TPSFUNCTIONINDEX return_ADDFUNCTION;
int POS;
POS = FINDFUNCTION(FUN.NAME);
if (POS != 0) {
if (DEFS.FUNCTIONS[(POS) - 1].ISDECLARATION) {
if (!ISSAMEFUNCTIONDEFINITION(POS, FUN)) {
if (FUN.RETURNTYPEINDEX == 0) {
write_s(STDERR, str_make(10, "Procedure "));
write_s(STDERR, FUN.NAME);
write_s(STDERR, str_make(42, " incompatible with its forward declaration"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
 else {
write_s(STDERR, str_make(9, "Function "));
write_s(STDERR, FUN.NAME);
write_s(STDERR, str_make(42, " incompatible with its forward declaration"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
 else {
if (FUN.RETURNTYPEINDEX == 0) {
write_s(STDERR, str_make(10, "Procedure "));
write_s(STDERR, FUN.NAME);
write_s(STDERR, str_make(16, " already defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
 else {
write_s(STDERR, str_make(9, "Function "));
write_s(STDERR, FUN.NAME);
write_s(STDERR, str_make(16, " already defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
 else {
POS = DEFS.SCOPE.NUMFUNCTIONS + 1;
if (POS > 256) {
{
write_s(STDERR, str_make(36, "Too many functions have been defined"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
DEFS.SCOPE.NUMFUNCTIONS = POS;
}
DEFS.FUNCTIONS[(POS) - 1] = FUN;
return_ADDFUNCTION = POS;
return return_ADDFUNCTION;
}
TPSTYPEINDEX FINDFIELDTYPE(TPSTYPEINDEX TYPEINDEX, STRING NAME) {
TPSTYPEINDEX return_FINDFIELDTYPE;
TPSTYPE TYP;
TPSRECORDDEF REC;
int POS;
TYP = DEFS.TYPES[(TYPEINDEX) - 1];
if (TYP.CLS != TTCRECORD) {
{
write_s(STDERR, str_make(14, "Not a record: "));
write_s(STDERR, TYP.NAME);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
TYPEINDEX = 0;
REC = DEFS.RECORDS[(TYP.RECORDINDEX) - 1];
{
int first = 1;
int last = REC.SIZE;
if (first <= last) {
POS = first;
while (1) {
if (cmp_ss(REC.FIELDS[(POS) - 1].NAME, NAME) == 0) TYPEINDEX = REC.FIELDS[(POS) - 1].TYPEINDEX;
if (POS == last) break;
++POS;
}
}
}
if (TYPEINDEX == 0) {
{
write_s(STDERR, str_make(17, "Field not found: "));
write_s(STDERR, NAME);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
return_FINDFIELDTYPE = TYPEINDEX;
return return_FINDFIELDTYPE;
}
TPSTYPE MAKETYPE(STRING NAME, TPSTYPECLASS CLS) {
TPSTYPE return_MAKETYPE;
TPSTYPE TYP;
TYP = EMPTYTYPE();
TYP.NAME = NAME;
TYP.CLS = CLS;
return_MAKETYPE = TYP;
return return_MAKETYPE;
}
TPSCONSTANT MAKECONSTANT(STRING NAME, TLXTOKENID TOKENID, STRING TOKENVALUE) {
TPSCONSTANT return_MAKECONSTANT;
TPSCONSTANT CONSTANT;
CONSTANT.NAME = NAME;
CONSTANT.REPLACEMENT.ID = TOKENID;
CONSTANT.REPLACEMENT.VALUE = TOKENVALUE;
return_MAKECONSTANT = CONSTANT;
return return_MAKECONSTANT;
}
TPSVARIABLE MAKETYPEDCONSTANT(STRING NAME, TPSTYPEINDEX TYPEINDEX) {
TPSVARIABLE return_MAKETYPEDCONSTANT;
TPSVARIABLE VARDEF;
VARDEF.NAME = NAME;
VARDEF.TYPEINDEX = TYPEINDEX;
VARDEF.ISREFERENCE = 0;
VARDEF.ISCONSTANT = 1;
return_MAKETYPEDCONSTANT = VARDEF;
return return_MAKETYPEDCONSTANT;
}
TPSVARIABLE MAKEVARIABLE(STRING NAME, TPSTYPEINDEX TYPEINDEX, PBoolean ISREF) {
TPSVARIABLE return_MAKEVARIABLE;
TPSVARIABLE VARDEF;
VARDEF.NAME = NAME;
VARDEF.TYPEINDEX = TYPEINDEX;
VARDEF.ISREFERENCE = ISREF;
VARDEF.ISCONSTANT = 0;
return_MAKEVARIABLE = VARDEF;
return return_MAKEVARIABLE;
}
PBoolean ISVARIABLEEXPRESSION(TPSEXPRESSION EXPR) {
PBoolean return_ISVARIABLEEXPRESSION;
return_ISVARIABLEEXPRESSION = (EXPR.CLS == TECVALUE) && (EXPR.TYPEINDEX != 0) && !EXPR.ISCONSTANT;
return return_ISVARIABLEEXPRESSION;
}
void STARTGLOBALSCOPE() {
TPSFUNCTION FUN;
CLEARDEFS();
GLOBALSCOPE = GETCURRENTSCOPE();
PRIMITIVETYPES.PTBOOLEAN = ADDTYPE(MAKETYPE(str_make(7, "BOOLEAN"), TTCBOOLEAN), GLOBALSCOPE);
PRIMITIVETYPES.PTINTEGER = ADDTYPE(MAKETYPE(str_make(7, "INTEGER"), TTCINTEGER), GLOBALSCOPE);
PRIMITIVETYPES.PTCHAR = ADDTYPE(MAKETYPE(str_make(4, "CHAR"), TTCCHAR), GLOBALSCOPE);
PRIMITIVETYPES.PTSTRING = ADDTYPE(MAKETYPE(str_make(6, "STRING"), TTCSTRING), GLOBALSCOPE);
PRIMITIVETYPES.PTTEXT = ADDTYPE(MAKETYPE(str_make(4, "TEXT"), TTCTEXT), GLOBALSCOPE);
ADDCONSTANT(MAKECONSTANT(str_make(5, "FALSE"), TKFALSE, str_make(5, "FALSE")), GLOBALSCOPE);
ADDCONSTANT(MAKECONSTANT(str_make(4, "TRUE"), TKTRUE, str_make(4, "TRUE")), GLOBALSCOPE);
ADDVARIABLE(MAKEVARIABLE(str_make(5, "INPUT"), PRIMITIVETYPES.PTTEXT, 0), GLOBALSCOPE);
ADDVARIABLE(MAKEVARIABLE(str_make(6, "OUTPUT"), PRIMITIVETYPES.PTTEXT, 0), GLOBALSCOPE);
ADDVARIABLE(MAKEVARIABLE(str_make(6, "STDERR"), PRIMITIVETYPES.PTTEXT, 0), GLOBALSCOPE);
FUN.NAME = str_make(6, "ASSIGN");
FUN.ARGCOUNT = 2;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_of('F'), PRIMITIVETYPES.PTTEXT, 1);
FUN.ARGS[(2) - 1] = MAKEVARIABLE(str_make(4, "NAME"), PRIMITIVETYPES.PTSTRING, 0);
FUN.RETURNTYPEINDEX = 0;
ADDFUNCTION(FUN);
FUN.NAME = str_make(5, "CLOSE");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_of('F'), PRIMITIVETYPES.PTTEXT, 1);
FUN.RETURNTYPEINDEX = 0;
ADDFUNCTION(FUN);
FUN.NAME = str_make(4, "COPY");
FUN.ARGCOUNT = 3;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_make(3, "STR"), PRIMITIVETYPES.PTSTRING, 0);
FUN.ARGS[(2) - 1] = MAKEVARIABLE(str_make(3, "POS"), PRIMITIVETYPES.PTINTEGER, 0);
FUN.ARGS[(3) - 1] = MAKEVARIABLE(str_make(3, "NUM"), PRIMITIVETYPES.PTINTEGER, 0);
FUN.RETURNTYPEINDEX = PRIMITIVETYPES.PTSTRING;
ADDFUNCTION(FUN);
FUN.NAME = str_make(6, "DELETE");
FUN.ARGCOUNT = 3;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_make(3, "STR"), PRIMITIVETYPES.PTSTRING, 1);
FUN.ARGS[(2) - 1] = MAKEVARIABLE(str_make(3, "POS"), PRIMITIVETYPES.PTINTEGER, 0);
FUN.ARGS[(3) - 1] = MAKEVARIABLE(str_make(3, "NUM"), PRIMITIVETYPES.PTINTEGER, 0);
FUN.RETURNTYPEINDEX = 0;
ADDFUNCTION(FUN);
FUN.NAME = str_make(3, "EOF");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_of('F'), PRIMITIVETYPES.PTTEXT, 1);
FUN.RETURNTYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
ADDFUNCTION(FUN);
FUN.NAME = str_make(4, "HALT");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_make(4, "CODE"), PRIMITIVETYPES.PTINTEGER, 0);
FUN.RETURNTYPEINDEX = 0;
ADDFUNCTION(FUN);
FUN.NAME = str_make(6, "LENGTH");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_make(3, "STR"), PRIMITIVETYPES.PTSTRING, 0);
FUN.RETURNTYPEINDEX = PRIMITIVETYPES.PTINTEGER;
ADDFUNCTION(FUN);
FUN.NAME = str_make(10, "PARAMCOUNT");
FUN.ARGCOUNT = 0;
FUN.RETURNTYPEINDEX = PRIMITIVETYPES.PTINTEGER;
ADDFUNCTION(FUN);
FUN.NAME = str_make(8, "PARAMSTR");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_of('I'), PRIMITIVETYPES.PTINTEGER, 0);
FUN.RETURNTYPEINDEX = PRIMITIVETYPES.PTSTRING;
ADDFUNCTION(FUN);
FUN.NAME = str_make(5, "RESET");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_of('F'), PRIMITIVETYPES.PTTEXT, 1);
FUN.RETURNTYPEINDEX = 0;
ADDFUNCTION(FUN);
FUN.NAME = str_make(7, "REWRITE");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_of('F'), PRIMITIVETYPES.PTTEXT, 1);
FUN.RETURNTYPEINDEX = 0;
ADDFUNCTION(FUN);
FUN.NAME = str_make(6, "UPCASE");
FUN.ARGCOUNT = 1;
FUN.ARGS[(1) - 1] = MAKEVARIABLE(str_make(3, "CHR"), PRIMITIVETYPES.PTCHAR, 0);
FUN.RETURNTYPEINDEX = PRIMITIVETYPES.PTCHAR;
ADDFUNCTION(FUN);
}
TPSTYPEINDEX PSTYPEDENOTER(TPSSCOPE SCOPE) {
TPSTYPEINDEX return_PSTYPEDENOTER;
TPSTYPEINDEX TYPEINDEX;
TPSTYPE TYP;
TPSENUMDEF ENUM;
TPSRECORDDEF REC;
TPSARRAYDEF ARR;
TYPEINDEX = 0;
if (LEXER.TOKEN.ID == TKIDENTIFIER) {
TYPEINDEX = FINDTYPE(LEXER.TOKEN.VALUE);
if (TYPEINDEX == 0) {
{
write_s(STDERR, str_make(14, "Unknown type: "));
write_s(STDERR, LEXER.TOKEN.VALUE);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
READTOKEN();
}
 else if (LEXER.TOKEN.ID == TKLPAREN) {
SKIPTOKEN(TKLPAREN);
ENUM.SIZE = 0;
do {
ENUM.SIZE = ENUM.SIZE + 1;
if (ENUM.SIZE > 128) {
{
write_s(STDERR, str_make(23, "Too many values in enum"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
ENUM.VALUES[(ENUM.SIZE) - 1] = GETTOKENVALUEANDREAD(TKIDENTIFIER);
WANTTOKEN2(TKCOMMA, TKRPAREN);
SKIPTOKEN(TKCOMMA);
} while (!(LEXER.TOKEN.ID == TKRPAREN));
TYP = EMPTYTYPE();
TYP.CLS = TTCENUM;
TYP.ENUMINDEX = ADDENUM(ENUM);
TYPEINDEX = ADDTYPE(TYP, SCOPE);
SKIPTOKEN(TKRPAREN);
}
 else if (LEXER.TOKEN.ID == TKRECORD) {
SKIPTOKEN(TKRECORD);
REC.SIZE = 0;
do {
REC.SIZE = REC.SIZE + 1;
if (REC.SIZE > 16) {
{
write_s(STDERR, str_make(25, "Too many fields in record"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
REC.FIELDS[(REC.SIZE) - 1].NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
WANTTOKENANDREAD(TKCOLON);
REC.FIELDS[(REC.SIZE) - 1].TYPEINDEX = PSTYPEDENOTER(SCOPE);
WANTTOKEN2(TKSEMICOLON, TKEND);
SKIPTOKEN(TKSEMICOLON);
} while (!(LEXER.TOKEN.ID == TKEND));
TYP = TYPEOFCLASS(TTCRECORD);
TYP.RECORDINDEX = ADDRECORD(REC);
TYPEINDEX = ADDTYPE(TYP, SCOPE);
SKIPTOKEN(TKEND);
}
 else if (LEXER.TOKEN.ID == TKARRAY) {
SKIPTOKEN(TKARRAY);
WANTTOKENANDREAD(TKLBRACKET);
ARR.LOWBOUND = GETTOKENVALUEANDREAD(TKNUMBER);
WANTTOKENANDREAD(TKRANGE);
ARR.HIGHBOUND = GETTOKENVALUEANDREAD(TKNUMBER);
WANTTOKENANDREAD(TKRBRACKET);
WANTTOKENANDREAD(TKOF);
ARR.TYPEINDEX = PSTYPEDENOTER(SCOPE);
TYP = TYPEOFCLASS(TTCARRAY);
TYP.ARRAYINDEX = ADDARRAY(ARR);
TYPEINDEX = ADDTYPE(TYP, SCOPE);
}
 else {
{
write_s(STDERR, str_make(30, "Wanted type definition, found "));
write_s(STDERR, LXTOKENSTR());
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
return_PSTYPEDENOTER = TYPEINDEX;
return return_PSTYPEDENOTER;
}
void OUTBEGIN() {
{
write_c(CODEGEN.OUTPUT, '{');
writeln(CODEGEN.OUTPUT);
}
}
void OUTEND() {
{
write_c(CODEGEN.OUTPUT, '}');
writeln(CODEGEN.OUTPUT);
}
}
void OUTENUMVALUES(TPSENUMINDEX POS) {
int POSINENUM;
{
write_s(CODEGEN.OUTPUT, str_make(22, "const char* EnumValues"));
write_i(CODEGEN.OUTPUT, POS);
write_s(CODEGEN.OUTPUT, str_make(7, "[] = { "));
}
{
int first = 1;
int last = DEFS.ENUMS[(POS) - 1].SIZE;
if (first <= last) {
POSINENUM = first;
while (1) {
{
if (POSINENUM != 1) {
write_s(CODEGEN.OUTPUT, str_make(2, ", "));
}
{
write_c(CODEGEN.OUTPUT, '\"');
write_s(CODEGEN.OUTPUT, DEFS.ENUMS[(POS) - 1].VALUES[(POSINENUM) - 1]);
write_c(CODEGEN.OUTPUT, '\"');
}
}
if (POSINENUM == last) break;
++POSINENUM;
}
}
}
{
write_s(CODEGEN.OUTPUT, str_make(3, " };"));
writeln(CODEGEN.OUTPUT);
}
}
void OUTENUMVALUESINSCOPE(TPSSCOPE SCOPE) {
TPSENUMINDEX POS;
{
TPSENUMINDEX first = SCOPE.NUMENUMS + 1;
TPSENUMINDEX last = DEFS.SCOPE.NUMENUMS;
if (first <= last) {
POS = first;
while (1) {
OUTENUMVALUES(POS);
if (POS == last) break;
++POS;
}
}
}
}
STRING OUTVARIABLENAME(STRING NAME, PBoolean ISREFERENCE) {
STRING return_OUTVARIABLENAME;
if (ISREFERENCE) return_OUTVARIABLENAME = cat_cs('*', NAME);
 else return_OUTVARIABLENAME = NAME;
return return_OUTVARIABLENAME;
}
STRING OUTRETURNVARIABLENAME(STRING NAME) {
STRING return_OUTRETURNVARIABLENAME;
return_OUTRETURNVARIABLENAME = cat_ss(str_make(7, "return_"), NAME);
return return_OUTRETURNVARIABLENAME;
}
void OUTNAMEANDTYPE(STRING NAME, TPSTYPEINDEX TYPEINDEX) {
TPSTYPE TYP;
TPSENUMDEF ENUM;
TPSRECORDDEF REC;
TPSARRAYDEF ARR;
int POS;
if (TYPEINDEX != 0) TYP = DEFS.TYPES[(TYPEINDEX) - 1];
if (TYPEINDEX == 0) {
write_s(CODEGEN.OUTPUT, str_make(5, "void "));
write_s(CODEGEN.OUTPUT, NAME);
}
 else if ((TYP.ALIASFOR != 0) && (cmp_ss(TYP.NAME, str_make(0, "")) != 0)) {
write_s(CODEGEN.OUTPUT, TYP.NAME);
write_c(CODEGEN.OUTPUT, ' ');
write_s(CODEGEN.OUTPUT, NAME);
}
 else if (TYP.CLS == TTCBOOLEAN) {
write_s(CODEGEN.OUTPUT, str_make(9, "PBoolean "));
write_s(CODEGEN.OUTPUT, NAME);
}
 else if (TYP.CLS == TTCINTEGER) {
write_s(CODEGEN.OUTPUT, str_make(4, "int "));
write_s(CODEGEN.OUTPUT, NAME);
}
 else if (TYP.CLS == TTCCHAR) {
write_s(CODEGEN.OUTPUT, str_make(5, "char "));
write_s(CODEGEN.OUTPUT, NAME);
}
 else if (TYP.CLS == TTCSTRING) {
write_s(CODEGEN.OUTPUT, str_make(7, "STRING "));
write_s(CODEGEN.OUTPUT, NAME);
}
 else if (TYP.CLS == TTCTEXT) {
write_s(CODEGEN.OUTPUT, str_make(6, "PFile "));
write_s(CODEGEN.OUTPUT, NAME);
}
 else if (TYP.CLS == TTCENUM) {
ENUM = DEFS.ENUMS[(TYP.ENUMINDEX) - 1];
{
write_s(CODEGEN.OUTPUT, str_make(7, "enum { "));
}
{
int first = 1;
int last = ENUM.SIZE;
if (first <= last) {
POS = first;
while (1) {
{
if (POS > 1) {
write_s(CODEGEN.OUTPUT, str_make(2, ", "));
}
{
write_s(CODEGEN.OUTPUT, ENUM.VALUES[(POS) - 1]);
}
}
if (POS == last) break;
++POS;
}
}
}
{
write_s(CODEGEN.OUTPUT, str_make(2, "} "));
write_s(CODEGEN.OUTPUT, NAME);
}
}
 else if (TYP.CLS == TTCRECORD) {
REC = DEFS.RECORDS[(TYP.RECORDINDEX) - 1];
{
write_s(CODEGEN.OUTPUT, str_make(9, "struct { "));
}
{
int first = 1;
int last = REC.SIZE;
if (first <= last) {
POS = first;
while (1) {
{
OUTNAMEANDTYPE(REC.FIELDS[(POS) - 1].NAME, REC.FIELDS[(POS) - 1].TYPEINDEX);
{
write_s(CODEGEN.OUTPUT, str_make(2, "; "));
}
}
if (POS == last) break;
++POS;
}
}
}
{
write_s(CODEGEN.OUTPUT, str_make(2, "} "));
write_s(CODEGEN.OUTPUT, NAME);
}
}
 else if (TYP.CLS == TTCARRAY) {
ARR = DEFS.ARRAYS[(TYP.ARRAYINDEX) - 1];
OUTNAMEANDTYPE(NAME, ARR.TYPEINDEX);
{
write_s(CODEGEN.OUTPUT, str_make(5, "[1 + "));
write_s(CODEGEN.OUTPUT, ARR.HIGHBOUND);
write_s(CODEGEN.OUTPUT, str_make(3, " - "));
write_s(CODEGEN.OUTPUT, ARR.LOWBOUND);
write_c(CODEGEN.OUTPUT, ']');
}
}
 else {
{
write_s(STDERR, str_make(29, "Error writing name and type: "));
write_s(STDERR, NAME);
write_s(STDERR, str_make(2, ", "));
write_s(STDERR, TYPENAME(TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
void OUTTYPEDEFINITION(TPSTYPEINDEX TYPEINDEX) {
STRING NAME;
NAME = DEFS.TYPES[(TYPEINDEX) - 1].NAME;
if (DEFS.TYPES[(TYPEINDEX) - 1].ALIASFOR == 0) {
{
write_s(STDERR, str_make(5, "Type "));
write_s(STDERR, NAME);
write_s(STDERR, str_make(16, " is not an alias"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
{
write_s(CODEGEN.OUTPUT, str_make(8, "typedef "));
}
OUTNAMEANDTYPE(NAME, DEFS.TYPES[(TYPEINDEX) - 1].ALIASFOR);
{
write_c(CODEGEN.OUTPUT, ';');
writeln(CODEGEN.OUTPUT);
}
}
void PSTYPEDEFINITIONS(TPSSCOPE SCOPE) {
STRING NAME;
TPSTYPEINDEX TYPEINDEX;
TPSTYPE NEWTYPE;
TPSSCOPE PREVIOUSSCOPE;
PREVIOUSSCOPE = GETCURRENTSCOPE();
WANTTOKENANDREAD(TKTYPE);
do {
NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
WANTTOKENANDREAD(TKEQUALS);
TYPEINDEX = PSTYPEDENOTER(SCOPE);
NEWTYPE = DEFS.TYPES[(TYPEINDEX) - 1];
NEWTYPE.NAME = NAME;
NEWTYPE.ALIASFOR = TYPEINDEX;
TYPEINDEX = ADDTYPE(NEWTYPE, SCOPE);
WANTTOKENANDREAD(TKSEMICOLON);
OUTTYPEDEFINITION(TYPEINDEX);
} while (!(LEXER.TOKEN.ID != TKIDENTIFIER));
OUTENUMVALUESINSCOPE(PREVIOUSSCOPE);
}
void PSCONSTANT(STRING NAME, TPSSCOPE SCOPE) {
TPSCONSTANT CONSTANT;
WANTTOKENANDREAD(TKEQUALS);
CONSTANT.NAME = NAME;
if ((LEXER.TOKEN.ID == TKFALSE) || (LEXER.TOKEN.ID == TKTRUE) || (LEXER.TOKEN.ID == TKNUMBER) || (LEXER.TOKEN.ID == TKSTRING)) CONSTANT.REPLACEMENT = LEXER.TOKEN;
 else {
{
write_s(STDERR, str_make(31, "Expected constant value, found "));
write_s(STDERR, LXTOKENSTR());
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
ADDCONSTANT(CONSTANT, SCOPE);
READTOKEN();
}
TPSEXPRESSION GENBOOLEANCONSTANT(PBoolean VALUE) {
TPSEXPRESSION return_GENBOOLEANCONSTANT;
TPSEXPRESSION EXPR;
EXPR.TYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
EXPR.CLS = TECVALUE;
EXPR.ISCONSTANT = 1;
if (VALUE) EXPR.VALUE = str_of('1');
 else EXPR.VALUE = str_of('0');
return_GENBOOLEANCONSTANT = EXPR;
return return_GENBOOLEANCONSTANT;
}
TPSEXPRESSION GENSTRINGCONSTANT(STRING VALUE) {
TPSEXPRESSION return_GENSTRINGCONSTANT;
TPSEXPRESSION EXPR;
STRING SIZE;
int POS;
PBoolean INSTR;
PBoolean LASTQUOTE;
int LEN;
INSTR = 0;
LASTQUOTE = 0;
EXPR.VALUE = str_make(0, "");
EXPR.CLS = TECVALUE;
EXPR.ISCONSTANT = 1;
LEN = 0;
{
int first = 1;
int last = LENGTH(VALUE);
if (first <= last) {
POS = first;
while (1) {
{
if (cmp_cc(VALUE.chr[POS], '\'') == 0) {
INSTR = !INSTR;
if (INSTR && LASTQUOTE) {
EXPR.VALUE = cat_ss(EXPR.VALUE, str_make(2, "\\\'"));
LEN = LEN + 1;
}
 else LASTQUOTE = !INSTR;
}
 else {
LASTQUOTE = 0;
if (cmp_cc(VALUE.chr[POS], '\"') == 0) EXPR.VALUE = cat_ss(EXPR.VALUE, str_make(2, "\\\""));
 else if (cmp_cc(VALUE.chr[POS], '\\') == 0) EXPR.VALUE = cat_ss(EXPR.VALUE, str_make(2, "\\\\"));
 else EXPR.VALUE = cat_sc(EXPR.VALUE, VALUE.chr[POS]);
LEN = LEN + 1;
}
}
if (POS == last) break;
++POS;
}
}
}
if (LEN == 1) {
EXPR.VALUE = cat_sc(cat_cs('\'', EXPR.VALUE), '\'');
EXPR.TYPEINDEX = PRIMITIVETYPES.PTCHAR;
}
 else {
SIZE = to_str_i(LEN);
EXPR.VALUE = cat_ss(cat_ss(cat_ss(cat_ss(str_make(9, "str_make("), SIZE), str_make(3, ", \"")), EXPR.VALUE), str_make(2, "\")"));
EXPR.TYPEINDEX = PRIMITIVETYPES.PTSTRING;
}
return_GENSTRINGCONSTANT = EXPR;
return return_GENSTRINGCONSTANT;
}
TPSEXPRESSION GENNUMBERCONSTANT(STRING VALUE) {
TPSEXPRESSION return_GENNUMBERCONSTANT;
TPSEXPRESSION EXPR;
EXPR.TYPEINDEX = PRIMITIVETYPES.PTINTEGER;
EXPR.VALUE = VALUE;
EXPR.CLS = TECVALUE;
EXPR.ISCONSTANT = 1;
return_GENNUMBERCONSTANT = EXPR;
return return_GENNUMBERCONSTANT;
}
void OUTCONSTANTVALUE(STRING VALUE) {
{
write_s(CODEGEN.OUTPUT, VALUE);
}
}
void OUTCONSTANTARRAYBEGIN() {
{
write_s(CODEGEN.OUTPUT, str_make(2, "{ "));
}
}
void OUTCONSTANTARRAYSEPARATOR() {
{
write_s(CODEGEN.OUTPUT, str_make(2, ", "));
}
}
void OUTCONSTANTARRAYEND() {
{
write_s(CODEGEN.OUTPUT, str_make(2, " }"));
}
}
void PSCONSTANTVALUE(TPSTYPEINDEX TYPEINDEX) {
TPSEXPRESSION EXPR;
if (ISBOOLEANTYPE(TYPEINDEX)) {
WANTTOKEN2(TKFALSE, TKTRUE);
EXPR = GENBOOLEANCONSTANT(LEXER.TOKEN.ID == TKTRUE);
READTOKEN();
OUTCONSTANTVALUE(EXPR.VALUE);
}
 else if (ISINTEGERTYPE(TYPEINDEX)) {
EXPR = GENNUMBERCONSTANT(GETTOKENVALUEANDREAD(TKNUMBER));
OUTCONSTANTVALUE(EXPR.VALUE);
}
 else if (ISCHARTYPE(TYPEINDEX)) {
EXPR = GENSTRINGCONSTANT(GETTOKENVALUEANDREAD(TKSTRING));
if (!ISCHARTYPE(EXPR.TYPEINDEX)) {
{
write_s(STDERR, str_make(28, "Expected char constant, got "));
write_s(STDERR, TYPENAME(EXPR.TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
OUTCONSTANTVALUE(EXPR.VALUE);
}
 else if (ISSTRINGTYPE(TYPEINDEX)) {
EXPR = GENSTRINGCONSTANT(GETTOKENVALUEANDREAD(TKSTRING));
OUTCONSTANTVALUE(EXPR.VALUE);
}
 else if (ISARRAYTYPE(TYPEINDEX)) {
WANTTOKENANDREAD(TKLPAREN);
TYPEINDEX = DEFS.ARRAYS[(DEFS.TYPES[(TYPEINDEX) - 1].ARRAYINDEX) - 1].TYPEINDEX;
OUTCONSTANTARRAYBEGIN();
while (LEXER.TOKEN.ID != TKRPAREN) {
PSCONSTANTVALUE(TYPEINDEX);
WANTTOKEN2(TKCOMMA, TKRPAREN);
if (LEXER.TOKEN.ID == TKCOMMA) OUTCONSTANTARRAYSEPARATOR();
SKIPTOKEN(TKCOMMA);
}
OUTCONSTANTARRAYEND();
WANTTOKENANDREAD(TKRPAREN);
}
 else {
{
write_s(STDERR, str_make(27, "Invalid type for constant: "));
write_s(STDERR, TYPENAME(TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
void OUTVARIABLEDECLARATION(TPSVARIABLE VARDEF) {
OUTNAMEANDTYPE(OUTVARIABLENAME(VARDEF.NAME, VARDEF.ISREFERENCE), VARDEF.TYPEINDEX);
}
void OUTVARIABLEDEFINITION(TPSVARIABLEINDEX VARINDEX) {
if (DEFS.VARIABLES[(VARINDEX) - 1].ISCONSTANT) {
write_s(CODEGEN.OUTPUT, str_make(6, "const "));
}
OUTVARIABLEDECLARATION(DEFS.VARIABLES[(VARINDEX) - 1]);
{
write_c(CODEGEN.OUTPUT, ';');
writeln(CODEGEN.OUTPUT);
}
}
void OUTCONSTANTDEFINITIONBEGIN(TPSVARIABLEINDEX VARINDEX) {
{
write_s(CODEGEN.OUTPUT, str_make(6, "const "));
}
OUTVARIABLEDECLARATION(DEFS.VARIABLES[(VARINDEX) - 1]);
{
write_s(CODEGEN.OUTPUT, str_make(3, " = "));
}
}
void OUTCONSTANTDEFINITIONEND() {
{
write_c(CODEGEN.OUTPUT, ';');
writeln(CODEGEN.OUTPUT);
}
}
void PSTYPEDCONSTANT(STRING NAME, TPSSCOPE SCOPE) {
TPSTYPEINDEX TYPEINDEX;
WANTTOKENANDREAD(TKCOLON);
TYPEINDEX = PSTYPEDENOTER(SCOPE);
WANTTOKENANDREAD(TKEQUALS);
OUTCONSTANTDEFINITIONBEGIN(ADDVARIABLE(MAKETYPEDCONSTANT(NAME, TYPEINDEX), SCOPE));
PSCONSTANTVALUE(TYPEINDEX);
OUTCONSTANTDEFINITIONEND();
}
void PSCONSTDEFINITIONS(TPSSCOPE SCOPE) {
STRING NAME;
WANTTOKENANDREAD(TKCONST);
do {
NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
WANTTOKEN2(TKEQUALS, TKCOLON);
if (LEXER.TOKEN.ID == TKEQUALS) PSCONSTANT(NAME, SCOPE);
 else PSTYPEDCONSTANT(NAME, SCOPE);
WANTTOKENANDREAD(TKSEMICOLON);
} while (!(LEXER.TOKEN.ID != TKIDENTIFIER));
}
void PSVARDEFINITIONS(TPSSCOPE SCOPE) {
STRING NAME;
TPSTYPEINDEX TYPEINDEX;
TPSSCOPE PREVIOUSSCOPE;
PREVIOUSSCOPE = GETCURRENTSCOPE();
WANTTOKENANDREAD(TKVAR);
do {
NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
WANTTOKENANDREAD(TKCOLON);
TYPEINDEX = PSTYPEDENOTER(SCOPE);
WANTTOKENANDREAD(TKSEMICOLON);
OUTVARIABLEDEFINITION(ADDVARIABLE(MAKEVARIABLE(NAME, TYPEINDEX, 0), SCOPE));
} while (!(LEXER.TOKEN.ID != TKIDENTIFIER));
OUTENUMVALUESINSCOPE(PREVIOUSSCOPE);
}
void OUTFUNCTIONPROTOTYPE(TPSFUNCTION DEF) {
int POS;
OUTNAMEANDTYPE(DEF.NAME, DEF.RETURNTYPEINDEX);
{
write_c(CODEGEN.OUTPUT, '(');
}
{
int first = 1;
int last = DEF.ARGCOUNT;
if (first <= last) {
POS = first;
while (1) {
{
OUTVARIABLEDECLARATION(DEF.ARGS[(POS) - 1]);
if (POS != DEF.ARGCOUNT) {
write_s(CODEGEN.OUTPUT, str_make(2, ", "));
}
}
if (POS == last) break;
++POS;
}
}
}
{
write_c(CODEGEN.OUTPUT, ')');
}
}
void OUTFUNCTIONDECLARATION(TPSFUNCTIONINDEX FNINDEX) {
OUTFUNCTIONPROTOTYPE(DEFS.FUNCTIONS[(FNINDEX) - 1]);
{
write_c(CODEGEN.OUTPUT, ';');
writeln(CODEGEN.OUTPUT);
}
}
void OUTFUNCTIONDEFINITION(TPSFUNCTIONINDEX FNINDEX) {
TPSFUNCTION FUN;
FUN = DEFS.FUNCTIONS[(FNINDEX) - 1];
OUTFUNCTIONPROTOTYPE(FUN);
{
write_s(CODEGEN.OUTPUT, str_make(2, " {"));
writeln(CODEGEN.OUTPUT);
}
if (FUN.RETURNTYPEINDEX != 0) {
OUTNAMEANDTYPE(OUTRETURNVARIABLENAME(FUN.NAME), FUN.RETURNTYPEINDEX);
{
write_c(CODEGEN.OUTPUT, ';');
writeln(CODEGEN.OUTPUT);
}
}
}
void OUTFUNCTIONEND(TPSFUNCTIONINDEX FNINDEX) {
if (DEFS.FUNCTIONS[(FNINDEX) - 1].RETURNTYPEINDEX != 0) {
write_s(CODEGEN.OUTPUT, str_make(7, "return "));
write_s(CODEGEN.OUTPUT, OUTRETURNVARIABLENAME(DEFS.FUNCTIONS[(FNINDEX) - 1].NAME));
write_c(CODEGEN.OUTPUT, ';');
writeln(CODEGEN.OUTPUT);
}
{
write_c(CODEGEN.OUTPUT, '}');
writeln(CODEGEN.OUTPUT);
}
}
void PSSTATEMENT();
void PSDEFINITIONS(TPSSCOPE SCOPE);
void ADDFUNCARGSTOSCOPE(TPSFUNCTIONINDEX FNINDEX, TPSSCOPE SCOPE) {
int POS;
{
int first = 1;
int last = DEFS.FUNCTIONS[(FNINDEX) - 1].ARGCOUNT;
if (first <= last) {
POS = first;
while (1) {
ADDVARIABLE(DEFS.FUNCTIONS[(FNINDEX) - 1].ARGS[(POS) - 1], SCOPE);
if (POS == last) break;
++POS;
}
}
}
}
void PSFUNCTIONBODY(TPSFUNCTIONINDEX FNINDEX) {
TPSSCOPE PREVIOUSSCOPE;
if (LEXER.TOKEN.ID == TKFORWARD) {
SKIPTOKEN(TKFORWARD);
WANTTOKENANDREAD(TKSEMICOLON);
DEFS.FUNCTIONS[(FNINDEX) - 1].ISDECLARATION = 1;
OUTFUNCTIONDECLARATION(FNINDEX);
}
 else {
PREVIOUSSCOPE = GETCURRENTSCOPE();
ADDFUNCARGSTOSCOPE(FNINDEX, PREVIOUSSCOPE);
OUTFUNCTIONDEFINITION(FNINDEX);
OUTENUMVALUESINSCOPE(PREVIOUSSCOPE);
PSDEFINITIONS(PREVIOUSSCOPE);
WANTTOKENANDREAD(TKBEGIN);
while (LEXER.TOKEN.ID != TKEND) {
PSSTATEMENT();
WANTTOKEN2(TKSEMICOLON, TKEND);
SKIPTOKEN(TKSEMICOLON);
}
WANTTOKENANDREAD(TKEND);
WANTTOKENANDREAD(TKSEMICOLON);
OUTFUNCTIONEND(FNINDEX);
SETCURRENTSCOPE(PREVIOUSSCOPE);
}
}
void PSFUNCTIONDEFINITION() {
PBoolean ISPROCEDURE;
TPSFUNCTION DEF;
WANTTOKEN2(TKFUNCTION, TKPROCEDURE);
ISPROCEDURE = LEXER.TOKEN.ID == TKPROCEDURE;
READTOKEN();
DEF.NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
DEF.ARGCOUNT = 0;
if (ISPROCEDURE) WANTTOKEN2(TKLPAREN, TKSEMICOLON);
 else WANTTOKEN2(TKLPAREN, TKCOLON);
if (LEXER.TOKEN.ID == TKLPAREN) {
WANTTOKENANDREAD(TKLPAREN);
do {
DEF.ARGCOUNT = DEF.ARGCOUNT + 1;
if (DEF.ARGCOUNT > 4) {
{
write_s(STDERR, str_make(41, "Too many arguments declared for function "));
write_s(STDERR, DEF.NAME);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
DEF.ARGS[(DEF.ARGCOUNT) - 1].ISREFERENCE = LEXER.TOKEN.ID == TKVAR;
SKIPTOKEN(TKVAR);
DEF.ARGS[(DEF.ARGCOUNT) - 1].NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
WANTTOKENANDREAD(TKCOLON);
DEF.ARGS[(DEF.ARGCOUNT) - 1].TYPEINDEX = PSTYPEDENOTER(GLOBALSCOPE);
WANTTOKEN2(TKSEMICOLON, TKRPAREN);
SKIPTOKEN(TKSEMICOLON);
} while (!(LEXER.TOKEN.ID == TKRPAREN));
SKIPTOKEN(TKRPAREN);
}
if (ISPROCEDURE) DEF.RETURNTYPEINDEX = 0;
 else {
WANTTOKENANDREAD(TKCOLON);
DEF.RETURNTYPEINDEX = PSTYPEDENOTER(GLOBALSCOPE);
}
WANTTOKENANDREAD(TKSEMICOLON);
PSFUNCTIONBODY(ADDFUNCTION(DEF));
}
void PSDEFINITIONS(TPSSCOPE SCOPE) {
PBoolean DONE;
DONE = 0;
do {
if (LEXER.TOKEN.ID == TKTYPE) PSTYPEDEFINITIONS(SCOPE);
 else if (LEXER.TOKEN.ID == TKCONST) PSCONSTDEFINITIONS(SCOPE);
 else if (LEXER.TOKEN.ID == TKVAR) PSVARDEFINITIONS(SCOPE);
 else if ((LEXER.TOKEN.ID == TKPROCEDURE) || (LEXER.TOKEN.ID == TKFUNCTION)) PSFUNCTIONDEFINITION();
 else DONE = 1;
} while (!(DONE));
}
void OUTPROGRAMHEADING(STRING NAME) {
{
write_s(CODEGEN.OUTPUT, str_make(12, "/* Program: "));
write_s(CODEGEN.OUTPUT, NAME);
write_s(CODEGEN.OUTPUT, str_make(3, " */"));
writeln(CODEGEN.OUTPUT);
}
{
write_s(CODEGEN.OUTPUT, str_make(20, "#include \"pascual.h\""));
writeln(CODEGEN.OUTPUT);
}
}
void PSPROGRAMHEADING() {
WANTTOKENANDREAD(TKPROGRAM);
OUTPROGRAMHEADING(GETTOKENVALUEANDREAD(TKIDENTIFIER));
if (LEXER.TOKEN.ID == TKLPAREN) {
do {
READTOKEN();
WANTTOKEN2(TKIDENTIFIER, TKRPAREN);
SKIPTOKEN(TKIDENTIFIER);
WANTTOKEN2(TKCOMMA, TKRPAREN);
} while (!(LEXER.TOKEN.ID == TKRPAREN));
SKIPTOKEN(TKRPAREN);
}
WANTTOKENANDREAD(TKSEMICOLON);
}
TPSEXPRESSION PSEXPRESSION();
TPSIDENTIFIER PSIDENTIFIER() {
TPSIDENTIFIER return_PSIDENTIFIER;
TPSIDENTIFIER IDENT;
IDENT.NAME = GETTOKENVALUEANDREAD(TKIDENTIFIER);
return_PSIDENTIFIER = IDENT;
return return_PSIDENTIFIER;
}
PBoolean ISOPADDING(TLXTOKEN TOK) {
PBoolean return_ISOPADDING;
return_ISOPADDING = (TOK.ID == TKPLUS) || (TOK.ID == TKMINUS) || (TOK.ID == TKOR);
return return_ISOPADDING;
}
PBoolean ISOPMULTIPYING(TLXTOKEN TOK) {
PBoolean return_ISOPMULTIPYING;
return_ISOPMULTIPYING = (TOK.ID == TKASTERISK) || (TOK.ID == TKSLASH) || (TOK.ID == TKDIV) || (TOK.ID == TKMOD) || (TOK.ID == TKAND);
return return_ISOPMULTIPYING;
}
PBoolean ISOPRELATIONAL(TLXTOKEN TOK) {
PBoolean return_ISOPRELATIONAL;
return_ISOPRELATIONAL = (TOK.ID == TKEQUALS) || (TOK.ID == TKNOTEQUALS) || (TOK.ID == TKLESSTHAN) || (TOK.ID == TKMORETHAN) || (TOK.ID == TKLESSOREQUALS) || (TOK.ID == TKMOREOREQUALS) || (TOK.ID == TKIN);
return return_ISOPRELATIONAL;
}
char SHORTTYPENAME(TPSTYPEINDEX TYPEINDEX) {
char return_SHORTTYPENAME;
if (ISBOOLEANTYPE(TYPEINDEX)) return_SHORTTYPENAME = 'b';
 else if (ISINTEGERTYPE(TYPEINDEX)) return_SHORTTYPENAME = 'i';
 else if (ISCHARTYPE(TYPEINDEX)) return_SHORTTYPENAME = 'c';
 else if (ISSTRINGTYPE(TYPEINDEX)) return_SHORTTYPENAME = 's';
 else if (ISENUMTYPE(TYPEINDEX)) return_SHORTTYPENAME = 'e';
 else {
write_s(STDERR, str_make(30, "No short type name exists for "));
write_s(STDERR, TYPENAME(TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
return return_SHORTTYPENAME;
}
TPSEXPRESSION INTEGERBINARYEXPRESSION(TPSEXPRESSION LEFT, TLXTOKENID OP, TPSEXPRESSION RIGHT) {
TPSEXPRESSION return_INTEGERBINARYEXPRESSION;
STRING OPER;
STRING CMP;
TPSEXPRESSION EXPR;
OPER = str_make(0, "");
CMP = str_make(0, "");
if (OP == TKPLUS) OPER = str_of('+');
 else if (OP == TKMINUS) OPER = str_of('-');
 else if (OP == TKASTERISK) OPER = str_of('*');
 else if (OP == TKSLASH) OPER = str_of('/');
 else if (OP == TKDIV) OPER = str_of('/');
 else if (OP == TKMOD) OPER = str_of('%');
 else if (OP == TKAND) OPER = str_of('&');
 else if (OP == TKOR) OPER = str_of('|');
 else if (OP == TKEQUALS) CMP = str_make(2, "==");
 else if (OP == TKNOTEQUALS) CMP = str_make(2, "!=");
 else if (OP == TKLESSTHAN) CMP = str_of('<');
 else if (OP == TKMORETHAN) CMP = str_of('>');
 else if (OP == TKLESSOREQUALS) CMP = str_make(2, "<=");
 else if (OP == TKMOREOREQUALS) CMP = str_make(2, ">=");
 else {
{
write_s(STDERR, str_make(32, "Expected binary operator, found "));
write_e(STDERR, OP, EnumValues1);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
if (cmp_ss(CMP, str_make(0, "")) == 0) EXPR.TYPEINDEX = PRIMITIVETYPES.PTINTEGER;
 else EXPR.TYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
EXPR.VALUE = cat_ss(cat_sc(cat_ss(cat_ss(cat_sc(LEFT.VALUE, ' '), OPER), CMP), ' '), RIGHT.VALUE);
EXPR.CLS = TECVALUE;
EXPR.ISCONSTANT = 1;
return_INTEGERBINARYEXPRESSION = EXPR;
return return_INTEGERBINARYEXPRESSION;
}
TPSEXPRESSION BOOLEANBINARYEXPRESSION(TPSEXPRESSION LEFT, TLXTOKENID OP, TPSEXPRESSION RIGHT) {
TPSEXPRESSION return_BOOLEANBINARYEXPRESSION;
STRING OPER;
TPSEXPRESSION EXPR;
if (OP == TKAND) OPER = str_make(2, "&&");
 else if (OP == TKOR) OPER = str_make(2, "||");
 else if (OP == TKEQUALS) OPER = str_make(2, "==");
 else if (OP == TKNOTEQUALS) OPER = str_make(2, "!=");
 else if (OP == TKLESSTHAN) OPER = str_of('<');
 else if (OP == TKMORETHAN) OPER = str_of('>');
 else if (OP == TKLESSOREQUALS) OPER = str_make(2, "<=");
 else if (OP == TKMOREOREQUALS) OPER = str_make(2, ">=");
 else {
{
write_s(STDERR, str_make(32, "Expected binary operator, found "));
write_e(STDERR, OP, EnumValues1);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
EXPR.TYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
EXPR.VALUE = cat_ss(cat_sc(cat_ss(cat_sc(LEFT.VALUE, ' '), OPER), ' '), RIGHT.VALUE);
EXPR.CLS = TECVALUE;
EXPR.ISCONSTANT = 1;
return_BOOLEANBINARYEXPRESSION = EXPR;
return return_BOOLEANBINARYEXPRESSION;
}
TPSEXPRESSION STRINGYBINARYEXPRESSION(TPSEXPRESSION LEFT, TLXTOKENID OP, TPSEXPRESSION RIGHT) {
TPSEXPRESSION return_STRINGYBINARYEXPRESSION;
STRING FNAME;
STRING CMP;
TPSEXPRESSION EXPR;
FNAME = str_make(3, "cmp");
CMP = str_make(0, "");
if (OP == TKPLUS) FNAME = str_make(3, "cat");
 else if (OP == TKEQUALS) CMP = str_make(2, "==");
 else if (OP == TKNOTEQUALS) CMP = str_make(2, "!=");
 else if (OP == TKLESSTHAN) CMP = str_of('<');
 else if (OP == TKMORETHAN) CMP = str_of('>');
 else if (OP == TKLESSOREQUALS) CMP = str_make(2, "<=");
 else if (OP == TKMOREOREQUALS) CMP = str_make(2, ">=");
 else {
{
write_s(STDERR, str_make(32, "Expected binary operator, found "));
write_e(STDERR, OP, EnumValues1);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
FNAME = cat_sc(cat_sc(cat_sc(FNAME, '_'), SHORTTYPENAME(LEFT.TYPEINDEX)), SHORTTYPENAME(RIGHT.TYPEINDEX));
EXPR.TYPEINDEX = PRIMITIVETYPES.PTSTRING;
EXPR.VALUE = cat_sc(cat_ss(cat_ss(cat_ss(cat_sc(FNAME, '('), LEFT.VALUE), str_make(2, ", ")), RIGHT.VALUE), ')');
if (cmp_ss(CMP, str_make(0, "")) != 0) {
EXPR.TYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
EXPR.VALUE = cat_ss(cat_ss(cat_sc(EXPR.VALUE, ' '), CMP), str_make(2, " 0"));
}
EXPR.CLS = TECVALUE;
EXPR.ISCONSTANT = 1;
return_STRINGYBINARYEXPRESSION = EXPR;
return return_STRINGYBINARYEXPRESSION;
}
TPSEXPRESSION ENUMBINARYEXPRESSION(TPSEXPRESSION LEFT, TLXTOKENID OP, TPSEXPRESSION RIGHT) {
TPSEXPRESSION return_ENUMBINARYEXPRESSION;
STRING CMP;
TPSEXPRESSION EXPR;
CMP = str_make(0, "");
if (OP == TKEQUALS) CMP = str_make(2, "==");
 else if (OP == TKNOTEQUALS) CMP = str_make(2, "!=");
 else if (OP == TKLESSTHAN) CMP = str_of('<');
 else if (OP == TKMORETHAN) CMP = str_of('>');
 else if (OP == TKLESSOREQUALS) CMP = str_make(2, "<=");
 else if (OP == TKMOREOREQUALS) CMP = str_make(2, ">=");
 else {
{
write_s(STDERR, str_make(32, "Expected binary operator, found "));
write_e(STDERR, OP, EnumValues1);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
EXPR.TYPEINDEX = PRIMITIVETYPES.PTBOOLEAN;
EXPR.VALUE = cat_ss(cat_sc(cat_ss(cat_sc(LEFT.VALUE, ' '), CMP), ' '), RIGHT.VALUE);
EXPR.CLS = TECVALUE;
EXPR.ISCONSTANT = 1;
return_ENUMBINARYEXPRESSION = EXPR;
return return_ENUMBINARYEXPRESSION;
}
TPSEXPRESSION BINARYEXPRESSION(TPSEXPRESSION LEFT, TLXTOKENID OP, TPSEXPRESSION RIGHT) {
TPSEXPRESSION return_BINARYEXPRESSION;
if (ISBOOLEANTYPE(LEFT.TYPEINDEX) && ISBOOLEANTYPE(RIGHT.TYPEINDEX)) return_BINARYEXPRESSION = BOOLEANBINARYEXPRESSION(LEFT, OP, RIGHT);
 else if (ISINTEGERTYPE(LEFT.TYPEINDEX) && ISINTEGERTYPE(RIGHT.TYPEINDEX)) return_BINARYEXPRESSION = INTEGERBINARYEXPRESSION(LEFT, OP, RIGHT);
 else if (ISSTRINGYTYPE(LEFT.TYPEINDEX) && ISSTRINGYTYPE(RIGHT.TYPEINDEX)) return_BINARYEXPRESSION = STRINGYBINARYEXPRESSION(LEFT, OP, RIGHT);
 else if (ISENUMTYPE(LEFT.TYPEINDEX) && ISSAMETYPE(LEFT.TYPEINDEX, RIGHT.TYPEINDEX)) return_BINARYEXPRESSION = ENUMBINARYEXPRESSION(LEFT, OP, RIGHT);
 else {
{
write_s(STDERR, str_make(27, "Type mismatch for operator "));
write_e(STDERR, OP, EnumValues1);
write_s(STDERR, str_make(2, ": "));
write_s(STDERR, TYPENAME(LEFT.TYPEINDEX));
write_s(STDERR, str_make(5, " and "));
write_s(STDERR, TYPENAME(RIGHT.TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
return return_BINARYEXPRESSION;
}
TPSEXPRESSION UNARYEXPRESSION(TLXTOKENID OP, TPSEXPRESSION EXPR) {
TPSEXPRESSION return_UNARYEXPRESSION;
if (OP != TKNOT) {
{
write_s(STDERR, str_make(31, "Expected unary operator, found "));
write_e(STDERR, OP, EnumValues1);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
 else if (!ISBOOLEANTYPE(EXPR.TYPEINDEX)) {
{
write_s(STDERR, str_make(33, "Expected boolean expression, got "));
write_s(STDERR, TYPENAME(EXPR.TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
 else EXPR.VALUE = cat_cs('!', EXPR.VALUE);
EXPR.ISCONSTANT = 1;
return_UNARYEXPRESSION = EXPR;
return return_UNARYEXPRESSION;
}
TPSEXPRESSION COERCETYPE(TPSEXPRESSION EXPR, TPSTYPEINDEX TYPEINDEX) {
TPSEXPRESSION return_COERCETYPE;
if (EXPR.CLS != TECVALUE) {
{
write_s(STDERR, str_make(26, "Cannot assign function to "));
write_s(STDERR, TYPENAME(TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
if (ISCHARTYPE(EXPR.TYPEINDEX) && ISSTRINGTYPE(TYPEINDEX)) {
EXPR.TYPEINDEX = PRIMITIVETYPES.PTSTRING;
EXPR.VALUE = cat_sc(cat_ss(str_make(7, "str_of("), EXPR.VALUE), ')');
}
 else if (!ISSAMETYPE(EXPR.TYPEINDEX, TYPEINDEX)) {
{
write_s(STDERR, str_make(14, "Cannot assign "));
write_s(STDERR, TYPENAME(EXPR.TYPEINDEX));
write_s(STDERR, str_make(4, " to "));
write_s(STDERR, TYPENAME(TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
return_COERCETYPE = EXPR;
return return_COERCETYPE;
}
STRING GENFUNCTIONCALLSTART(STRING FN) {
STRING return_GENFUNCTIONCALLSTART;
return_GENFUNCTIONCALLSTART = cat_sc(FN, '(');
return return_GENFUNCTIONCALLSTART;
}
STRING GENFUNCTIONCALLEND(STRING FN) {
STRING return_GENFUNCTIONCALLEND;
return_GENFUNCTIONCALLEND = cat_sc(FN, ')');
return return_GENFUNCTIONCALLEND;
}
STRING GENFUNCTIONCALLARGUMENT(STRING FN, TPSEXPRESSION EXPR, PBoolean ISREFERENCE, int ARGNUM) {
STRING return_GENFUNCTIONCALLARGUMENT;
if (ARGNUM != 1) FN = cat_ss(FN, str_make(2, ", "));
if (ISREFERENCE) FN = cat_ss(cat_sc(FN, '&'), EXPR.VALUE);
 else FN = cat_ss(FN, EXPR.VALUE);
return_GENFUNCTIONCALLARGUMENT = FN;
return return_GENFUNCTIONCALLARGUMENT;
}
TPSEXPRESSION GENPARENS(TPSEXPRESSION EXPR) {
TPSEXPRESSION return_GENPARENS;
EXPR.VALUE = cat_sc(cat_cs('(', EXPR.VALUE), ')');
return_GENPARENS = EXPR;
return return_GENPARENS;
}
TPSEXPRESSION PSFUNCTIONCALL(TPSEXPRESSION FN) {
TPSEXPRESSION return_PSFUNCTIONCALL;
TPSFUNCTION FUN;
TPSEXPRESSION EXPR;
int ARGNUM;
if (FN.CLS != TECFUNCTION) {
{
write_s(STDERR, str_make(14, "Not a function"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
FUN = DEFS.FUNCTIONS[(FN.FUNCTIONINDEX) - 1];
FN.VALUE = GENFUNCTIONCALLSTART(FN.VALUE);
WANTTOKENANDREAD(TKLPAREN);
{
int first = 1;
int last = FUN.ARGCOUNT;
if (first <= last) {
ARGNUM = first;
while (1) {
{
if (ARGNUM != 1) WANTTOKENANDREAD(TKCOMMA);
EXPR = COERCETYPE(PSEXPRESSION(), FUN.ARGS[(ARGNUM) - 1].TYPEINDEX);
FN.VALUE = GENFUNCTIONCALLARGUMENT(FN.VALUE, EXPR, FUN.ARGS[(ARGNUM) - 1].ISREFERENCE, ARGNUM);
}
if (ARGNUM == last) break;
++ARGNUM;
}
}
}
WANTTOKENANDREAD(TKRPAREN);
FN.VALUE = GENFUNCTIONCALLEND(FN.VALUE);
FN.CLS = TECVALUE;
FN.TYPEINDEX = FUN.RETURNTYPEINDEX;
FN.ISCONSTANT = 1;
return_PSFUNCTIONCALL = FN;
return return_PSFUNCTIONCALL;
}
void OUTREAD(STRING SRC, TPSEXPRESSION OUTVAR) {
{
write_s(CODEGEN.OUTPUT, str_make(5, "read_"));
write_c(CODEGEN.OUTPUT, SHORTTYPENAME(OUTVAR.TYPEINDEX));
write_c(CODEGEN.OUTPUT, '(');
write_s(CODEGEN.OUTPUT, SRC);
write_s(CODEGEN.OUTPUT, str_make(3, ", &"));
write_s(CODEGEN.OUTPUT, OUTVAR.VALUE);
write_s(CODEGEN.OUTPUT, str_make(2, ");"));
writeln(CODEGEN.OUTPUT);
}
}
void OUTREADLN(STRING SRC) {
{
write_s(CODEGEN.OUTPUT, str_make(7, "readln("));
write_s(CODEGEN.OUTPUT, SRC);
write_s(CODEGEN.OUTPUT, str_make(2, ");"));
writeln(CODEGEN.OUTPUT);
}
}
void PSREAD(TPSIDENTIFIER ID) {
STRING SRC;
PBoolean LINEFEED;
TPSEXPRESSION OUTVAR;
LINEFEED = cmp_ss(ID.NAME, str_make(6, "READLN")) == 0;
OUTBEGIN();
SRC = str_make(5, "INPUT");
WANTTOKENANDREAD(TKLPAREN);
if (LEXER.TOKEN.ID != TKRPAREN) {
OUTVAR = PSEXPRESSION();
if (ISVARIABLEEXPRESSION(OUTVAR) && ISTEXTTYPE(OUTVAR.TYPEINDEX)) SRC = OUTVAR.VALUE;
 else {
if (!ISVARIABLEEXPRESSION(OUTVAR) || !ISSTRINGYTYPE(OUTVAR.TYPEINDEX)) {
{
write_s(STDERR, str_make(36, "Invalid expression for read argument"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
OUTREAD(SRC, OUTVAR);
}
WANTTOKEN2(TKCOMMA, TKRPAREN);
SKIPTOKEN(TKCOMMA);
while (LEXER.TOKEN.ID != TKRPAREN) {
OUTVAR = PSEXPRESSION();
if (!ISVARIABLEEXPRESSION(OUTVAR) || !ISSTRINGYTYPE(OUTVAR.TYPEINDEX)) {
{
write_s(STDERR, str_make(36, "Invalid expression for read argument"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
OUTREAD(SRC, OUTVAR);
WANTTOKEN2(TKCOMMA, TKRPAREN);
SKIPTOKEN(TKCOMMA);
}
}
WANTTOKENANDREAD(TKRPAREN);
if (LINEFEED) OUTREADLN(SRC);
OUTEND();
}
void OUTWRITE(STRING DST, TPSEXPRESSION EXPR) {
if (DEFS.TYPES[(EXPR.TYPEINDEX) - 1].CLS == TTCENUM) {
write_s(CODEGEN.OUTPUT, str_make(8, "write_e("));
write_s(CODEGEN.OUTPUT, DST);
write_s(CODEGEN.OUTPUT, str_make(2, ", "));
write_s(CODEGEN.OUTPUT, EXPR.VALUE);
write_s(CODEGEN.OUTPUT, str_make(12, ", EnumValues"));
write_i(CODEGEN.OUTPUT, DEFS.TYPES[(EXPR.TYPEINDEX) - 1].ENUMINDEX);
write_s(CODEGEN.OUTPUT, str_make(2, ");"));
writeln(CODEGEN.OUTPUT);
}
 else {
write_s(CODEGEN.OUTPUT, str_make(6, "write_"));
write_c(CODEGEN.OUTPUT, SHORTTYPENAME(EXPR.TYPEINDEX));
write_c(CODEGEN.OUTPUT, '(');
write_s(CODEGEN.OUTPUT, DST);
write_s(CODEGEN.OUTPUT, str_make(2, ", "));
write_s(CODEGEN.OUTPUT, EXPR.VALUE);
write_s(CODEGEN.OUTPUT, str_make(2, ");"));
writeln(CODEGEN.OUTPUT);
}
}
void OUTWRITELN(STRING SRC) {
{
write_s(CODEGEN.OUTPUT, str_make(8, "writeln("));
write_s(CODEGEN.OUTPUT, SRC);
write_s(CODEGEN.OUTPUT, str_make(2, ");"));
writeln(CODEGEN.OUTPUT);
}
}
void PSWRITE(TPSIDENTIFIER ID) {
STRING DST;
PBoolean LINEFEED;
TPSEXPRESSION EXPR;
LINEFEED = cmp_ss(ID.NAME, str_make(7, "WRITELN")) == 0;
OUTBEGIN();
DST = str_make(6, "OUTPUT");
WANTTOKENANDREAD(TKLPAREN);
if (LEXER.TOKEN.ID != TKRPAREN) {
EXPR = PSEXPRESSION();
if (ISVARIABLEEXPRESSION(EXPR) && ISTEXTTYPE(EXPR.TYPEINDEX)) DST = EXPR.VALUE;
 else OUTWRITE(DST, EXPR);
WANTTOKEN2(TKCOMMA, TKRPAREN);
SKIPTOKEN(TKCOMMA);
while (LEXER.TOKEN.ID != TKRPAREN) {
OUTWRITE(DST, PSEXPRESSION());
WANTTOKEN2(TKCOMMA, TKRPAREN);
SKIPTOKEN(TKCOMMA);
}
}
WANTTOKENANDREAD(TKRPAREN);
if (LINEFEED) OUTWRITELN(DST);
OUTEND();
}
void OUTSTR(STRING DST, TPSEXPRESSION EXPR) {
if (DEFS.TYPES[(EXPR.TYPEINDEX) - 1].CLS == TTCENUM) {
write_s(CODEGEN.OUTPUT, DST);
write_s(CODEGEN.OUTPUT, str_make(12, " = to_str_e("));
write_s(CODEGEN.OUTPUT, EXPR.VALUE);
write_s(CODEGEN.OUTPUT, str_make(12, ", EnumValues"));
write_i(CODEGEN.OUTPUT, DEFS.TYPES[(EXPR.TYPEINDEX) - 1].ENUMINDEX);
write_s(CODEGEN.OUTPUT, str_make(2, ");"));
writeln(CODEGEN.OUTPUT);
}
 else {
write_s(CODEGEN.OUTPUT, DST);
write_s(CODEGEN.OUTPUT, str_make(10, " = to_str_"));
write_c(CODEGEN.OUTPUT, SHORTTYPENAME(EXPR.TYPEINDEX));
write_c(CODEGEN.OUTPUT, '(');
write_s(CODEGEN.OUTPUT, EXPR.VALUE);
write_s(CODEGEN.OUTPUT, str_make(2, ");"));
writeln(CODEGEN.OUTPUT);
}
}
void PSSTR() {
TPSEXPRESSION EXPR;
TPSEXPRESSION DEST;
WANTTOKENANDREAD(TKLPAREN);
EXPR = PSEXPRESSION();
WANTTOKENANDREAD(TKCOMMA);
DEST = PSEXPRESSION();
if (!ISVARIABLEEXPRESSION(DEST) || !ISSTRINGTYPE(DEST.TYPEINDEX)) {
{
write_s(STDERR, str_make(45, "Destination argument is not a string variable"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
WANTTOKENANDREAD(TKRPAREN);
OUTSTR(DEST.VALUE, EXPR);
}
void SETSTRINGINDEX(TPSEXPRESSION *STR, TPSEXPRESSION IDX) {
(*STR).VALUE = cat_sc(cat_ss(cat_ss((*STR).VALUE, str_make(5, ".chr[")), IDX.VALUE), ']');
}
void SETARRAYINDEX(TPSEXPRESSION *ARR, TPSEXPRESSION IDX) {
(*ARR).VALUE = cat_sc(cat_ss(cat_ss(cat_ss(cat_ss((*ARR).VALUE, str_make(2, "[(")), IDX.VALUE), str_make(4, ") - ")), DEFS.ARRAYS[(DEFS.TYPES[((*ARR).TYPEINDEX) - 1].ARRAYINDEX) - 1].LOWBOUND), ']');
}
TPSEXPRESSION PSARRAYACCESS(TPSEXPRESSION ARR) {
TPSEXPRESSION return_PSARRAYACCESS;
TPSEXPRESSION IDX;
WANTTOKENANDREAD(TKLBRACKET);
IDX = PSEXPRESSION();
WANTTOKENANDREAD(TKRBRACKET);
if ((IDX.CLS != TECVALUE) || !ISINTEGERTYPE(IDX.TYPEINDEX)) {
{
write_s(STDERR, str_make(28, "Subscript must be an integer"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
if ((ARR.CLS == TECVALUE) && ISSTRINGTYPE(ARR.TYPEINDEX)) {
SETSTRINGINDEX(&ARR, IDX);
ARR.TYPEINDEX = PRIMITIVETYPES.PTCHAR;
}
 else if ((ARR.CLS == TECVALUE) && ISARRAYTYPE(ARR.TYPEINDEX)) {
SETARRAYINDEX(&ARR, IDX);
ARR.TYPEINDEX = DEFS.ARRAYS[(DEFS.TYPES[(ARR.TYPEINDEX) - 1].ARRAYINDEX) - 1].TYPEINDEX;
}
 else {
{
write_s(STDERR, str_make(21, "Not a string or array"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
return_PSARRAYACCESS = ARR;
return return_PSARRAYACCESS;
}
void SETFIELDACCESS(TPSEXPRESSION *REC, STRING FLD) {
if (cmp_cc((*REC).VALUE.chr[1], '*') == 0) (*REC).VALUE = cat_sc(cat_cs('(', (*REC).VALUE), ')');
(*REC).VALUE = cat_ss(cat_sc((*REC).VALUE, '.'), FLD);
}
TPSEXPRESSION PSFIELDACCESS(TPSEXPRESSION REC) {
TPSEXPRESSION return_PSFIELDACCESS;
TPSIDENTIFIER FLD;
TPSTYPEINDEX FLDTYPE;
if ((REC.CLS != TECVALUE) || (DEFS.TYPES[(REC.TYPEINDEX) - 1].CLS != TTCRECORD)) {
{
write_s(STDERR, str_make(12, "Not a record"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
WANTTOKENANDREAD(TKDOT);
FLD = PSIDENTIFIER();
FLDTYPE = FINDFIELDTYPE(REC.TYPEINDEX, FLD.NAME);
if (FLDTYPE == 0) {
{
write_s(STDERR, str_make(6, "Field "));
write_s(STDERR, FLD.NAME);
write_s(STDERR, str_make(20, " not found in record"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
SETFIELDACCESS(&REC, FLD.NAME);
REC.TYPEINDEX = FLDTYPE;
return_PSFIELDACCESS = REC;
return return_PSFIELDACCESS;
}
TPSEXPRESSION PSVARIABLEORFUNCTIONCALL() {
TPSEXPRESSION return_PSVARIABLEORFUNCTIONCALL;
TPSIDENTIFIER ID;
TPSVARIABLEINDEX VARINDEX;
TPSFUNCTIONINDEX FNINDEX;
TPSTYPEINDEX ENUMTYPEINDEX;
TPSEXPRESSION EXPR;
PBoolean DONE;
DONE = 0;
EXPR.VALUE = str_make(0, "");
EXPR.ISCONSTANT = 0;
ID = PSIDENTIFIER();
VARINDEX = FINDVARIABLE(ID.NAME);
FNINDEX = FINDFUNCTION(ID.NAME);
ENUMTYPEINDEX = FINDTYPEOFENUMVALUE(ID.NAME);
if (VARINDEX != 0) {
if (DEFS.VARIABLES[(VARINDEX) - 1].ISREFERENCE) EXPR.VALUE = cat_cs('*', ID.NAME);
 else EXPR.VALUE = ID.NAME;
EXPR.CLS = TECVALUE;
EXPR.TYPEINDEX = DEFS.VARIABLES[(VARINDEX) - 1].TYPEINDEX;
}
 else if (FNINDEX != 0) {
EXPR.VALUE = ID.NAME;
EXPR.CLS = TECFUNCTION;
EXPR.FUNCTIONINDEX = FNINDEX;
}
 else if (ENUMTYPEINDEX != 0) {
EXPR.VALUE = ID.NAME;
EXPR.CLS = TECVALUE;
EXPR.TYPEINDEX = ENUMTYPEINDEX;
EXPR.ISCONSTANT = 1;
}
 else {
EXPR.CLS = TECSTATEMENT;
EXPR.TYPEINDEX = 0;
if ((cmp_ss(ID.NAME, str_make(4, "READ")) == 0) || (cmp_ss(ID.NAME, str_make(6, "READLN")) == 0)) PSREAD(ID);
 else if ((cmp_ss(ID.NAME, str_make(5, "WRITE")) == 0) || (cmp_ss(ID.NAME, str_make(7, "WRITELN")) == 0)) PSWRITE(ID);
 else if (cmp_ss(ID.NAME, str_make(3, "STR")) == 0) PSSTR();
 else {
{
write_s(STDERR, str_make(30, "Unknown variable or function: "));
write_s(STDERR, ID.NAME);
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
do {
if (LEXER.TOKEN.ID == TKDOT) EXPR = PSFIELDACCESS(EXPR);
 else if (LEXER.TOKEN.ID == TKLBRACKET) EXPR = PSARRAYACCESS(EXPR);
 else if (LEXER.TOKEN.ID == TKLPAREN) EXPR = PSFUNCTIONCALL(EXPR);
 else DONE = 1;
} while (!(DONE));
return_PSVARIABLEORFUNCTIONCALL = EXPR;
return return_PSVARIABLEORFUNCTIONCALL;
}
TPSEXPRESSION PSFACTOR() {
TPSEXPRESSION return_PSFACTOR;
TPSEXPRESSION EXPR;
if ((LEXER.TOKEN.ID == TKFALSE) || (LEXER.TOKEN.ID == TKTRUE)) {
EXPR = GENBOOLEANCONSTANT(LEXER.TOKEN.ID == TKTRUE);
READTOKEN();
}
 else if (LEXER.TOKEN.ID == TKSTRING) EXPR = GENSTRINGCONSTANT(GETTOKENVALUEANDREAD(TKSTRING));
 else if (LEXER.TOKEN.ID == TKNUMBER) EXPR = GENNUMBERCONSTANT(GETTOKENVALUEANDREAD(TKNUMBER));
 else if (LEXER.TOKEN.ID == TKIDENTIFIER) EXPR = PSVARIABLEORFUNCTIONCALL();
 else if (LEXER.TOKEN.ID == TKLPAREN) {
WANTTOKENANDREAD(TKLPAREN);
EXPR = GENPARENS(PSEXPRESSION());
WANTTOKENANDREAD(TKRPAREN);
}
 else if (LEXER.TOKEN.ID == TKNOT) {
WANTTOKENANDREAD(TKNOT);
EXPR = UNARYEXPRESSION(TKNOT, PSFACTOR());
}
 else {
{
write_s(STDERR, str_make(29, "Invalid token in expression: "));
write_s(STDERR, LXTOKENSTR());
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
return_PSFACTOR = EXPR;
return return_PSFACTOR;
}
TPSEXPRESSION PSTERM() {
TPSEXPRESSION return_PSTERM;
TLXTOKENID OP;
TPSEXPRESSION EXPR;
EXPR = PSFACTOR();
while (ISOPMULTIPYING(LEXER.TOKEN)) {
OP = LEXER.TOKEN.ID;
READTOKEN();
EXPR = BINARYEXPRESSION(EXPR, OP, PSFACTOR());
}
return_PSTERM = EXPR;
return return_PSTERM;
}
TPSEXPRESSION PSSIMPLEEXPRESSION() {
TPSEXPRESSION return_PSSIMPLEEXPRESSION;
TLXTOKENID OP;
TPSEXPRESSION EXPR;
EXPR = PSTERM();
while (ISOPADDING(LEXER.TOKEN)) {
OP = LEXER.TOKEN.ID;
READTOKEN();
EXPR = BINARYEXPRESSION(EXPR, OP, PSTERM());
}
return_PSSIMPLEEXPRESSION = EXPR;
return return_PSSIMPLEEXPRESSION;
}
TPSEXPRESSION PSEXPRESSION() {
TPSEXPRESSION return_PSEXPRESSION;
TLXTOKENID OP;
TPSEXPRESSION EXPR;
EXPR = PSSIMPLEEXPRESSION();
while (ISOPRELATIONAL(LEXER.TOKEN)) {
OP = LEXER.TOKEN.ID;
READTOKEN();
EXPR = BINARYEXPRESSION(EXPR, OP, PSSIMPLEEXPRESSION());
}
return_PSEXPRESSION = EXPR;
return return_PSEXPRESSION;
}
void OUTEXPRESSION(TPSEXPRESSION EXPR) {
{
write_s(CODEGEN.OUTPUT, EXPR.VALUE);
}
}
void OUTASSIGN(TPSEXPRESSION LHS, TPSEXPRESSION RHS) {
{
write_s(CODEGEN.OUTPUT, LHS.VALUE);
write_s(CODEGEN.OUTPUT, str_make(3, " = "));
write_s(CODEGEN.OUTPUT, RHS.VALUE);
write_c(CODEGEN.OUTPUT, ';');
writeln(CODEGEN.OUTPUT);
}
}
void OUTASSIGNRETURNVALUE(TPSEXPRESSION LHS, TPSEXPRESSION RHS) {
{
write_s(CODEGEN.OUTPUT, str_make(7, "return_"));
write_s(CODEGEN.OUTPUT, DEFS.FUNCTIONS[(LHS.FUNCTIONINDEX) - 1].NAME);
write_s(CODEGEN.OUTPUT, str_make(3, " = "));
write_s(CODEGEN.OUTPUT, RHS.VALUE);
write_c(CODEGEN.OUTPUT, ';');
writeln(CODEGEN.OUTPUT);
}
}
void PSASSIGN(TPSEXPRESSION LHS, TPSEXPRESSION RHS) {
if (LHS.ISCONSTANT) {
{
write_s(STDERR, str_make(33, "Cannot assign to a constant value"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
if (LHS.CLS == TECFUNCTION) OUTASSIGNRETURNVALUE(LHS, COERCETYPE(RHS, DEFS.FUNCTIONS[(LHS.FUNCTIONINDEX) - 1].RETURNTYPEINDEX));
 else if (LHS.CLS == TECVALUE) OUTASSIGN(LHS, COERCETYPE(RHS, LHS.TYPEINDEX));
 else {
{
write_s(STDERR, str_make(36, "Cannot assign to result of statement"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
void OUTIF(TPSEXPRESSION EXPR) {
{
write_s(CODEGEN.OUTPUT, str_make(4, "if ("));
write_s(CODEGEN.OUTPUT, EXPR.VALUE);
write_s(CODEGEN.OUTPUT, str_make(2, ") "));
}
}
void OUTELSE() {
{
write_s(CODEGEN.OUTPUT, str_make(6, " else "));
}
}
void OUTREPEATBEGIN() {
{
write_s(CODEGEN.OUTPUT, str_make(4, "do {"));
writeln(CODEGEN.OUTPUT);
}
}
void OUTREPEATEND(TPSEXPRESSION EXPR) {
if (!ISBOOLEANTYPE(EXPR.TYPEINDEX)) {
{
write_s(STDERR, str_make(33, "Expected boolean expression, got "));
write_s(STDERR, TYPENAME(EXPR.TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
{
write_s(CODEGEN.OUTPUT, str_make(11, "} while (!("));
write_s(CODEGEN.OUTPUT, EXPR.VALUE);
write_s(CODEGEN.OUTPUT, str_make(3, "));"));
writeln(CODEGEN.OUTPUT);
}
}
void OUTWHILEBEGIN(TPSEXPRESSION EXPR) {
if (!ISBOOLEANTYPE(EXPR.TYPEINDEX)) {
{
write_s(STDERR, str_make(33, "Expected boolean expression, got "));
write_s(STDERR, TYPENAME(EXPR.TYPEINDEX));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
{
write_s(CODEGEN.OUTPUT, str_make(7, "while ("));
write_s(CODEGEN.OUTPUT, EXPR.VALUE);
write_s(CODEGEN.OUTPUT, str_make(2, ") "));
}
}
void OUTWHILEEND() {
}
void OUTFORBEGIN(TPSEXPRESSION ITER, TPSEXPRESSION FIRSTEXPR, TPSEXPRESSION LASTEXPR, PBoolean ASCENDING) {
TPSVARIABLE FIRST;
TPSVARIABLE LAST;
FIRST = MAKEVARIABLE(str_make(5, "first"), ITER.TYPEINDEX, 0);
LAST = MAKEVARIABLE(str_make(4, "last"), ITER.TYPEINDEX, 0);
{
write_c(CODEGEN.OUTPUT, '{');
writeln(CODEGEN.OUTPUT);
}
OUTVARIABLEDECLARATION(FIRST);
{
write_s(CODEGEN.OUTPUT, str_make(3, " = "));
write_s(CODEGEN.OUTPUT, FIRSTEXPR.VALUE);
write_c(CODEGEN.OUTPUT, ';');
writeln(CODEGEN.OUTPUT);
}
OUTVARIABLEDECLARATION(LAST);
{
write_s(CODEGEN.OUTPUT, str_make(3, " = "));
write_s(CODEGEN.OUTPUT, LASTEXPR.VALUE);
write_c(CODEGEN.OUTPUT, ';');
writeln(CODEGEN.OUTPUT);
}
{
write_s(CODEGEN.OUTPUT, str_make(10, "if (first "));
}
if (ASCENDING) {
write_s(CODEGEN.OUTPUT, str_make(2, "<="));
}
 else {
write_s(CODEGEN.OUTPUT, str_make(2, "=>"));
}
{
write_s(CODEGEN.OUTPUT, str_make(8, " last) {"));
writeln(CODEGEN.OUTPUT);
}
{
write_s(CODEGEN.OUTPUT, ITER.VALUE);
write_s(CODEGEN.OUTPUT, str_make(9, " = first;"));
writeln(CODEGEN.OUTPUT);
}
{
write_s(CODEGEN.OUTPUT, str_make(11, "while (1) {"));
writeln(CODEGEN.OUTPUT);
}
}
void OUTFOREND(TPSEXPRESSION ITER, PBoolean ASCENDING) {
{
write_s(CODEGEN.OUTPUT, str_make(4, "if ("));
write_s(CODEGEN.OUTPUT, ITER.VALUE);
write_s(CODEGEN.OUTPUT, str_make(16, " == last) break;"));
writeln(CODEGEN.OUTPUT);
}
if (ASCENDING) {
write_s(CODEGEN.OUTPUT, str_make(2, "++"));
write_s(CODEGEN.OUTPUT, ITER.VALUE);
write_c(CODEGEN.OUTPUT, ';');
writeln(CODEGEN.OUTPUT);
}
 else {
write_s(CODEGEN.OUTPUT, str_make(2, "--"));
write_s(CODEGEN.OUTPUT, ITER.VALUE);
write_c(CODEGEN.OUTPUT, ';');
}
{
write_c(CODEGEN.OUTPUT, '}');
writeln(CODEGEN.OUTPUT);
}
{
write_c(CODEGEN.OUTPUT, '}');
writeln(CODEGEN.OUTPUT);
}
{
write_c(CODEGEN.OUTPUT, '}');
writeln(CODEGEN.OUTPUT);
}
}
void OUTPROCEDURECALL(TPSEXPRESSION EXPR) {
{
write_s(CODEGEN.OUTPUT, EXPR.VALUE);
write_c(CODEGEN.OUTPUT, ';');
writeln(CODEGEN.OUTPUT);
}
}
void OUTEMPTYSTATEMENT() {
{
write_c(CODEGEN.OUTPUT, ';');
writeln(CODEGEN.OUTPUT);
}
}
void PSSTATEMENTSEQUENCE() {
OUTBEGIN();
SKIPTOKEN(TKBEGIN);
while (LEXER.TOKEN.ID != TKEND) {
PSSTATEMENT();
WANTTOKEN2(TKSEMICOLON, TKEND);
SKIPTOKEN(TKSEMICOLON);
}
OUTEND();
SKIPTOKEN(TKEND);
}
void PSIDENTIFIERSTATEMENT() {
TPSEXPRESSION LHS;
LHS = PSEXPRESSION();
if (LEXER.TOKEN.ID == TKASSIGN) {
WANTTOKENANDREAD(TKASSIGN);
PSASSIGN(LHS, PSEXPRESSION());
}
 else if (LHS.CLS != TECSTATEMENT) OUTPROCEDURECALL(LHS);
}
void PSIFSTATEMENT() {
WANTTOKENANDREAD(TKIF);
OUTIF(PSEXPRESSION());
WANTTOKENANDREAD(TKTHEN);
if (LEXER.TOKEN.ID == TKELSE) OUTEMPTYSTATEMENT();
 else PSSTATEMENT();
if (LEXER.TOKEN.ID == TKELSE) {
WANTTOKENANDREAD(TKELSE);
OUTELSE();
PSSTATEMENT();
}
}
void PSREPEATSTATEMENT() {
WANTTOKENANDREAD(TKREPEAT);
OUTREPEATBEGIN();
while (LEXER.TOKEN.ID != TKUNTIL) {
PSSTATEMENT();
WANTTOKEN2(TKSEMICOLON, TKUNTIL);
SKIPTOKEN(TKSEMICOLON);
}
WANTTOKENANDREAD(TKUNTIL);
OUTREPEATEND(PSEXPRESSION());
}
void PSWHILESTATEMENT() {
WANTTOKENANDREAD(TKWHILE);
OUTWHILEBEGIN(PSEXPRESSION());
WANTTOKENANDREAD(TKDO);
PSSTATEMENT();
OUTWHILEEND();
}
void PSFORSTATEMENT() {
TPSEXPRESSION ITER;
TPSEXPRESSION FIRST;
TPSEXPRESSION LAST;
PBoolean ASCENDING;
WANTTOKENANDREAD(TKFOR);
ITER = PSEXPRESSION();
if (!ISVARIABLEEXPRESSION(ITER)) {
{
write_s(STDERR, str_make(17, "Expected variable"));
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
WANTTOKENANDREAD(TKASSIGN);
FIRST = PSEXPRESSION();
WANTTOKEN2(TKTO, TKDOWNTO);
ASCENDING = LEXER.TOKEN.ID == TKTO;
READTOKEN();
LAST = PSEXPRESSION();
WANTTOKENANDREAD(TKDO);
OUTFORBEGIN(ITER, FIRST, LAST, ASCENDING);
PSSTATEMENT();
OUTFOREND(ITER, ASCENDING);
}
void PSSTATEMENT() {
if (LEXER.TOKEN.ID == TKSEMICOLON) OUTEMPTYSTATEMENT();
 else if (LEXER.TOKEN.ID == TKBEGIN) PSSTATEMENTSEQUENCE();
 else if (LEXER.TOKEN.ID == TKIDENTIFIER) PSIDENTIFIERSTATEMENT();
 else if (LEXER.TOKEN.ID == TKIF) PSIFSTATEMENT();
 else if (LEXER.TOKEN.ID == TKREPEAT) PSREPEATSTATEMENT();
 else if (LEXER.TOKEN.ID == TKWHILE) PSWHILESTATEMENT();
 else if (LEXER.TOKEN.ID == TKFOR) PSFORSTATEMENT();
 else {
{
write_s(STDERR, str_make(17, "Unexpected token "));
write_s(STDERR, LXTOKENSTR());
write_s(STDERR, LXWHERESTR());
writeln(STDERR);
}
HALT(1);
}
}
void OUTPROGRAMBEGIN() {
{
write_s(CODEGEN.OUTPUT, str_make(21, "void pascual_main() {"));
writeln(CODEGEN.OUTPUT);
}
}
void OUTPROGRAMEND() {
{
write_c(CODEGEN.OUTPUT, '}');
writeln(CODEGEN.OUTPUT);
}
}
void PSPROGRAMBLOCK() {
PSDEFINITIONS(GLOBALSCOPE);
WANTTOKENANDREAD(TKBEGIN);
OUTPROGRAMBEGIN();
while (LEXER.TOKEN.ID != TKEND) {
PSSTATEMENT();
WANTTOKEN2(TKSEMICOLON, TKEND);
SKIPTOKEN(TKSEMICOLON);
}
OUTPROGRAMEND();
WANTTOKENANDREAD(TKEND);
}
void PARSEPROGRAM() {
LEXER.POS.ROW = 0;
LEXER.POS.COL = 0;
STARTGLOBALSCOPE();
READTOKEN();
PSPROGRAMHEADING();
PSPROGRAMBLOCK();
WANTTOKENANDREAD(TKDOT);
WANTTOKEN(TKEOF);
}
void READTOKEN() {
TPSCONSTANTINDEX CONSTINDEX;
TLXPOS TOKENPOS;
do {
LXREADTOKEN();
if (LEXER.TOKEN.ID == TKIDENTIFIER) {
CONSTINDEX = FINDCONSTANT(LEXER.TOKEN.VALUE);
if (CONSTINDEX != 0) {
TOKENPOS = LEXER.TOKEN.POS;
LEXER.TOKEN = DEFS.CONSTANTS[(CONSTINDEX) - 1].REPLACEMENT;
LEXER.TOKEN.POS = TOKENPOS;
}
}
} while (!(LEXER.TOKEN.ID != TKCOMMENT));
}
void USAGE(STRING MSG) {
if (cmp_ss(MSG, str_make(0, "")) != 0) {
write_s(OUTPUT, MSG);
writeln(OUTPUT);
}
{
write_s(OUTPUT, PARAMSTR(0));
write_s(OUTPUT, str_make(18, " input [-o output]"));
writeln(OUTPUT);
}
HALT(0);
}
STRING REPLACEEXTENSION(STRING STR, STRING OLD, STRING NEW) {
STRING return_REPLACEEXTENSION;
int BASELEN;
int POS;
PBoolean MATCHES;
return_REPLACEEXTENSION = str_make(0, "");
BASELEN = LENGTH(STR) - LENGTH(OLD);
if (BASELEN > 0) {
MATCHES = 1;
{
int first = 1;
int last = LENGTH(OLD);
if (first <= last) {
POS = first;
while (1) {
MATCHES = MATCHES && (cmp_cc(UPCASE(STR.chr[POS + BASELEN]), UPCASE(OLD.chr[POS])) == 0);
if (POS == last) break;
++POS;
}
}
}
if (MATCHES) return_REPLACEEXTENSION = cat_ss(COPY(STR, 1, BASELEN), NEW);
}
return return_REPLACEEXTENSION;
}
void PARSECMDLINE() {
int POS;
STRING INPUTFILE;
STRING OUTPUTFILE;
enum { FLAGNONE, FLAGOUTPUT} FLAG;
STRING PARAM;
const char* EnumValues5[] = { "FLAGNONE", "FLAGOUTPUT" };
INPUTFILE = str_make(0, "");
OUTPUTFILE = str_make(0, "");
FLAG = FLAGNONE;
{
int first = 1;
int last = PARAMCOUNT();
if (first <= last) {
POS = first;
while (1) {
{
PARAM = PARAMSTR(POS);
if (cmp_cc(PARAM.chr[1], '-') == 0) {
if (cmp_ss(PARAM, str_make(2, "-o")) == 0) FLAG = FLAGOUTPUT;
 else if (cmp_ss(PARAM, str_make(2, "-h")) == 0) USAGE(str_make(0, ""));
 else USAGE(cat_ss(str_make(16, "Unknown option: "), PARAM));
}
 else if (FLAG == FLAGOUTPUT) {
if (cmp_ss(OUTPUTFILE, str_make(0, "")) != 0) USAGE(str_make(39, "Output file must be specified only once"));
 else OUTPUTFILE = PARAM;
FLAG = FLAGNONE;
}
 else {
if (cmp_ss(INPUTFILE, str_make(0, "")) != 0) USAGE(str_make(38, "Input file must be specified only once"));
 else INPUTFILE = PARAM;
}
}
if (POS == last) break;
++POS;
}
}
}
if (cmp_ss(OUTPUTFILE, str_make(0, "")) == 0) OUTPUTFILE = REPLACEEXTENSION(INPUTFILE, str_make(4, ".pas"), str_make(2, ".c"));
if (cmp_ss(INPUTFILE, str_make(0, "")) == 0) LEXER.INPUT = INPUT;
 else {
ASSIGN(&LEXER.INPUT, INPUTFILE);
RESET(&LEXER.INPUT);
}
if (cmp_ss(OUTPUTFILE, str_make(0, "")) == 0) CODEGEN.OUTPUT = OUTPUT;
 else {
ASSIGN(&CODEGEN.OUTPUT, OUTPUTFILE);
REWRITE(&CODEGEN.OUTPUT);
}
}
void pascual_main() {
PARSECMDLINE();
PARSEPROGRAM();
CLOSE(&LEXER.INPUT);
CLOSE(&CODEGEN.OUTPUT);
}
